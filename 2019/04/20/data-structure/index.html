
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>数据结构基本知识与常见的数据结构:数组、栈、队列、链表 - 小心心的笔记</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="所念皆星河，星河不及你,数据结构用来描述数据元素之间的关系
数据元素之间存在特定的关系，这种关系可以分为两种：逻辑结构和物理结构
数据关系逻辑结构逻辑结构描述了数据对象中数据元素之间的关系，按照逻辑结构可以分为四种：集合、,"> 
    <meta name="author" content="小心心"> 
    <link rel="alternative" href="atom.xml" title="小心心的笔记" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    <link rel="stylesheet" href="/css/diaspora.css">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">小心心的笔记</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://xinxinjs.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">数据结构基本知识与常见的数据结构:数组、栈、队列、链表</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">数据结构基本知识与常见的数据结构:数组、栈、队列、链表</h1>
        <div class="stuff">
            <span>四月 20, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>


        </div>
        <div class="content markdown">
            <p>数据结构用来描述数据元素之间的关系</p>
<p>数据元素之间存在特定的关系，这种关系可以分为两种：逻辑结构和物理结构</p>
<h2 id="数据关系"><a href="#数据关系" class="headerlink" title="数据关系"></a>数据关系</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构描述了数据对象中数据元素之间的关系，按照逻辑结构可以分为四种：集合、线性结构、树形结构、图形结构</p>
<h4 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h4><p>数据元素同属于一个集合，但是数据元素之间没有其他的关系，如图：</p>
<p><img src="/img/data/jihe.jpeg" alt="集合"></p>
<h4 id="线性结构："><a href="#线性结构：" class="headerlink" title="线性结构："></a>线性结构：</h4><p>是一组有序数据的集合，除了第一个元素和最后一个元素，其他的元素都是首位相接。</p>
<p>js中数组就是典型的线性结构，除此之外还有队列、栈和链表也是线性结构</p>
<p><img src="/img/data/xianxing.jpeg" alt="线性结构"></p>
<h4 id="树形结构："><a href="#树形结构：" class="headerlink" title="树形结构："></a>树形结构：</h4><p>数据元素是一对多的关系</p>
<p>前端最常接触的树形结构是DOM树</p>
<p><img src="/img/data/shuxing.jpeg" alt="树形"></p>
<h4 id="图形结构："><a href="#图形结构：" class="headerlink" title="图形结构："></a>图形结构：</h4><p>数据元素是多对多的关系</p>
<p>比如地图导航就是使用的图形结构来存储数据</p>
<p><img src="/img/data/tuxing.jpeg" alt="图形"></p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>物理结构描述数据在内存中是如何存储的，数据的存储结构应该正确的反应数据之间的逻辑关系</p>
<p>分为：顺序存储（连续内存）和链式存储（非连续内存）</p>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>数据在内存中是连续内存地址来存储的，数据元素之间的逻辑关系和物理关系是一致的</p>
<p>给数据分配内存的时候会在内存中开辟一段连续的内存地址</p>
<p><img src="/img/data/shunxu.jpeg" alt="顺序存储"></p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>链式存储会把数据元素放在任意的内存地址，可以是连续的地址，也可以是不连续的，链式存储是不能反映出数据元素之间的逻辑关系，所以链式存储需要一个叫做指针的东西，</p>
<p>指针可以反映出链式存储的数据元素之间的逻辑关系</p>
<p><img src="/img/data/lianshi.jpeg" alt="链式存储"></p>
<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><p><img src="/img/data/changjian.jpeg" alt="常见的数据结构"></p>
<p>下面是常见的数据结构的基本知识，和优缺点</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是比较常用的数据结构。作为一个前端，主要需要了解js的数组。</p>
<p>首先先了解一下传统意义上的数组的概念是：相同类型元素的有序集合，计算机会在内存中开辟一段连续的内存空间来存储数组</p>
<p>但是js中的数组我们有时候会写成这样子：<code>[1, &#39;a&#39;, &#39;b&#39;, 2]</code>，这显然不符合传统意义对于数组的定义，人家要求是相同类型的数据，所以说js中的数组不是传统意义上的数组。</p>
<p>在js中定义一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<p>数组的每一个元素都有一个索引，从0开始，连续排列：</p>
<p><img src="/img/data/shuzu.jpeg" alt="数组"></p>
<p>那么在js中数组作为比较常见的数据结构他有什么优点呢：</p>
<ol>
<li><p>从上图看出，可以按照索引查询数组元素，速度会很快，我们在js语言中可以通过<code>array[index]</code>的方式来快速的查询数组元素</p>
</li>
<li><p>数组可以存储大量的数据</p>
</li>
<li><p>可以通过索引去遍历数组</p>
</li>
</ol>
<p>数组的缺点：在js的数组中插入和删除的时候不太方便，从上面的图片可以看出索引和数组元素一一对应、连续排列，当我们对数组进行插入和删除操作的时候，索引和数组元素的对应关系在内存会重新整理，比如插入一个元素，在插入元素的位置后面的元素都要依次往后移动相应的位置，删除数组元素的时候，从删除元素位置后面的元素都要依次往前移动相对应的位置。这些移动的操作都会消耗一定的内存</p>
<p><img src="/img/data/caozuoshuzu.jpeg" alt="数组"></p>
<p>所以要尽量避免从数组的头部插入或者删除元素，因为这样子数组里的每一个元素都要移动。尽可能的从数组的尾部插入或者删除元素</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>在内存中有一个叫做栈内存，内存中的栈是真实存在的物理区，而我们这里讨论的是数据结构中的栈，是从栈内存抽象而来的数据结构存储结构</p>
<p>我们先来看一下栈的一些概念：</p>
<ol>
<li><p>是一种受限制的线性表，遵循后进先出的规则：（LIFO）last in first out</p>
</li>
<li><p>受限制：仅允许在栈的一端进行插入和删除操作，这一端称之为栈顶，相对的另外一端称之为栈底</p>
</li>
<li><p>向一个栈插入新元素的操作称作：进栈、入栈、或者压栈</p>
</li>
<li><p>从一个栈删除元素又称之为退栈、出栈</p>
</li>
</ol>
<p>下面这张图可以形象的描述栈的概念和受限制的操作</p>
<p><img src="/img/data/zhan.jpeg" alt="栈"></p>
<p>在js语言中可以通过数组的push和pop方法实现栈的数据结构方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往栈内添加一个元素</span></span><br><span class="line">  push(ele) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(ele);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原属出栈</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈顶元素</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为空栈</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取栈中元素的个数</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空栈</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stack) <span class="comment">// Stack &#123;items: [1,2,3,4]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.pop()) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.size()) <span class="comment">// 3</span></span><br><span class="line">stack.clear();</span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="栈的实际运用"><a href="#栈的实际运用" class="headerlink" title="栈的实际运用"></a>栈的实际运用</h4><p>在js语言中实现栈的数据结构操作还是比较简单的，那么栈在实际运用中有什么作用呢？学习栈这个数据结构对我们学习和使用js有什么帮助呢</p>
<h5 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h5><p>例如我们要把十进制数字100转换成二进制，需要使用除2取余，逆序排列</p>
<p><img src="/img/data/10-2.jpeg" alt="十进制转二进制"></p>
<p>由此得出100转二进制的结果是1100100</p>
<p>那么如何用js的栈区实现这个算法呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binary = <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">let</span> remainder = <span class="number">0</span> <span class="comment">// 余数</span></span><br><span class="line">  <span class="keyword">let</span> top = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    remainder = number % <span class="number">2</span>;</span><br><span class="line">    stack.push(remainder);</span><br><span class="line">    number = <span class="built_in">Math</span>.floor(number / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">    top += stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(binary(<span class="number">100</span>)); <span class="comment">// 1100100</span></span><br></pre></td></tr></table></figure>
<h5 id="理解js的调用栈"><a href="#理解js的调用栈" class="headerlink" title="理解js的调用栈"></a>理解js的调用栈</h5><p>js是单线程的，代码自上而下的执行，依次进栈，执行完成之后代码出栈</p>
<p>如下图所示，首先是全局执行上下文入栈，然后outer函数入栈，最后inner函数入栈，然后inner函数出栈，outer函数出栈，全局环境出栈</p>
<p><img src="/img/data/diaoyongzhan.jpeg" alt="调用栈"></p>
<h5 id="递归的原理"><a href="#递归的原理" class="headerlink" title="递归的原理"></a>递归的原理</h5><p>从上面可以看出函数执行的时候就是函数的进栈和出栈，执行的时候函数先入栈，执行完了出栈，但是在函数调用的时候有一个特殊的情况，就是递归。</p>
<p>执行递归的时候会进入递归栈：函数先进栈，达到跳出条件后在出栈，如果没有出栈就会导致栈溢出</p>
<p>从一个数字n的阶乘来理解递归</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factor</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factor(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factor(<span class="number">5</span>)) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>这个5的阶乘的函数调用栈如图所示:</p>
<p><img src="/img/data/jiecheng.jpeg" alt="调用栈"></p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种运算受限制的线性表，它遵循一种先进先出的规则</p>
<ol>
<li><p>只能在队列的前端进行删除操作</p>
</li>
<li><p>在队列的尾端进行插入</p>
</li>
</ol>
<p>![队列](/img/data/duilie.jpeg</p>
<p>用js实现一个队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  enqueue(ele) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看队头</span></span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看队尾</span></span><br><span class="line">  rear() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length<span class="number">-1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取长度</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列这种数据结构，一般用于排队去一个一个的解决问题</p>
<p>那么队列这种数据结构和我们前端有什么关系呢？</p>
<h4 id="理解js的任务队列"><a href="#理解js的任务队列" class="headerlink" title="理解js的任务队列"></a>理解js的任务队列</h4><p>js在浏览器中运行是单线程的，在js程序运行的时候会，所有的代码都是依次执行，不同的是：有的代码会立即执行，而有的代码则需要等待一定的时间才可以执行，比较常见的就是请求一个接口，等待接口有返回内容之后再去执行相应的代码</p>
<p>立即执行的代码叫做同步任务，需要等待执行的代码叫做异步任务，同步任务立即执行，同步任务是立即执行的但是也需要在主线程排队依次执行，这个排队的地方叫做调用栈，或者执行栈,</p>
<p>为了避免异步任务阻塞后面的同步任务的执行，js有一个异步任务队列，在执行到异步任务的时候，会把异步任务先放进异步任务队列，等待执行</p>
<p>等同步代码的调用栈里面的代码全部都执行完了以后，会依次把异步任务队列里面的代码进入调用栈执行，等到调用栈再次清空之后，再去执行异步的任务队列，这个往复循环的过程叫做js的事件循环机制</p>
<p>主线程读取任务队列并执行任务遵循先进先出的机制顺序</p>
<p>js是单线程语言，浏览器只会分配一个主线程给js，用来执行任务</p>
<p>异步任务队列分为：宏任务队列和微任务队列，同样都是异步任务，微任务队列是优先于宏任务队列执行的</p>
<p>最后js的任务执行优先顺序：同步任务-&gt;微任务-&gt;宏任务</p>
<p>宏任务：I/O 、定时器、事件绑定、ajax</p>
<p>微任务：promise.then catch finally process.nextTick async await</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>前面说过数组，数组是最常见的数据结构，数组的优点就是查询比较快速，但是当我们对数组进行插入和删除的时候就比较麻烦。</p>
<p>那么为了解决数组的插入和删除比较麻烦的这个事情，链表就可以很好的解决数组的这个痛点，链表可以很方便快速的进行插入和删除</p>
<h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><ol>
<li><p>链表在物理内存上是链式存储，相邻元素不一定是连续的物理空间</p>
</li>
<li><p>链表的每一个元素包含元素本身和一个指向下一个元素的引用，或者早有些语言里面叫做指针</p>
</li>
</ol>
<h4 id="链表和数组的比较"><a href="#链表和数组的比较" class="headerlink" title="链表和数组的比较"></a>链表和数组的比较</h4><ol>
<li><p>插入、删除操作，链表速度快性能好</p>
</li>
<li><p>查询、修改操作，数组的性能好</p>
</li>
<li><p>链表没有大小的限制，支持动态的扩容，js的数组是支持动态改变长度的，但是在很多其他的语言中，数组的大小是不能动态修改的</p>
</li>
<li><p>因为链表需要存储指向下一个元素的指针，在内存上的消耗也比数组来的大，就是翻倍的内存</p>
</li>
</ol>
<h4 id="用js语言实现一个链表"><a href="#用js语言实现一个链表" class="headerlink" title="用js语言实现一个链表"></a>用js语言实现一个链表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">          <span class="keyword">this</span>.element = element;</span><br><span class="line">          <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>() &#123;</span><br><span class="line">          <span class="comment">// 链表的长度</span></span><br><span class="line">          <span class="keyword">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">// 链表的长度</span></span><br><span class="line">          <span class="keyword">this</span>.length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在链表的尾部追加元素</span></span><br><span class="line">        append(element) &#123;</span><br><span class="line">          <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span>(current.next) &#123;</span><br><span class="line">              current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取链表的头</span></span><br><span class="line">        getHead() &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.head;</span><br><span class="line">        &#125;</span><br><span class="line">        toString() &#123;</span><br><span class="line">          <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">          <span class="keyword">let</span> linkString = <span class="string">''</span>;</span><br><span class="line">          <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            linkString += <span class="string">','</span> + current.element;</span><br><span class="line">            current = current.next</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> linkString.slice(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        insert(element, position) &#123;</span><br><span class="line">          <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">          <span class="comment">// 上一个元素</span></span><br><span class="line">          <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">          <span class="keyword">if</span>(position === <span class="number">0</span>) &#123;</span><br><span class="line">            node.next = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">this</span>.head = node;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">              prev = current;</span><br><span class="line">              current = current.next;</span><br><span class="line">              index++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = current;</span><br><span class="line">            prev.next = node;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.length += <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getPosition(position) &#123;</span><br><span class="line">          <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt; <span class="keyword">this</span>.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">          <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            index++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">        removeAt(position) &#123;</span><br><span class="line">          <span class="keyword">if</span>(position &lt; <span class="number">0</span> || position &gt;= <span class="keyword">this</span>.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">          <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">if</span>(position === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head === <span class="keyword">this</span>.head.next;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; position) &#123;</span><br><span class="line">              prev = current</span><br><span class="line">              current = current.next;</span><br><span class="line">              index++;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = current.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.length--;</span><br><span class="line">          <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">      linkedList.append(<span class="number">1</span>)</span><br><span class="line">      linkedList.append(<span class="number">2</span>)</span><br><span class="line">      linkedList.append(<span class="number">3</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(linkedList);</span><br><span class="line">      <span class="built_in">console</span>.log(linkedList.removeAt(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>我们在控制台打印出来长这样子：</p>
<p><img src="/img/data/lianbiao.jpeg" alt="十进制转二进制"></p>
<p>由图可见，每个元素里面都有一个指向下一个元素的引用</p>
<h4 id="链表分类"><a href="#链表分类" class="headerlink" title="链表分类"></a>链表分类</h4><ol>
<li><p>单项链表</p>
</li>
<li><p>双向链表</p>
</li>
</ol>
<h4 id="从链表的角度理解js的原型链"><a href="#从链表的角度理解js的原型链" class="headerlink" title="从链表的角度理解js的原型链"></a>从链表的角度理解js的原型链</h4><p>众所周知，javascript这门语言是基于对象的开发的，在面向对象的语言里面实现继承有两种方式：接口继承和实现继承</p>
<p>js语言无法实现接口继承，只支持实现继承，而js的实现继承主要是依靠的js的原型链机制</p>
<p>首先要记住两个：</p>
<ol>
<li><p>所有的函数都有一个<code>prototype</code>属性，该属性是一个普通的对象，一个隐式的对象</p>
</li>
<li><p>所有的引用类型，都有一个<code>__proto__</code>属性是一个普通的对象，显示对象</p>
</li>
</ol>
<p>例如我们写一个构造函数，构造函数也是函数，所有构造函数会有一个prototype属性，是一个隐式的对象,我们通常叫做原型对象，包含由特定类型的实例共享的属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'name'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(SuperType)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为prototype属性是隐式的对象，所以打印出来的是函数体</span></span><br><span class="line"><span class="comment"> SuperType() &#123;</span></span><br><span class="line"><span class="comment">  this.name = 'name';</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//  我们可以手动的打印一下prototype属性</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype)</span><br></pre></td></tr></table></figure>
<p>第二个console，我们手动的打印了prototype属性，打印出来的是构造函数的方法和一个原型对象，我们可以看到原型对象，如下图:</p>
<p><img src="/img/data/yuanxing.jpeg" alt="图片"></p>
<p>从图中可以看出来构造函数的prototype是一个对象，所以包含一个<code>__proto__</code>属性和一个<code>constructor</code>属性，这个<code>constructor</code>指向这个原型对象的构造函数，也就是SuperType</p>
<p>还包含原型对象上的方法</p>
<p>然后我们实例化SuperType，返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> SuperType())</span><br></pre></td></tr></table></figure>
<p><img src="/img/data/shilihua.jpeg" alt="图片"></p>
<p>从上图可以看出，通过new关键字实例化返回的是一个对象，这个对象包含构造函数上的方法和属性，同时和其他普通对象一样，包含一个<code>__proto__</code>属性，这个<code>__proto__</code>属性包含构造函数的原型上的属性和方法。还有一个<code>constructor</code>属性，指向这个实例的构造函数</p>
<p>画个图表示一下</p>
<p><img src="/img/data/gouzaohanshu.svg" alt="图片"></p>
<p>而我们是如何通过原型链实现j的继承呢？简单的说一下就是让第二个原型对象等于另一个对象的实例，</p>
<p>先从代码的角度看一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父级函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'name'</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子级函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子级的原型对象等于父级的实例</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype);</span><br></pre></td></tr></table></figure>
<p>我们先打印一下SubType.prototype，发现和我们刚才打印<code>console.log(new SuperType())</code>打印出来的是一样的，因为SubType的prototype就是Supertype的实例，但是也不是一摸一样，因为这还包含了SubType自己的原型上的方法</p>
<p>然后我们实例化一个这个新的构造函数，在打印一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p><img src="/img/data/jicheng.svg" alt="图片"></p>
<p>从控制台可看出来，实例化返回一个新的对象，这个对象和其他实例化的对象一样，首先包含它构造函数上的属性和方法，然后包含一个<code>__proto__</code>属性，这个<code>__proto__</code>属性包含它的构造函数的原型上的属性和方法。而Subtype的原型又是SuperType的实例，所以同时包含了SuperType原型上的方法和属性，</p>
<p>再有第三个构造函数要实现继承也是如此实现，语言太啰嗦不清晰，画图表示一下</p>
<p><img src="/img/data/jichenglianbiao.svg" alt="图片"></p>
<p>从图中可以看出来，原型链的继承的数据结构是链表的结构实现的，而所有的对象最终的继承都是Object</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='/music/夜的钢琴曲(五).mp3'></li>
                        
                    
                        
                            <li title='1' data-url='/music/S.E.N.S. (神思者)-伽罗 (Kyara).mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据关系"><span class="toc-number">1.</span> <span class="toc-text">数据关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑结构"><span class="toc-number">1.1.</span> <span class="toc-text">逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#集合："><span class="toc-number">1.1.1.</span> <span class="toc-text">集合：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线性结构："><span class="toc-number">1.1.2.</span> <span class="toc-text">线性结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树形结构："><span class="toc-number">1.1.3.</span> <span class="toc-text">树形结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图形结构："><span class="toc-number">1.1.4.</span> <span class="toc-text">图形结构：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#物理结构"><span class="toc-number">1.2.</span> <span class="toc-text">物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序存储"><span class="toc-number">1.2.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链式存储"><span class="toc-number">1.2.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的数据结构"><span class="toc-number">2.</span> <span class="toc-text">常见的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">2.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈"><span class="toc-number">2.2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的实际运用"><span class="toc-number">2.2.1.</span> <span class="toc-text">栈的实际运用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#十进制转二进制"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">十进制转二进制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#理解js的调用栈"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">理解js的调用栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#递归的原理"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">递归的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列"><span class="toc-number">2.3.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理解js的任务队列"><span class="toc-number">2.3.1.</span> <span class="toc-text">理解js的任务队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表"><span class="toc-number">2.4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#链表的定义"><span class="toc-number">2.4.1.</span> <span class="toc-text">链表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表和数组的比较"><span class="toc-number">2.4.2.</span> <span class="toc-text">链表和数组的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用js语言实现一个链表"><span class="toc-number">2.4.3.</span> <span class="toc-text">用js语言实现一个链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表分类"><span class="toc-number">2.4.4.</span> <span class="toc-text">链表分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从链表的角度理解js的原型链"><span class="toc-number">2.4.5.</span> <span class="toc-text">从链表的角度理解js的原型链</span></a></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
