<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>每日一题</title>
    <url>/2019/04/14/201904example-1/</url>
    <content><![CDATA[<p>下面的代码，a如何处理才能打印出‘success’</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相等操作符，等号两边的数据类型不一样的时候，有一个隐式类型转换，先转换再比较，转换规则</p>
<ul>
<li>null 相等于 undefined，null和undefined和其他值比较的时候不相等</li>
<li>NaN 不等于NaN，也不等于其他任何的值</li>
<li>对象和字符串比较，先调用对象的toString方法把对象转换成字符串，进行比较</li>
<li>剩下的转换成数字</li>
</ul>
<h2 id="重写的对象toString方法"><a href="#重写的对象toString方法" class="headerlink" title="重写的对象toString方法"></a>重写的对象toString方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  i: <span class="number">0</span>,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++<span class="keyword">this</span>.i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重写数组的toString方法"><a href="#重写数组的toString方法" class="headerlink" title="重写数组的toString方法"></a>重写数组的toString方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">a.toString = a.shift;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题的解决方案</title>
    <url>/2017/04/14/201904CO/</url>
    <content><![CDATA[<h2 id="为什么会产生跨域"><a href="#为什么会产生跨域" class="headerlink" title="为什么会产生跨域"></a>为什么会产生跨域</h2><p>前后端分离，前端的代码和服务端的代码分别部署在不同的域名下，导致的跨域问题</p>
<p>协议，域名端，口号不一样都是跨域</p>
<h2 id="跨域资源共享CORS"><a href="#跨域资源共享CORS" class="headerlink" title="跨域资源共享CORS"></a>跨域资源共享CORS</h2><p>定义在访问跨域资源的时候，浏览器与服务端如何沟通</p>
<p>使用自定义的HTTP头部让浏览器与服务器进行沟通，例如：</p>
<p>Origin: <a href="http://xx.com:80" target="_blank" rel="noopener">http://xx.com:80</a></p>
<p>如果浏览器可以处理请求，就在Access-Control-Allow-Origin头部中返回相同的源信息，例如</p>
<p>Access-Control-Allow-Origin: <a href="http://xx.com:80" target="_blank" rel="noopener">http://xx.com:80</a></p>
<h2 id="其他的跨域方案"><a href="#其他的跨域方案" class="headerlink" title="其他的跨域方案"></a>其他的跨域方案</h2><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>动态创建script标签， src赋值为要请求的地址，仅支持get请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  function func(data) &#123;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://xx.com/list/callback=func'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jsonp存在的问题：不安全、有缓存、传递的信息有限制、需要服务器处理</p>
<h3 id="服务端允许跨域"><a href="#服务端允许跨域" class="headerlink" title="服务端允许跨域"></a>服务端允许跨域</h3><p>设置一个允许跨域访问的源：Access-Control-Allow-Origin: <a href="http://xx.com:80" target="_blank" rel="noopener">http://xx.com:80</a></p>
<h3 id="webpack-proxy"><a href="#webpack-proxy" class="headerlink" title="webpack proxy"></a>webpack proxy</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"proxy": "代里地址"</span><br></pre></td></tr></table></figure>
<h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题之防抖节流</title>
    <url>/2021/04/13/202004debounce-throttle/</url>
    <content><![CDATA[<p>防抖和节流都是优化高频率执行代码的一种手段，例如浏览器的resize，scroll，input等事件，</p>
<p>这些事件在被触发的时候会不断的调用绑定在事件上的回调函数，这个就会极大的浪费资源，降低前端的性能</p>
<p>为了优化体验就需要对这些代码的调用次数做限制，所使用的方法就是防抖或者节流算法</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖的概念：连续触发事件N秒后执行该函数，如果在N秒内事件被重复触发，则重新计时</p>
<p>防抖算法：使用闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">delay, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        callback(value);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存在外部调用</span></span><br><span class="line"><span class="keyword">const</span> debounceFunc = debounce(<span class="number">1000</span>, func);</span><br><span class="line"><span class="keyword">const</span> click = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  debounceFunc(e.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用场景：防止重复的执行</p>
<ul>
<li><p>搜索框输入查询，用户连续触发input事件，在停止输入后的N秒执行函数</p>
</li>
<li><p>手机号码验证输入，用户连续触发input事件，在停止输入的N秒之后做校验</p>
</li>
<li><p>窗口大小改变，用户连续拖动改变窗口的大小，在停止拖动N秒之后执行函数</p>
</li>
</ul>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>N秒内之运行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">delay, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        callback(value);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用场景：</p>
<ul>
<li><p>滚动加载</p>
</li>
<li><p>加载更多</p>
</li>
<li><p>滚到底部监听</p>
</li>
<li><p>搜索联想功能</p>
</li>
</ul>
<h2 id="防抖和节流的相同之处"><a href="#防抖和节流的相同之处" class="headerlink" title="防抖和节流的相同之处"></a>防抖和节流的相同之处</h2><ol>
<li><p>实现方法，都是通过setTimeout实现的</p>
</li>
<li><p>目的一样，都是想要降低高频代码的执行顺序</p>
</li>
</ol>
<h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><ol>
<li><p>防抖是在一段连续操作结束后处理回调，利用clearTimeout和setTimeout实现</p>
</li>
<li><p>节流，是在一段连续操作中，每一段事件执行一次</p>
</li>
</ol>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>数据结构与算饭</tag>
      </tags>
  </entry>
  <entry>
    <title>函数内部this指向问题</title>
    <url>/2019/04/13/202004this/</url>
    <content><![CDATA[<p>this是一个对象，是在函数运行的时候基于函数的运行环境绑定的</p>
<p>关于this指向的问题，可以简单的概括一句话：谁调用我，我就指向谁</p>
<h2 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h2><p>在不同的场景下this的指向会不太一样，例如：</p>
<h3 id="普通函数内部this指向window"><a href="#普通函数内部this指向window" class="headerlink" title="普通函数内部this指向window"></a>普通函数内部this指向window</h3><p>严格模式下this指向undefined，在函数内部执行：console.log(this)，控制台会输出undefined</p>
<p>非严格模式下，this指向window，就是在window下调用了这个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数中，this指向window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window &#123;window: Window, self: Window, document: document, name: "", location: Location, …&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window &#123;window: Window, self: Window, document: document, name: "", location: Location …&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  aa()</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<h3 id="在对象的方法中this指向这个对象"><a href="#在对象的方法中this指向这个对象" class="headerlink" title="在对象的方法中this指向这个对象"></a>在对象的方法中this指向这个对象</h3><p>通过对象成员访问‘.’的方式调用，this指向这个对象，也就是这个对象调用了这个方法，所以这个方法的this指向这个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 在对象的方法中，指向sayHi对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// window，this指向window，是因为这个函数是一个普通的函数，并不少某个对象的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    fn1();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 闭包window</span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.sayHi();</span><br></pre></td></tr></table></figure>
<h3 id="在定时器中指向window"><a href="#在定时器中指向window" class="headerlink" title="在定时器中指向window"></a>在定时器中指向window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="在构造函数中"><a href="#在构造函数中" class="headerlink" title="在构造函数中"></a>在构造函数中</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 指向实例对象：Person&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<h3 id="在事件处理函数中指向"><a href="#在事件处理函数中指向" class="headerlink" title="在事件处理函数中指向"></a>在事件处理函数中指向</h3><p>指向绑定事件的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 绑定事件对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="在匿名函数中指向window"><a href="#在匿名函数中指向window" class="headerlink" title="在匿名函数中指向window"></a>在匿名函数中指向window</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>func.call(调用者，参数1，参数2)</code></p>
<p>调用的时候函数会被立即执行，函数体内的this指向调用者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'xinxin'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">b.call(obj, <span class="string">'lll'</span>); <span class="comment">// this指向调用者：obj</span></span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>func.apply(调用者, [参数1，...])</code></p>
<p>调用的时候函数会被立即执行，函数体内的this指向调用者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'xinxin'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">b.call(obj, [<span class="string">'111'</span>]); <span class="comment">// this指向调用者：obj</span></span><br></pre></td></tr></table></figure>
<h3 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h3><p><code>func.bind(调用者，参数1，参数2)</code></p>
<p>调用的时候函数不会被立即执行，返回一个新的函数，函数体内的this指向调用者，需要手动调用新的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'xinxin'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bb = b.bind(obj, <span class="string">'lll'</span>); <span class="comment">//this指向obj</span></span><br><span class="line">bb();</span><br></pre></td></tr></table></figure>
<h2 id="为什么内部函数和匿名函数没有取得外部包含作用域的this对象呢"><a href="#为什么内部函数和匿名函数没有取得外部包含作用域的this对象呢" class="headerlink" title="为什么内部函数和匿名函数没有取得外部包含作用域的this对象呢"></a>为什么内部函数和匿名函数没有取得外部包含作用域的this对象呢</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 在对象的方法中，指向sayHi对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    fn1();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 闭包window</span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.sayHi();</span><br></pre></td></tr></table></figure>
<p>在函数被调用的时候，会自动获取两个特殊的对象：arguments和this，内部函数在搜索这两个变量的时候，只会搜索到其活动对象位置，因此永远不能访问外部函数中的这两个对象。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>SMART原则</title>
    <url>/2020/11/26/202011-smartstandard/</url>
    <content><![CDATA[<p>SMART原则，是一种目标的制定和考核标准，使考核更加科学化、规范化，更能保证考核的公正、公开与公平。</p>
<h2 id="SMART原则解析"><a href="#SMART原则解析" class="headerlink" title="SMART原则解析"></a>SMART原则解析</h2><ul>
<li><p>S=Specific、具体的，就是说目标的制定必须是具体的，不能笼统</p>
</li>
<li><p>M=Measurable、可衡量的，目标是可以量化或者行为化的，验证指标是否达到标准的数据是可以获得的</p>
</li>
<li><p>A=Attainable、可实现的，指标在付出努力的情况下是可以达到的，不能设立的太高或者太低</p>
</li>
<li><p>R=Relevant、相关的，指标是与本职工作相关的</p>
</li>
<li><p>T=Time-bound、有时限的，指标具体完成的日期或者期限</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>营销需求管理</title>
    <url>/2021/01/01/202101-xuqiu/</url>
    <content><![CDATA[<p>营销专家、科特勒集团合伙人王赛老师曾经提出过一个新鲜的观点，他说需求管理是营销的本质，营销回到原点，就是对需求的研究。</p>
<p>王赛老师认为，好的「需求管理」需要解决两个问题。</p>
<h2 id="如何有效的发现差异化的需求"><a href="#如何有效的发现差异化的需求" class="headerlink" title="如何有效的发现差异化的需求"></a>如何有效的发现差异化的需求</h2><p>首先由于资源有限，所以企业不可能服务于市场中所有的客户，而是根据自己的资源状况和竞争优势选择特定的细分市场才能够立足。</p>
<p>如果我们的产品和营销不是差异化的，而是同质化的，往往就会陷入惨烈的竞争，甚至价格战中</p>
<p>name，如何发现一个差异化的需求呢，王赛老师认为，归根结底是要找到好的细分市场。</p>
<p>一个好的细分市场满足三个条件：</p>
<ol>
<li><p>用户的需求个性且多元</p>
</li>
<li><p>细分市场的容量足够大，可以养得活这家企业</p>
</li>
<li><p>这个细分市场用户的频次还不高，还有挖掘空间</p>
</li>
</ol>
<h2 id="如何打造产品独特的价值点，让客户喜欢你的产品和服务"><a href="#如何打造产品独特的价值点，让客户喜欢你的产品和服务" class="headerlink" title="如何打造产品独特的价值点，让客户喜欢你的产品和服务"></a>如何打造产品独特的价值点，让客户喜欢你的产品和服务</h2><p>寻找价值点是满足需求的核心</p>
<p>三角价值的营销工具：盲点，痛点、甜点</p>
<p>盲点：需求背后的需求，也就是明白客户真正的需求</p>
<p>痛点：指的是用户在使用产品和服务当中，没有被满足所形成的心里落差和不满，发觉痛点就是找到用户有负面情绪的地方</p>
<p>甜点：甜点是指和竞争对手做同样的事情，你也做，我也做，但是我比你做的更好，甜点本质上就是做增加值</p>
]]></content>
      <categories>
        <category>营销</category>
      </categories>
      <tags>
        <tag>营销</tag>
      </tags>
  </entry>
  <entry>
    <title>关于项目风险来源</title>
    <url>/2021/03/05/202102-project-risk/</url>
    <content><![CDATA[<p><img src="/img/project/项目风险来源.png" alt="图片"></p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重的三种思路</title>
    <url>/2017/04/14/202104-sf-unrepeated/</url>
    <content><![CDATA[<h2 id="双层循环去重"><a href="#双层循环去重" class="headerlink" title="双层循环去重"></a>双层循环去重</h2><p>基本思路就是：声明一个空数组作为去重之后的数组，第一层循环遍历要去重数组使用for或者forEach，第二层循环循环新数组，判断新数组里面没有第一次循环的当前项，就把当前项push进新的数组</p>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> b = []</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b.indexOf(a[i]) == <span class="number">-1</span>) &#123;</span><br><span class="line">          b.push(a[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> b = []</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!b.includes(a[i])) &#123;</span><br><span class="line">          b.push(a[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="es6方法-Array-from-new-Set-arr"><a href="#es6方法-Array-from-new-Set-arr" class="headerlink" title="es6方法 Array.from(new Set(arr))"></a>es6方法 Array.from(new Set(arr))</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(a)) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="利用对象的属性不能重复"><a href="#利用对象的属性不能重复" class="headerlink" title="利用对象的属性不能重复"></a>利用对象的属性不能重复</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  c[a[i]] = a[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(c))</span><br></pre></td></tr></table></figure>
<p>这个方法的缺点就是对象的key都是字符串，如果数组的值为number或者其他类型的时候，就会转换成字符串，在某些场景下不适用</p>
]]></content>
      <categories>
        <category>数据结构与算饭</category>
      </categories>
      <tags>
        <tag>数据结构与算饭</tag>
      </tags>
  </entry>
  <entry>
    <title>cookies、sessionStorage和localStorage的区别</title>
    <url>/2018/04/15/202104cunchu/</url>
    <content><![CDATA[<h2 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h2><p>大小最多只有4k,每次访问接口http都会自动带上cookies</p>
<p>主要作用是用来保存登陆信息</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>存储大小有5M，把出局存储在本地，如果浏览器被关闭了，下次打开他还在</p>
<p>应用场景：购物车，表单暂存</p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>存储大小也是5M，存储在session对象中，如果浏览器被关闭了sessionStorage会被清空</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>不容错过的 Babel7 知识</title>
    <url>/2019/03/31/babel-7start/</url>
    <content><![CDATA[<p>博客原文地址：<a href="https://juejin.im/post/5ddff3abe51d4502d56bd143" target="_blank" rel="noopener">不容错过的 Babel7 知识</a></p>
<p>简单了解Babel</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Babel 是一个 JS 编译器。</p>
<p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<h2 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h2><ul>
<li><p>语法转换</p>
</li>
<li><p>通过 Polyfill 方式在目标环境中添加缺失的特性(@babel/polyfill模块)</p>
</li>
<li><p>源码转换(codemods)</p>
</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="核心库-babel-core"><a href="#核心库-babel-core" class="headerlink" title="核心库 @babel/core"></a>核心库 @babel/core</h3><p>不安装 @babel/core，无法使用 babel 进行编译。</p>
<p>npm install –save-dev @babel/core</p>
<h3 id="CLI命令行工具-babel-cli"><a href="#CLI命令行工具-babel-cli" class="headerlink" title="CLI命令行工具 @babel/cli"></a>CLI命令行工具 @babel/cli</h3><p>babel 提供的命令行工具，主要是提供 babel 这个命令，适合安装在项目里。</p>
<p>@babel/node 提供了 babel-node 命令，但是 @babel/node 更适合全局安装，不适合安装在项目里。</p>
<p>npm install –save-dev @babel/cli</p>
<p>将命令配置在 package.json 文件的 scripts 字段中:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "compiler": "babel src --out-dir lib --watch"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>配置在.babelrc文件中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">    "plugins": ["@babel/plugin-transform-arrow-functions"], //插件发布在 npm 上，可以直接填写插件的名称，</span><br><span class="line">    "plugins": ["./node_modules/@babel/plugin-transform-arrow-functions"], //也可以指定插件的相对/绝对路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预设"><a href="#预设" class="headerlink" title="预设"></a>预设</h3><p>通过使用或创建一个 preset 即可轻松使用一组插件。</p>
<p>@babel/preset-env 主要作用是对我们所使用的并且目标浏览器中缺失的功能进行代码转换和加载 polyfill，在不进行任何配置的情况下，@babel/preset-env 所包含的插件将支持所有最新的JS特性(ES2015,ES2016等，不包含 stage 阶段)，将其转换成ES5代码。例如，如果你的代码中使用了可选链(目前，仍在 stage 阶段)，那么只配置 @babel/preset-env，转换时会抛出错误，需要另外安装相应的插件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h3><p>垫片就是垫平不同浏览器或者不同环境下的差异，让新的内置函数、实例方法等在低版本浏览器中也可以使用。</p>
<p>@babel/polyfill 模块包括 core-js 和一个自定义的 regenerator runtime 模块，可以模拟完整的 ES2015+ 环境（不包含第4阶段前的提议）。</p>
<p>安装 @babel/polyfill 依赖: npm install –save @babel/polyfill</p>
<p>注意：不使用 –save-dev，因为这是一个需要在源码之前运行的垫片。</p>
<p>我们需要将完整的 polyfill 在代码之前加载，</p>
<p>@babel/polyfill 需要在其它代码之前引入，我们也可以在 webpack 中进行配置。</p>
<p>例如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">entry: [</span><br><span class="line">    require.resolve('./polyfills'),</span><br><span class="line">    path.resolve('./index')</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>@babel/preset-env 提供了一个 useBuiltIns 参数，设置值为 usage 时，就只会包含代码需要的 polyfill 。有一点需要注意：配置此参数的值为 usage ，必须要同时设置 corejs (如果不设置，会给出警告，默认使用的是”corejs”: 2) ，注意: 这里仍然需要安装 @babel/polyfill(当前 @babel/polyfill 版本默认会安装 “corejs”: 2):</p>
<p>npm install –save core-js@3</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//.babelrcconst </span><br><span class="line">presets = [    [        "@babel/env",        &#123;               "useBuiltIns": "usage",            "corejs": 3        &#125;    ]]</span><br></pre></td></tr></table></figure>
<p>Babel 会检查所有代码，以便查找在目标环境中缺失的功能，然后仅仅把需要的 polyfill 包含进来。</p>
<p>Babel 会使用很小的辅助函数来实现类似 _createClass 等公共方法。默认情况下，它将被添加(inject)到需要它的每个文件中。</p>
<h3 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h3><p>@babel/plugin-transform-runtime 是一个可以重复使用 Babel 注入的帮助程序，以节省代码大小的插件。</p>
<p>@babel/plugin-transform-runtime 需要和 @babel/runtime 配合使用。</p>
<p>npm install –save-dev @babel/plugin-transform-runtime</p>
<p>npm install –save @babel/runtime</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123; <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>, &#123;<span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>, <span class="attr">"corejs"</span>: <span class="number">3</span>&#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [[<span class="string">"@babel/plugin-transform-runtime"</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们希望 @babel/plugin-transform-runtime 不仅仅处理帮助函数，同时也能加载 polyfill 的话，我们需要给 @babel/plugin-transform-runtime 增加配置信息。</p>
<p>新增依赖 @babel/runtime-corejs3: npm install @babel/runtime-corejs3 –save</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>, &#123;<span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>, <span class="attr">"corejs"</span>: <span class="number">3</span>&#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [[<span class="string">"@babel/plugin-transform-runtime"</span>, &#123;<span class="attr">"corejs"</span>: <span class="number">3</span>&#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插件-预设补充知识"><a href="#插件-预设补充知识" class="headerlink" title="插件/预设补充知识"></a>插件/预设补充知识</h3><p>如果两个转换插件都将处理“程序（Program）”的某个代码片段，则将根据转换插件或 preset 的排列顺序依次执行。</p>
<ul>
<li><p>插件在 Presets 前运行。</p>
</li>
<li><p>插件顺序从前往后排列。</p>
</li>
<li><p>Preset 顺序是颠倒的（从后往前）。</p>
</li>
</ul>
<p>插件参数</p>
<p>插件和 preset 都可以接受参数，参数由插件名和参数对象组成一个数组。preset 设置参数也是这种格式。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Babel 支持多种格式的配置文件。</p>
<p>所有的 Babel API 参数都可以被配置，但是如果该参数需要使用的 JS 代码，那么可能需要使用 JS 代码版的配置文件。</p>
<p>如果希望以编程的方式创建配置文件或者希望编译 node_modules 目录下的模块：那么 babel.config.js 可以满足你的需求。</p>
<p>如果只是需要一个简单的并且中用于单个软件包的配置：那么 .babelrc 即可满足你的需求。</p>
]]></content>
      <tags>
        <tag>babel</tag>
        <tag>babel7</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建博客，换了电脑之后踩坑记录</title>
    <url>/2018/06/27/blogNote/</url>
    <content><![CDATA[<p>搭建参考教程：</p>
<ol>
<li><a href="https://www.jianshu.com/p/e99ed60390a8" target="_blank" rel="noopener">全民博客时代的到来——20 分钟简要教程</a></li>
<li><a href="https://www.jianshu.com/p/6fb0b287f950" target="_blank" rel="noopener">Hexo博客的跨设备同步</a></li>
</ol>
<p>换了电脑之后 hexo 配置都没有了</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>新建一个分支 hexo，管理 hexo 配置和主题文件，原来的 master 分支继续存放生成的静态页面即要发布的内容</p>
<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><ol>
<li>新建 hexo 分支，把 hexo 的配置和主题文件复制进去，然后执行：git add … git push ，push 到 hexo 分支</li>
<li>生成并发布到 master 执行：hexo g，然后 hexo d</li>
</ol>
<p>换电脑之后(windows)：</p>
<ol>
<li>先 clone 一下 hexo 分支的代码</li>
<li>安裝 npm install hexo-cli -g</li>
<li>安装 hexo npm install hexo</li>
<li>安装其他依赖 npm install</li>
<li>安装 hexo-deployer-git 执行命令：npm install hexo-deployer-git –save</li>
<li>安装 hexo server 命令：npm install hexo-server<br>npm install hexo-server –save</li>
<li>生成添加密钥: 执行命令 ssh-keygen -t rsa -C “Github 的注册邮箱地址”，一路回车，待秘钥生成完毕，会得到两个文件 id_rsa 和 id_rsa.pub，用带格式的记事本打开 id_rsa.pub，Ctrl + a 复制里面的所有内容，然后进入<a href="https://github.com/settings/keys，添加密钥" target="_blank" rel="noopener">https://github.com/settings/keys，添加密钥</a></li>
</ol>
<p>踩坑记录：</p>
<ul>
<li>执行 hexo s 启动本地服务，页面空白，有时候还一直转圈圈，网上百度，说是 hexo server 默认的端口号是 4000，这个端口号被占用了，依照网上的操作，hexo s -p 4001 切换端口号，还是没用</li>
</ul>
<p>使用了主题，比如 next ,在根目录执行：git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next，安装主题，否则不能生成静态目录</p>
<ul>
<li>又发现另外一个待解决的问题： 如果使用的主题皮肤，主题皮肤是另外一个仓库的，有自己的 git 配置，不能被我的 git 仓库管理，解决方法：<a href="https://juejin.im/post/5c2e22fcf265da615d72c596" target="_blank" rel="noopener">https://juejin.im/post/5c2e22fcf265da615d72c596</a></li>
</ul>
<ol>
<li><p>git submodule add <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>这个命令可以将外部的仓库作为当前项目的子模块添加进来</p>
</li>
<li><p>报错： ‘themes/next’ already exists in the index，原因是themes/next文件夹已经在git stage里面缓存了，执行git rm -r –cached theme/next命令从stage 移除该文件夹</p>
</li>
<li><p>继续添加子模块：  git submodule add <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</li>
<li><p>子模块添加成功后，根目录会出现一个 ：.gitmodules文件，这是一个配置文件，记录子模块</p>
</li>
<li><p>执行 git commit -m “添加皮肤主题next作为子模块”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[hexo 16896fd] 添加皮肤主题next作为子模块</span><br><span class="line">2 files changed, 4 insertions(+)</span><br><span class="line">create mode 100644 .gitmodules</span><br><span class="line">create mode 160000 themes/next</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>create mode 160000，表示themes/next 条目是160000，这在Git中是一个特殊模式意思是你将一根提交，记录为目录项，而不是子目录或者文件</p>
<h2 id="如果再换电脑（MAC）"><a href="#如果再换电脑（MAC）" class="headerlink" title="如果再换电脑（MAC）"></a>如果再换电脑（MAC）</h2><ul>
<li><p>使用git clone克隆整个仓库，然后themes/next存在，是空的</p>
</li>
<li><p>生成添加密钥: 执行命令 ssh-keygen -t rsa -C “Github 的注册邮箱地址”，一路回车，待秘钥生成完毕，会得到两个文件 id_rsa 和 id_rsa.pub，用带格式的记事本打开 id_rsa.pub，Ctrl + a 复制里面的所有内容，然后进入<a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a></p>
</li>
<li><p>执行git submodule init命令来初始化本地的配置文件</p>
</li>
<li><p>git submodule update来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交</p>
</li>
<li><p>安裝 npm install hexo-cli -g</p>
</li>
<li><p>尝试执行 hexo s,启动服务</p>
</li>
</ul>
<h3 id="其他错误处理"><a href="#其他错误处理" class="headerlink" title="其他错误处理"></a>其他错误处理</h3><p><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">全局安装软件包时解决EACCES权限错误</a></p>
<h2 id="如果皮肤的作者有更新"><a href="#如果皮肤的作者有更新" class="headerlink" title="如果皮肤的作者有更新"></a>如果皮肤的作者有更新</h2>]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的事件循环和任务队列</title>
    <url>/2018/08/17/browser-tasks/</url>
    <content><![CDATA[<p>参考文档：</p>
<p><a href="https://segmentfault.com/a/1190000012748907" target="_blank" rel="noopener">浏览器中的事件循环机制</a></p>
<p><a href="https://segmentfault.com/a/1190000019059045?utm_source=tag-newest" target="_blank" rel="noopener">浏览器的微任务MicroTask和宏任务MacroTask</a></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>js在浏览器运行是单线程的，一般情况下浏览器会按顺序同步执行js代码，但是有些情况下需要延迟执行js代码</p>
<p>最常见的就是等待接口返回数据之后再去执行回调函数，不可能一直在那里等着接口有返回了再去执行后面的，这就是会阻塞后面js执行，请求接口是同步执行的，请求成功之后的回调是异步的，所以会先找一个地方把异步操作存起来，等其他的js执行完成了再去执行，这个存贮的地方就是浏览器的任务队列</p>
<h2 id="事件循环（event-loop）机制"><a href="#事件循环（event-loop）机制" class="headerlink" title="事件循环（event loop）机制"></a>事件循环（event loop）机制</h2><p>浏览器的事件循环机制，可以理解为任务队列的机制</p>
<h3 id="任务队列的分类"><a href="#任务队列的分类" class="headerlink" title="任务队列的分类"></a>任务队列的分类</h3><ul>
<li><p>同步任务（Task），即为立即执行的js代码队列</p>
</li>
<li><p>宏任务（macroTask），setTimeout、setInterval、I/O、UI渲染</p>
</li>
<li><p>微任务（microTask），promise、object.obsever、MutationObsever</p>
</li>
<li><p>用户交互事件，点击事件等</p>
</li>
</ul>
<h3 id="promise-与-setTimeout"><a href="#promise-与-setTimeout" class="headerlink" title="promise 与 setTimeout"></a>promise 与 setTimeout</h3><p>我们用的比较多的是这两个，先看一下这两个的执行顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span> + <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'before resolve'</span>);</span><br><span class="line">    resolve(<span class="string">'promise'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after resolve'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">before resolve</span><br><span class="line">after resolve</span><br><span class="line">end</span><br><span class="line">promise</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>
<p>为什么‘promise’会比‘延迟任务’先打印出来，明明按照代码的编写顺序延迟任务setTimeout是先进入任务队列的，这就是因为promise进入的是微任务（microTask）队列，而延迟任务进入的是宏任务（macroTask）队列，从上可看出，微任务（microTask）队列是优先于宏任务（macroTask）队列执行的</p>
<p>执行顺序说明：</p>
<ol>
<li><p>test函数进入执行队列</p>
</li>
<li><p>执行同步任务，console.log(a)，同步任务都是立即执行的</p>
</li>
<li><p>setTimeout任务进入任务队列，没有立即执行，而是放在了宏任务（macroTask）队列</p>
</li>
<li><p>代码继续往下走，promise进入任务队列，new promise会立即执行传入的回调函数，resolve(‘promise)前后和它的两个console.log()，都是同步任务，所以会立即执行，执行到resolve(‘promise’);这一句，把promise.then()放入任务队列，这个是放入微任务（microTask）队列，</p>
</li>
<li><p>执行同步任务console.log(‘end’);</p>
</li>
<li><p>浏览器闲下来，优先查找微任务（microTask）队列，执行promise.then()，控制台打印console.log(value);</p>
</li>
<li><p>微任务（microTask）队列为空，查找宏任务（macroTask）队列，控制台打印console.log(“延迟任务”);</p>
</li>
</ol>
<h3 id="只要有-Microtasks-插入，就会不断执行-Microtasks-队列直到结束，在结束前都不会执行到-Tasks"><a href="#只要有-Microtasks-插入，就会不断执行-Microtasks-队列直到结束，在结束前都不会执行到-Tasks" class="headerlink" title="只要有 Microtasks 插入，就会不断执行 Microtasks 队列直到结束，在结束前都不会执行到 Tasks"></a>只要有 Microtasks 插入，就会不断执行 Microtasks 队列直到结束，在结束前都不会执行到 Tasks</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">".outer"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">".inner"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用。</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"检测到dom改变"</span>);</span></span><br><span class="line"><span class="undefined">      &#125;).observe(outer, &#123;</span></span><br><span class="line"><span class="javascript">        attributes: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">target</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"click"</span> + <span class="string">' '</span> + target);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"延迟任务"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;, 0);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          resolve(<span class="string">'promise'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(value);</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        outer.setAttribute(<span class="string">"data-random"</span>, <span class="built_in">Math</span>.random());</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      inner.addEventListener(<span class="string">"click"</span>, () =&gt; onClick(<span class="string">'inner'</span>));</span></span><br><span class="line"><span class="javascript">      outer.addEventListener(<span class="string">"click"</span>, () =&gt; onClick(<span class="string">'outer'</span>));</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    test();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click inner</span><br><span class="line">promise</span><br><span class="line">检测到dom改变</span><br><span class="line">click outer</span><br><span class="line">promise</span><br><span class="line">检测到dom改变</span><br><span class="line">延迟任务</span><br><span class="line">延迟任务</span><br></pre></td></tr></table></figure>
<h3 id="一个事件循环执行过程"><a href="#一个事件循环执行过程" class="headerlink" title="一个事件循环执行过程"></a>一个事件循环执行过程</h3><p>先执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setInterval'</span>)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout 1'</span>)</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'promise 2'</span>)</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'setTimeout 2'</span>)</span><br><span class="line">            <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'promise 3'</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                clearInterval(interval)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 1'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise <span class="number">1</span></span><br><span class="line">setInterval</span><br><span class="line">setTimeout <span class="number">1</span></span><br><span class="line">promise <span class="number">2</span></span><br><span class="line">setInterval</span><br><span class="line">setTimeout <span class="number">2</span></span><br><span class="line">promise <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title>从性能优化的角度看缓存</title>
    <url>/2019/03/30/cache/</url>
    <content><![CDATA[<h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><p>重复利用已经获取的资源，减少延迟和网络阻塞，</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><ul>
<li><p>数据库缓存</p>
</li>
<li><p>服务器缓存</p>
<p>代理服务器缓存</p>
<p>cdn缓存</p>
</li>
<li><p>浏览器缓存</p>
<p>http缓存</p>
<p>数据缓存</p>
<p>应用离线缓存 PWA</p>
</li>
</ul>
<h2 id="浏览器缓存-强缓存和协商缓存"><a href="#浏览器缓存-强缓存和协商缓存" class="headerlink" title="浏览器缓存-强缓存和协商缓存"></a>浏览器缓存-强缓存和协商缓存</h2><p>浏览器命中缓存原理</p>
<ol>
<li><p>浏览器在请求资源的时候，根据请求头部的expires 和cache-control判断是否命中强缓存，如果命中强缓存，就直接从浏览器获取缓存，而不会发送请求到服务器</p>
</li>
<li><p>如果没有命中强缓存，就一定会发送请求到服务器，通过last-modified和Etag判断是否命中协商缓存，如果命中了协商缓存，服务器会返回这个请求，并返回状态码 304 not-modified，但是不会返回这个资源的数据，依然是从缓存获取数据</p>
</li>
<li><p>如果既没有命中强缓存，也没有命中协商缓存，则从服务器获取资源并加载</p>
</li>
</ol>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存通过expires和cache-control两种请求头实现</p>
<ol>
<li><p>expires，设置绝对时间，表示资源过期的时间</p>
</li>
<li><p>Cache-Control，设置指令短语 max-age，表示相对时间</p>
</li>
</ol>
<p>如果当前的时间在给定的时间之内，就会使用本地的缓存，而不会向服务器再去请求</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串</p>
<p>实现协商缓存</p>
<h4 id="last-modified和if-modified-since"><a href="#last-modified和if-modified-since" class="headerlink" title="last-modified和if-modified-since"></a>last-modified和if-modified-since</h4><p>浏览器上一次返回资源在返回头里返回last-modified首部字段，该首部字段表示该资源上次修改的时间，然后浏览器下次请求的时候会在请求头里设置if-modified-since，该首部字段设置为上次last-modified返回的值，</p>
<p>以这种方式询问服务器这个资源从这个时间之后是否有修改，如果有就会返回新的资源，如果没有则返回304 not-modified状态码</p>
<p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag</p>
<h4 id="Etag和if-none-match"><a href="#Etag和if-none-match" class="headerlink" title="Etag和if-none-match"></a>Etag和if-none-match</h4><p>浏览器上一次返回资源在返回头里返回Etag这个首部字段，Etag表示文件指纹，然后浏览器下次请求的时候会在请求头里设置if-none-match，该首部字段设置为上次eTag的值</p>
<p>以这种方式询问服务器，请求的资源是否有更新，如果有就返回新的资源，如果没有则返回304 not-modified状态码</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作</title>
    <url>/2017/04/08/git-base/</url>
    <content><![CDATA[<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>新建分支：</p>
<p>git checkout -b [分支]<br>git push –set-upstream origin [分支]</p>
<p>删除本地分支：先切换到别的分支，然后git branch -d [分支]</p>
<p>删除远程分支 ：git push origin –delete [分支]</p>
<p>切换远程仓库的地址：git remote set-url oringin &lt;新的远程仓库URL&gt;</p>
<p>查看远程仓库的地址：git remote -v</p>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>git stash 将当前所有修改项(未提交的)暂存，压栈。此时代码回到你上一次的提交，用git status可查看状态。</p>
<p>git stash list将列出所有暂存项。</p>
<p>git stash clear 清除所有暂存项。</p>
<p>git stash apply 将暂存的修改重新应用，使用git status可以看到以前暂存的修改又回来了</p>
<p>git stash pop 弹出最后一个stash</p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>git log 查看提交日志</p>
<p>git reset HEAD^  撤回上一次的commit提交</p>
<p>git reset –hard [commit的版本id] ，回滚到某个版本的提交</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git-rebase</title>
    <url>/2019/04/08/git-rebase/</url>
    <content><![CDATA[<p>太多的commit不利于code review，造成分支污染，如果需要回滚代码，发现有很多的commit，难以定位要回滚的版本</p>
<h2 id="使用场景：合并多次commit"><a href="#使用场景：合并多次commit" class="headerlink" title="使用场景：合并多次commit"></a>使用场景：合并多次commit</h2><p>git rebase -i HEAD~4</p>
<p>进入vi模式：</p>
<ul>
<li><p>p, pick = use commit</p>
</li>
<li><p>r, reword = use commit, but edit the commit message</p>
</li>
<li><p>e, edit = use commit, but stop for amending（停下来修改）</p>
</li>
<li><p>s, squash = use commit, but meld into previous commit（融入先前哪个commit）</p>
</li>
<li><p>f, fixup = like “squash”, but discard this commit’s log message（丢弃这个commit的日志信息）</p>
</li>
<li><p>x, exec = run command (the rest of the line) using shell（运行命令）</p>
</li>
<li><p>d, drop = remove commit</p>
</li>
</ul>
<h2 id="git-pull-–rebase"><a href="#git-pull-–rebase" class="headerlink" title="git pull –rebase"></a>git pull –rebase</h2><p>多个人使用同一个远程分支合作开发，执行git pull之后，远程有新的commit</p>
<h2 id="git-rebase-–abort"><a href="#git-rebase-–abort" class="headerlink" title="git rebase –abort"></a>git rebase –abort</h2>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2016/07/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>js数组操作</title>
    <url>/2017/08/04/js-array/</url>
    <content><![CDATA[<h2 id="数组随机排序"><a href="#数组随机排序" class="headerlink" title="数组随机排序"></a>数组随机排序</h2><h3 id="随机数打乱数组的排序"><a href="#随机数打乱数组的排序" class="headerlink" title="随机数打乱数组的排序"></a>随机数打乱数组的排序</h3><p>遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素</p>
<p>通过随机数打乱数组原有的排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort1</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="comment">// 生成一个在数组长度范围内的随机数</span></span><br><span class="line">    <span class="keyword">let</span> rc = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * l)</span><br><span class="line">    <span class="comment">// 让当前循环的数组元素和随机出来的数组元素交换位置</span></span><br><span class="line">    <span class="keyword">const</span> current = arr[i]</span><br><span class="line">    arr[i] = arr[rc]</span><br><span class="line">    arr[rc] = current</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成新的随机排序数组"><a href="#生成新的随机排序数组" class="headerlink" title="生成新的随机排序数组"></a>生成新的随机排序数组</h3><p>通过随机数从数组中随机取出某一项，重新排序组成新的数组</p>
<ul>
<li><p>循环给定的数组，</p>
</li>
<li><p>每次循环根据数组的长度获取随机整数</p>
</li>
<li><p>以获取的随机数为索引，从数组中取出该随机数所对应的那一项，push到新的数组中去</p>
</li>
<li><p>然后用splice方法从原数组中删除已经放进新数组的那一项</p>
</li>
<li><p>循环执行以上操作</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mixedArr = []</span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rc = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * arr.length)</span><br><span class="line">    mixedArr.push(arr[rc])</span><br><span class="line">    arr.splice(rc, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mixedArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="array-sort方法排序"><a href="#array-sort方法排序" class="headerlink" title="array.sort方法排序"></a>array.sort方法排序</h3><p>sort方法会在愿数组上进行排序，接受一个排序的方法，通过生成随机数的方式，决定要不要调换当前两个元素的顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h2><h3 id="根据对象单个属性排序"><a href="#根据对象单个属性排序" class="headerlink" title="根据对象单个属性排序"></a>根据对象单个属性排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = a[property]</span><br><span class="line">    <span class="keyword">let</span> value2 = b[property]</span><br><span class="line">    <span class="keyword">return</span> value1 - value2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'zopp'</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'gpp'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'yjj'</span>, <span class="attr">age</span>: <span class="number">8</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">arr.sort(compare(<span class="string">'age'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="多个属性排序"><a href="#多个属性排序" class="headerlink" title="多个属性排序"></a>多个属性排序</h3><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><h3 id="ES6-中的-flat-方法"><a href="#ES6-中的-flat-方法" class="headerlink" title="ES6 中的 flat 方法"></a>ES6 中的 flat 方法</h3><p>array.flat接受一个数字，表示要扁平化的深度</p>
<h3 id="利用递归"><a href="#利用递归" class="headerlink" title="利用递归"></a>利用递归</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> flatten = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      flatten(item)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用-reduce-函数迭代"><a href="#利用-reduce-函数迭代" class="headerlink" title="利用 reduce 函数迭代"></a>利用 reduce 函数迭代</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten2(cur) : cur)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="利用indexOf"><a href="#利用indexOf" class="headerlink" title="利用indexOf"></a>利用indexOf</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArr.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先将原数组排序，在与相邻的进行比较，如果不同则存入新数组"><a href="#先将原数组排序，在与相邻的进行比较，如果不同则存入新数组" class="headerlink" title="先将原数组排序，在与相邻的进行比较，如果不同则存入新数组"></a>先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formArr = arr.sort()</span><br><span class="line">  <span class="keyword">var</span> newArr = [formArr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; formArr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (formArr[i] !== formArr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      newArr.push(formArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用对象属性存在的特性，如果没有该属性则存入新数组"><a href="#利用对象属性存在的特性，如果没有该属性则存入新数组" class="headerlink" title="利用对象属性存在的特性，如果没有该属性则存入新数组"></a>利用对象属性存在的特性，如果没有该属性则存入新数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">      obj[arr[i]] = <span class="number">1</span></span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用数组原型对象上的-includes-方法"><a href="#利用数组原型对象上的-includes-方法" class="headerlink" title="利用数组原型对象上的 includes 方法"></a>利用数组原型对象上的 includes 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(arr[i])) &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用数组原型对象上的-filter-和-includes-方法"><a href="#利用数组原型对象上的-filter-和-includes-方法" class="headerlink" title="利用数组原型对象上的 filter 和 includes 方法"></a>利用数组原型对象上的 filter 和 includes 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique5</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newArr.includes(item) ? <span class="string">''</span> : newArr.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用-ES6-的-set-方法"><a href="#利用-ES6-的-set-方法" class="headerlink" title="利用 ES6 的 set 方法"></a>利用 ES6 的 set 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)) <span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据属性去重"><a href="#根据属性去重" class="headerlink" title="根据属性去重"></a>根据属性去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique6</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !res.has(item.id) &amp;&amp; res.set(item.id, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique6([&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'aa'</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'bb'</span>&#125;]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique7</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i].id]) &#123;</span><br><span class="line">      result.push(arr[i])</span><br><span class="line">      obj[arr[i].id] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取数组的交集-并集-差集"><a href="#取数组的交集-并集-差集" class="headerlink" title="取数组的交集/并集/差集"></a>取数组的交集/并集/差集</h2><h3 id="includes-方法结合-filter-方法"><a href="#includes-方法结合-filter-方法" class="headerlink" title="includes 方法结合 filter 方法"></a>includes 方法结合 filter 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = a.concat(b.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> !a.includes(v)))</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersection = a.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> b.includes(v))</span><br><span class="line"><span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = a.concat(b).filter(<span class="function">(<span class="params">v</span>) =&gt;</span> !a.includes(v) || !b.includes(v))</span><br><span class="line"><span class="comment">// [1,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="ES6-的-Set-数据结构"><a href="#ES6-的-Set-数据结构" class="headerlink" title="ES6 的 Set 数据结构"></a>ES6 的 Set 数据结构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4,5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x)))</span><br><span class="line"><span class="comment">// set &#123;2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x) || !a.has(x)))</span><br><span class="line"><span class="comment">// Set &#123;1, 3, 4 , 5&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    s += arr[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>] + sum(arr.slice(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ES6-的-reduce-方法"><a href="#ES6-的-reduce-方法" class="headerlink" title="ES6 的 reduce 方法"></a>ES6 的 reduce 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, curr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + curr</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类数组转化"><a href="#类数组转化" class="headerlink" title="类数组转化"></a>类数组转化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...arguments]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>模态框的最佳实践</title>
    <url>/2020/10/27/modal/</url>
    <content><![CDATA[<p>原文：<a href="http://www.jerrychane.com/user-experience/3.html" target="_blank" rel="noopener">模态框的最佳实践</a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>为什么选择这篇文章呢？</p>
<ol>
<li><p>前端工程师的定位不仅仅在于讨论如何解决架构层面的问题，更应该重视交互体验</p>
</li>
<li><p>前端工程师从未停止过对用户体验的追求，如何思考模态框在产品中的存在和使用，存在许多争议；</p>
</li>
</ol>
<h2 id="知识普及"><a href="#知识普及" class="headerlink" title="知识普及"></a>知识普及</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>维基百科上对模态框的定义如下：模态框是一个定位于应用视窗顶层的元素。它创造了一种模式让自身保持在一个最外层的子视窗下显示，并让主视窗失效。用户必须通过在它上面做交互动作，才可以回到主视窗。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li><p>抓住用户的吸引力；</p>
</li>
<li><p>需要用户输入内容；</p>
</li>
<li><p>在上下文下显示额外的信息；</p>
</li>
<li><p>不在上下文下显示额外的信息；</p>
</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li><p>退出的方式，可以是模态框上的一个按钮，键盘上的一个按键，也可以是模态框外的区域；</p>
</li>
<li><p>描述性标题，标题是给用户标识在哪个位置进行操作的上下文信息；</p>
</li>
<li><p>按钮的内容，它一定是用户可以理解，并促使用户进行下一步行动的内容，不会产生迷惑；</p>
</li>
<li><p>大小与位置，模态框不要太大，也不要太小，位置建议在视窗中间偏上(太低在移动端显示不全)；</p>
</li>
<li><p>焦点的切换，模态框的出现会吸引用户的注意力，建议键盘焦点切换到框内；</p>
</li>
<li><p>需用户发起，通过用户的动作，如点击按钮促使模态框出现，不然会惊吓到用户；</p>
</li>
</ul>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>模态框由于太大，占用太多控件，在移动端很难适配。通常建议增加设备按键或内置滚动条来操作，用户可以滑动或放大缩小来操作模态框。</p>
<h3 id="无障碍访问"><a href="#无障碍访问" class="headerlink" title="无障碍访问"></a>无障碍访问</h3><ul>
<li><p>快捷键 - 考虑在打开、移动、管理焦点和关闭时增加对模态框的快捷键；</p>
</li>
<li><p>ARIA - 在前端代码层面加上 aria 的标识，如 Role = “dailog”,aria-hidden,aria-label;</p>
</li>
</ul>
<h2 id="思考与实践"><a href="#思考与实践" class="headerlink" title="思考与实践"></a>思考与实践</h2><h3 id="定位思考"><a href="#定位思考" class="headerlink" title="定位思考"></a>定位思考</h3><p>Modal 与 Toast、Notification、Message 以及 Popover 都会在某个时间点被触发并弹出一个浮层。但从定义上来看上述组件都不属于模态框，因为模态框始终会阻塞原来主视窗下的操作，只能在框内做后续操作。模态框的出现从界面上彻底打断了用户的心流。如果是一般的消息提醒，可以用信息条、小红点等交互形式，至少不会阻塞用户的操作。</p>
<p>那么模态框有什么优点吗？要知道模态框的体验要比页面跳转更加轻量，更让用户感觉舒适。例如，用户在电商网站看中一款产品，想登陆购买，此时弹出模态框的体验就远远好于跳转到登录页面，因为用户在模态框中登录后，就可以直接购买了。</p>
<p>也就是说，当我们设计好模态框出现的时机，流畅的弹出体验，必要的上下文信息，以及友好的退出反馈，足以提升体验。模态框的目的在于吸引用户的注意，而且一定要提供能够在本页面即可完成额外的流程操作或是信息告知，可以是一个重要的操作，也可以是一份重要的协议。</p>
<h3 id="合理使用"><a href="#合理使用" class="headerlink" title="合理使用"></a>合理使用</h3><p>-内容是否相关。模态框作为当前页面的一种衍生或补充，若其内容与当前页面无关联，可以使用其他操作代替模态框，例如页面跳转。</p>
<p>-避免过多操作。模态框应该给用户留下一种看完即走，潇洒自如的感觉，而非繁杂的交互留住或牵制用户。</p>
<p>-避免多模态框。出现多个模态框，会加深产品垂直深度，提高视觉复杂度，而且让用户感到烦躁。</p>
<p>-用户主动触发。不要突然打开或自动打开模态框，会惊吓到用户。</p>
<p>-大小尺寸适中。模态框大小要严格限制，避免内容过多出现滚动条的情况，除非需展示明细内容。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>错误示例</p>
]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>用户体验</tag>
      </tags>
  </entry>
  <entry>
    <title>人间失格</title>
    <url>/2020/11/19/note-renjianshige/</url>
    <content><![CDATA[<p>生而为人，我很抱歉</p>
<p>胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤。”孤独、怯懦、自卑的叶藏了解自己，却走不出自己的牢笼。狂妄的为所欲为只是一种伪饰，心事从未向世人展开。</p>
<p>读别人的残疾，明白了自己的残疾，愿你读完之后能真正的原谅自己，原谅周围的世界。</p>
<p>人活在这个世界，确实有很多的卑微和无奈，但是不应该放松任由卑微和无奈肆意生长，你要用尽全力去争斗一个为人的资格</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>我什么也没忘，但是有些事只适合收藏，不能说，也不能想，却又不能忘。</title>
    <url>/2019/10/26/notes1/</url>
    <content><![CDATA[<p>更多时候，击垮我们的瞬间不是那些灾难性的事件和人生重大的意外，而是日常生活中不断消磨我们情感、意志的等待，纠缠、进退两难；是你认为最熟悉、亲近你，处处为你好的家人、朋友充满善意的误解；我们要拿出来应对这一切的往往也不是什么智慧的决断、钢铁的意志，而是无尽的耐心。</p>
<p>我什么也没忘，但是有些事只适合收藏，不能说，也不能想，却又不能忘。</p>
<p>我用真心待你，但不执着于你，活在缘分中，而非关系里。如果执着于某种关系，以此对关系中的对方作种种要求，关系就成了彼此的束缚。</p>
<p>愿神明偏爱，一切从欢</p>
<p>十年饮冰，难凉热血；千载暗室，一灯即明</p>
<p>心里藏着小星星，生活才能亮晶晶</p>
<p>播种和收获不在同一个季节，中间隔着的一段时间，我们叫它：坚持</p>
<p>在人生的某个年纪之前，你可以依靠透支身体，小聪明和老天给你的运气，一直巧取的活着。然而到了某个年纪之后，真正能让你走远的，都是自律、积极和勤奋，不论是工作还是身材的管理</p>
<p>众生皆苦，你就是那一点甜</p>
<p>相遇都有目的，不是恩赐就是教训 愿你遍历山河 ，仍觉得人间值得</p>
<p>愿你内心山河壮阔，始终相信人间值得。每个人都会经历一段特别艰难的时光，生活的窘迫，工作的失意，爱的惶惶不可终日，挺过来的，人生就会豁然开朗，挺不过来的，时间也会教你怎么与它们握手言和。所以你不用害怕，日升月落，总有黎明。 《杨绛先生语录》</p>
<ul>
<li><p>愿你一生温暖纯良，不舍爱与自由。</p>
</li>
<li><p>愿你一生平安喜乐，皆能得偿所愿。</p>
</li>
<li><p>愿你眼里长着太阳，笑里全是坦荡。</p>
</li>
<li><p>愿你心里一直有光芒，活成自己想要的模样。</p>
</li>
<li><p>愿你回望皆是无悔，不负如梦青春。</p>
</li>
<li><p>愿你付出甘之如饴，所得归于欢喜。</p>
</li>
<li><p>愿你有前进一寸的勇气，亦有后退一尺的从容，</p>
</li>
<li><p>愿你忠于自己活的还像自己。</p>
</li>
<li><p>愿你温柔可爱依如往昔</p>
</li>
<li><p>愿你天黑有灯，下雨有伞，一路上有良人相伴</p>
</li>
<li><p>愿你眼里有星辰大海，心里有繁花似锦</p>
</li>
</ul>
<p>前半生择其所爱，余下的岁月爱其所择。</p>
<p>最美的你不是生如夏花，而是在时间的长河里，波澜不惊。</p>
<p>比起有人左右情绪的日子，我更喜欢过无人问津的生活</p>
<p>要努力，但是不要着急，繁花似锦和硕果累累都需要过程</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器在线预览文件（PDF,txt,html,ofd,docx,pptx,jpg,jpeg,png...等）</title>
    <url>/2020/11/09/preview/</url>
    <content><![CDATA[<p>最近做项目，接到一个需求：要求预览上传的文件，大概包括以下格式：PDF,txt,html,ofd,docx,pptx,jpg,jpeg,png…</p>
<p>首先参考前人（同事）的经验，将要预览的文件进行了分类：</p>
<ul>
<li><p>Office类型的</p>
</li>
<li><p>图片类型的</p>
</li>
<li><p>其他类型：PDF，ofd，html，txt</p>
</li>
</ul>
<p>项目使用的是react + hooks + ant design搭建，我搭建了一个demo来演示预览功能</p>
<h2 id="Office类型的"><a href="#Office类型的" class="headerlink" title="Office类型的"></a>Office类型的</h2><p>根据分类，最简单的是Office类型的文件预览，微软的提供了一个官方的预览方法，参数url是你的附件地址，直接在浏览器里打开这个地址，再后面拼上文件的地址就可以了，内嵌在iframe也可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`https://view.officeapps.live.com/op/view.aspx?src=<span class="subst">$&#123;url&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<h2 id="图片类型的"><a href="#图片类型的" class="headerlink" title="图片类型的"></a>图片类型的</h2><p>图片类型的是最简单的，直接写进img标签里就可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#123;url&#125; style=&#123;&#123;<span class="attr">width</span>: <span class="string">'1000px'</span>, <span class="attr">margin</span>: <span class="string">'0 auto'</span>&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="PDF类型"><a href="#PDF类型" class="headerlink" title="PDF类型"></a>PDF类型</h2><p>比较麻烦的是剩下几个类型的，第一个先说PDF格式的预览</p>
<p>经过调查和研究最终选择了现有的一个库pdfjs-dist来实现该功能</p>
<p>实现步骤：</p>
<p>安装：<code>npm install pdfjs-dist --save</code></p>
<p>在项目中引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as PDFJS from &apos;pdfjs-dist&apos;;</span><br><span class="line">import pdfjsWorker from &apos;pdfjs-dist/build/pdf.worker.entry&apos;;</span><br><span class="line"></span><br><span class="line">PDFJS.GlobalWorkerOptions.workerSrc = pdfjsWorker;</span><br><span class="line"></span><br><span class="line">const pdfurl = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">function PreView() &#123;</span><br><span class="line">  const containerRef = useRef();</span><br><span class="line"></span><br><span class="line">  // 设置canvas，将PDF文件分页用canvas绘制出来，并渲染在页面</span><br><span class="line">  const openPage = (pdf: any, pageNumber: number) =&gt; &#123;</span><br><span class="line">    pdf.getPage(pageNumber).then((pdfPage: any) =&gt; &#123;</span><br><span class="line">      var viewport = pdfPage.getViewport(&#123; scale &#125;);</span><br><span class="line">      const canvas = document.createElement(&apos;canvas&apos;);</span><br><span class="line">      canvas.id = &apos;test&apos;;</span><br><span class="line">      canvas.width = viewport.width;</span><br><span class="line">      canvas.height = viewport.height;</span><br><span class="line">      var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">      var renderTask = pdfPage.render(&#123;</span><br><span class="line">        canvasContext: ctx,</span><br><span class="line">        viewport: viewport,</span><br><span class="line">      &#125;);</span><br><span class="line">      containerRef.current.appendChild(canvas);</span><br><span class="line">      return renderTask.promise;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // PDFJS.getDocument（url）获取PDF，解析PDF</span><br><span class="line">  const readPDF = async () =&gt; &#123;</span><br><span class="line">    const loadingTask = await PDFJS.getDocument(pdfurl);</span><br><span class="line">    loadingTask.promise.then((pdf: any) =&gt; &#123;</span><br><span class="line">      const pageNum = pdf.numPages;</span><br><span class="line">      for (let i = 1; i &lt;= pageNum; i++) &#123;</span><br><span class="line">        openPage(pdf, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    readPDF();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div ref=&#123;containerRef&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PreView;</span><br></pre></td></tr></table></figure>
<h2 id="ofd格式"><a href="#ofd格式" class="headerlink" title="ofd格式"></a>ofd格式</h2><p>ofd格式的文档，我还是第一次听说，我们这次使用ofd格式的文档主要是用于发票的上传和预览</p>
<p>先百科一下，顺便自己长点知识：OFD格式是我国自主可控的电子文件版式文档格式。OFD版式文件，版面固定、不跑版、所见即所得，可以视为计算机时代的“数字纸张”；是电子文档发布、数字化信息传播和存档的理想文档格式。（来自知乎复制黏贴）</p>
<p>OFD格式具有以下优势：</p>
<ol>
<li><p>产权属于自主产权。</p>
</li>
<li><p>具有便携性：文件小，可压缩比率大。测试显示生成的文件体量比PDF还要小。</p>
</li>
<li><p>具有开放性：易于入门，对于使用者来说更具开放性。</p>
</li>
<li><p>具有扩展性：预留了可扩展入口和自定义标引，设置了非接触式引用机制，为特性化提供支持。</p>
</li>
<li><p>呈现效果与设备无关，在各种设备上阅读、打印或印刷时，版面固定、不跑版。</p>
</li>
<li><p>应用广泛：无论是电子商务、电子公务，还是信息发布、文件交换，档案管理等都需要版式文档的技术支持。</p>
</li>
</ol>
<h3 id="如何预览"><a href="#如何预览" class="headerlink" title="如何预览"></a>如何预览</h3><p>经过查找，找到了ofd.js工具库来实现ofd文件的预览，现在项目里安装一下</p>
<p><code>npm i ofd.js</code></p>
<p>然后在页面中引入并使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function PreView() &#123;</span><br><span class="line">  const &#123; parseOfdDocument, renderOfd &#125; = require(&apos;ofd.js&apos;);</span><br><span class="line">  const contentDiv = useRef();</span><br><span class="line">  const ofdRef = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      delete Array.prototype.pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  const fileChanged = (e) =&gt; &#123;</span><br><span class="line">    const file = ofdRef.current.input.files[0];</span><br><span class="line">    const reader = new FileReader();</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">    reader.onload = function (e) &#123;</span><br><span class="line">      const ofdBase64 = e.target.result.split(&apos;,&apos;)[1];</span><br><span class="line">    &#125;</span><br><span class="line">    // 核心方法，file支持本地文件、二进制或者url</span><br><span class="line">    parseOfdDocument(&#123;</span><br><span class="line">      ofd: file,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">        //输出ofd每页的div</span><br><span class="line">        const divs = renderOfd(900, res[0]);</span><br><span class="line">        for (const div of divs) &#123;</span><br><span class="line">          contentDiv.current.appendChild(div);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Input type=&quot;file&quot; accept=&quot;.ofd&quot; onChange=&#123;(e) =&gt; fileChanged(e)&#125; ref=&#123;ofdRef&#125; /&gt;</span><br><span class="line">      &lt;div ref=&#123;contentDiv&#125;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default PreView;</span><br></pre></td></tr></table></figure>
<p>在这里为什么要使用require(‘ofd.js’)的方式引入呢？原因是，ofd.js的源码里有这样子一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="built_in">Array</span>.prototype.pipeline = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> === <span class="keyword">this</span> || <span class="string">'undefined'</span> === <span class="keyword">typeof</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// At the moment all modern browsers, that support strict mode, have</span></span><br><span class="line">    <span class="comment">// native implementation of Array.prototype.reduce. For instance, IE8</span></span><br><span class="line">    <span class="comment">// does not support strict mode, so this check is actually useless.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">'Array.prototype.pipeline called on null or undefined'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> !== <span class="keyword">typeof</span> callback) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> index, value,</span><br><span class="line">    length = <span class="keyword">this</span>.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; length &gt; index; ++index) &#123;</span><br><span class="line">    value = <span class="keyword">await</span> callback(value, <span class="keyword">this</span>[index], index, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _pipeline = <span class="function"><span class="keyword">function</span>(<span class="params">...funcs</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> funcs.pipeline(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.call(<span class="keyword">this</span>, a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pipeline = _pipeline;</span><br></pre></td></tr></table></figure>
<p>这段代码在array的原型链上添加了一个方法，如果直接放在顶层引用，可能会报错</p>
<p>最后在组件卸载的时候，最好手动删除一下这个添加在原型链上的方法，我已经在上面的代码里删除了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      delete Array.prototype.pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure>
<h2 id="txt，html"><a href="#txt，html" class="headerlink" title="txt，html"></a>txt，html</h2><p>这两种文件预览的处理方式差不多，先看一下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const url = &apos;xx.txt&apos;; // 或者xx.html</span><br><span class="line">function Index() &#123;</span><br><span class="line">  const [txt, setTxt] = useState([]);</span><br><span class="line"></span><br><span class="line">  const htmlRef = useRef();</span><br><span class="line">  let fileType = url ? url.split(&apos;.&apos;).pop() : &apos;&apos;;</span><br><span class="line"></span><br><span class="line">  const viewTxt = () =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;get&apos;, url);</span><br><span class="line">    xhr.responseType = &apos;blob&apos;;</span><br><span class="line">    xhr.onload = function() &#123;</span><br><span class="line">      var Blob = xhr.response;</span><br><span class="line">      const reader = new FileReader();</span><br><span class="line">      reader.readAsText(Blob, &apos;utf-8&apos;);</span><br><span class="line">      reader.onload = (result: any) =&gt; &#123;</span><br><span class="line">        let targetNum = result.target.result;</span><br><span class="line">        const changeString = targetNum.replace(/\r/g, &apos;&apos;).split(&apos;\n&apos;);</span><br><span class="line">        setTxt(changeString); // 存进state，用于txt文档的展示</span><br><span class="line">        if(fileType == &apos;html&apos;) &#123;</span><br><span class="line">          htmlRef.current.innerHTML = targetNum; //使用innerHTML把html字符串加入到dom中去</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    if(fileType == &apos;txt&apos; || fileType == &apos;html&apos;) viewTxt();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div style=&#123;&#123; background: &apos;#fff&apos; &#125;&#125;&gt;</span><br><span class="line">      txt文件预览： </span><br><span class="line">      &lt;div style=&#123;&#123;width: &apos;100%&apos;, height: &apos;100%&apos;&#125;&#125;&gt;&#123;txt&#125;&lt;/div&gt;</span><br><span class="line">      html文件预览</span><br><span class="line">      &lt;div ref=&#123;htmlRef&#125; style=&#123;&#123;width: &apos;100%&apos;, height: &apos;100%&apos;&#125;&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Index;</span><br></pre></td></tr></table></figure>
<p>大概的代码就是这样子，我拿到文件的url地址，通过XMLHttpRequest去请求这个资源，然后设置responseType = ‘blob’;</p>
<p>拿到返回值之后再通过FileReader的方式读取内容，然后用自己的方式展示在页面上</p>
<p>txt文件直接拿到内容就可以展示，最多处理一下换行什么的</p>
<p>html格式的比较特殊，因为需要保留人家html的样式和布局，所以使用innerHTML的方式把字符串插入到dom中</p>
]]></content>
  </entry>
  <entry>
    <title>window.print打印设置水印和页头页底</title>
    <url>/2020/05/08/print/</url>
    <content><![CDATA[<p>需求：点击打印按钮，打印出两个不同的文件，第一个文件是普通的表格，无特殊要求，第二个是打印一份录用员工的offer，打印offer需要每一页都有水印、带有公司logo的页头和带有公司网站的页底</p>
<p>每一页的带有公司logo的页头页底，可以使用样式 <code>position: fixed;</code>设置为position: fixed;样式属性的元素，可以在打印的时候每一页纸上都显示在固定位置，样式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正文部分设置适当的paddingTop值，使用 <code>pageBreakAfter: &#39;always&#39;</code>在适当的位置强制分页，效果：</p>
<p><img src="/img/print/test1.jpeg" alt="效果"></p>
<p>水印部分也要每个页面都有，同样思路使用 <code>position: fixed;</code>定位元素，正文部分要浮在水印的上面，使用<code>z-index</code>让正文部分的值高于水印部分的值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.watermark</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(10) <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fffffe</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/print/test2.png" alt="效果"></p>
<p>碰到另外一个问题：点击一个按钮同时打印出来的除了offer还有另外一个审批的表格table，这个表格不需要页头页底和水印。</p>
<p>解决方案：设置一个足够高的白色蒙版，<code>absolute</code>相对于offer定位，遮住不需要的水印和页头页底</p>
<p>absolute定位的元素不会在每一页都显示，但是会根据相对的父级元素定位，可以用来遮住不想显示的内容</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    position: <span class="string">'absolute'</span>,</span><br><span class="line">    top: <span class="number">-1199</span>,</span><br><span class="line">    left: <span class="number">0</span>,</span><br><span class="line">    width: <span class="string">'100%'</span>,</span><br><span class="line">    height: <span class="number">1200</span>,</span><br><span class="line">    zIndex: <span class="number">1</span>,</span><br><span class="line">    background: <span class="string">'#fff'</span>,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title>react/context</title>
    <url>/2018/02/28/react-context/</url>
    <content><![CDATA[<p>context 提供了一个无需为每层组件手动添加 props，就可以在组件树之间进行数据传递的方法</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li>React.createContext</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Context对象，并传递一个默认的值： defaultValue， 其他组件可以订阅这个Context对象，称为消费组件</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(<span class="string">"defaultValue"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>Context.Provider</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个Context对象都返回一个Provider React 组件，</span></span><br><span class="line">&lt;MyContext.Provider value=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt;</span><br><span class="line">  &lt;ThemedButton /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br></pre></td></tr></table></figure>
<p>Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p>
<p>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p>
<ul>
<li>订阅 Context</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过指定contextType订阅Context</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = ThemeContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.context&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Class.contextType</li>
</ul>
<p>挂在在 class 的 contextType 属性会被重新赋值为一个由 React.createContext() 创建的 Context 对象</p>
<p>在 class 内部可以使用 this.context 来消费最近的 Context 上的那个值，可以在任何生命周期中访问到它，包括 render 函数中。</p>
<ul>
<li>Context.Consumer</li>
</ul>
<p>在函数式组件中完成订阅 Context，这需要函数作为子元素，这个函数接受当前的 context 值，返回一个 React 节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* 基于 context 值进行渲染*/</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br></pre></td></tr></table></figure>
<p>传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</p>
<h2 id="动态-Context"><a href="#动态-Context" class="headerlink" title="动态 Context"></a>动态 Context</h2><h2 id="嵌套组件中更新-Context"><a href="#嵌套组件中更新-Context" class="headerlink" title="嵌套组件中更新 Context"></a>嵌套组件中更新 Context</h2><p>要在嵌套很深的组件中更新 Context，可以通过 context 传递一个函数，使得 consumers 组件更新 context</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// theme-context.js</span></span><br><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(&#123;</span><br><span class="line">  theme: themes.dark,</span><br><span class="line">  <span class="comment">// 默认值，函数</span></span><br><span class="line">  toggleTheme: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"default click"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// theme-toggler-button.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeToggleButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 利用函数式组件和Consumer订阅Context</span></span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123; theme, toggleTheme &#125;) =&gt; (</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;toggleTheme&#125;</span><br><span class="line">          style=&#123;&#123; <span class="attr">backgroundColor</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.toggleTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"click"</span>);</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        theme: state.theme === themes.dark ? themes.light : themes.dark</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggleTheme: <span class="keyword">this</span>.toggleTheme</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Content() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemeToggleButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="消费多个-Context"><a href="#消费多个-Context" class="headerlink" title="消费多个 Context"></a>消费多个 Context</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line">  &#123;theme =&gt; (</span><br><span class="line">    &lt;UserContext.Consumer&gt;</span><br><span class="line">      &#123;user =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ProfilePage</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">  )&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react-fiber 原理介绍</title>
    <url>/2020/12/30/react-fiber/</url>
    <content><![CDATA[<h2 id="为什么会出现react-fiber"><a href="#为什么会出现react-fiber" class="headerlink" title="为什么会出现react-fiber"></a>为什么会出现react-fiber</h2><p>react15的问题：当我们调用setState更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。整个过程是一气呵成，不能被打断的</p>
<p>默认情况下，js运算，页面布局，页面绘制都在浏览器的主线程运行，如果页面元素很多，在大量的频繁计算之下，js运算持续占用主线成，页面就没有办法即使的更新</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>要解决上面的问题，就是要解决js运算占用主线成大量时间的问题，将运算切割成多个部分，分批完成</p>
<p>15以下的react使用的是递归的方式进行渲染，使用js引擎自身调用函数栈，是不能被中断的，fiber使用window.requestIdleCallback()方法实现切片运行</p>
<p>window.requestIdleCallback()会在浏览器空闲时期依次调用函数，</p>
<h2 id="react是怎么做的"><a href="#react是怎么做的" class="headerlink" title="react是怎么做的"></a>react是怎么做的</h2><p>react框架内部的运作可以分为三层</p>
<ul>
<li><p>virtual DOM层，描述页面长什么样子</p>
</li>
<li><p>react reconciler（调节器） 负责调用组件生命周期方法，进行diff运算</p>
</li>
<li><p>Renderer，根据不同的平台，渲染出响应的页面，比较常见的是reactDom 和reactNative</p>
</li>
</ul>
<p>fiber 是一个新的reconciler,它有一个新的名字叫fiber-reconsiler</p>
<p>fiber-reconsiler运行一段时间就会把控制权交给浏览器</p>
<p>Fiber Reconciler 在执行过程中，会分为 2 个阶段。</p>
<ol>
<li><p>生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。</p>
</li>
<li><p>将需要更新的节点一次过批量更新，这个过程不能被打断。</p>
</li>
</ol>
<p>第一个阶段是Diff 计算的时候生成一个fiber树，这个阶段是可以被打断的，这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：</p>
<p>如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>React 使用 Redux</title>
    <url>/2018/10/27/react-redux/</url>
    <content><![CDATA[<p>Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。</p>
<p>react-redux是redux为react专门封装的库，Redux 默认并不包含 React 绑定库，需要单独安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save react-redux</span><br></pre></td></tr></table></figure>
<p>学习使用react-redux之前先了解一些知识</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。</p>
<h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h3><p>只负责展示UI</p>
<p>UI 组件有以下几个特征：</p>
<ul>
<li><p>只负责 UI 的呈现，不带有任何业务逻辑</p>
</li>
<li><p>没有状态</p>
</li>
<li><p>所有数据都由参数（props）提供</p>
</li>
<li><p>不使用任何 Redux 的 API</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Title =</span><br><span class="line">  value =&gt; <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值。</p>
<h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><p>容器组件的特征恰恰相反:</p>
<ul>
<li><p>负责管理数据和业务逻辑，不负责 UI 的呈现</p>
</li>
<li><p>带有内部状态</p>
</li>
<li><p>使用 Redux 的 API</p>
</li>
</ul>
<h2 id="学习使用react-redux"><a href="#学习使用react-redux" class="headerlink" title="学习使用react-redux"></a>学习使用react-redux</h2><p>从一个例子，来学习如何使用react-redux：实现一个todo列表，一个 todo 项被点击后，会增加一条删除线并标记 completed。我们会显示用户新增一个 todo 字段。在 footer 里显示一个可切换的显示全部/只显示 completed 的/只显示 incompleted 的 todos。</p>
<p>这里使用react hooks ，ts 外加react-redux实现，整体的思路是先写出UI组件，在使用react-redux把UI组件和状态业务逻辑链接起来</p>
<h3 id="写出UI组件"><a href="#写出UI组件" class="headerlink" title="写出UI组件"></a>写出UI组件</h3><h4 id="todo项组件"><a href="#todo项组件" class="headerlink" title="todo项组件"></a>todo项组件</h4><p>负责展示每一条todo的内容，先简单的写一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface TodoProps &#123;</span><br><span class="line">  text: string</span><br><span class="line">&#125;</span><br><span class="line">const Todo = (&#123;text&#125;: TodoProps) =&gt; (</span><br><span class="line">  &lt;li&gt;&#123;text&#125;&lt;/li&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="TodoList组件"><a href="#TodoList组件" class="headerlink" title="TodoList组件"></a>TodoList组件</h4><p>负责展示整个todo列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;todos.map((todo, index) =&gt; (</span><br><span class="line">      &lt;Todo key=&#123;index&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(index)&#125; /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h4><p>在footer里面用来展示todos</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Link = (&#123; active, children &#125;: LinkProps) =&gt; &#123;</span><br><span class="line">  if (active) &#123;</span><br><span class="line">    return &lt;span&gt;&#123;children&#125;&lt;/span&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href=&quot;&quot; &gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Footer组件"><a href="#Footer组件" class="headerlink" title="Footer组件"></a>Footer组件</h3><p>然后如何把UI组件和redux的state连接起来呢？这就是react-redux做的工作了，React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。</p>
<h3 id="生成容器组件"><a href="#生成容器组件" class="headerlink" title="生成容器组件"></a>生成容器组件</h3><p>content()使用方法，把刚才写的UI组件TodoList生成容器组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure>
<p>content()是一个高阶组件，接受两个参数mapStatetoProps和mapDispatchToProps</p>
<p>使用 connect() 生成容器组件之前，需要先定义 mapStateToProps 这个函数来指定如何把当前 Redux store state 映射到展示组件的 props 中。</p>
<h4 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h4><p>mapStateToProps是一个函数，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。该函数执行后返回一个对象，里面每一个健值对就是一个映射。</p>
<p>mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p>mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。</p>
<p>connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p>
<p>上面例子的需求中：在footer 里显示一个可切换的显示全部/只显示 completed 的/只显示 incompleted 的 todos，所以定义了根据 state.visibilityFilter 来过滤 state.todos 的方法，并在 mapStateToProps 中使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getVisibleTodos = (todos: any[], filter: string) =&gt; &#123;</span><br><span class="line">  switch (filter) &#123;</span><br><span class="line">    case &apos;SHOW_COMPLETED&apos;:</span><br><span class="line">      return todos.filter(t =&gt; t.completed)</span><br><span class="line">    case &apos;SHOW_ACTIVE&apos;:</span><br><span class="line">      return todos.filter(t =&gt; !t.completed)</span><br><span class="line">    case &apos;SHOW_ALL&apos;:</span><br><span class="line">    default:</span><br><span class="line">      return todos</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapStateToProps接受state作为参数，返回一个对象，对象有一个todos属性，代表了UI组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。</p>
<h4 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h4><p>除了读取 state，容器组件还能分发 action。这就要用到connect()方法的第二个参数,mapDispatchToProps可以是一个函数，也可以是一个对象。</p>
<p>mapDispatchToProps() 方法接收 dispatch() 方法并返回期望注入到展示组件的 props 中的回调方法</p>
<p>mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p>
<p>如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。</p>
<p>现在我们希望 VisibleTodoList 向 TodoList 组件中注入一个叫 onTodoClick 的 props ，还希望 onTodoClick 能分发 TOGGLE_TODO 这个 action：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mapDispatchToProps = dispatch =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    onTodoClick: id =&gt; &#123;</span><br><span class="line">      dispatch(toggleTodo(id))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完。。。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.redux.org.cn/docs/react-redux/" target="_blank" rel="noopener">react-redux文档</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" target="_blank" rel="noopener">Redux 入门教程（三）：React-Redux 的用法</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react/refs</title>
    <url>/2018/02/15/react-refs/</url>
    <content><![CDATA[<p>官网文档的搬运者</p>
<h2 id="何时使用-refs"><a href="#何时使用-refs" class="headerlink" title="何时使用 refs"></a>何时使用 refs</h2><ol>
<li><p>管理焦点，文本选择或媒体播放</p>
</li>
<li><p>触发强制动画。</p>
</li>
<li><p>集成第三方 DOM 库。</p>
</li>
</ol>
<h2 id="创建-ref"><a href="#创建-ref" class="headerlink" title="创建 ref"></a>创建 ref</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 创建ref</span></span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="keyword">this</span>.myRef.current;</span><br></pre></td></tr></table></figure>
<h3 id="ref-的值根据节点的类型而有所不同："><a href="#ref-的值根据节点的类型而有所不同：" class="headerlink" title="ref 的值根据节点的类型而有所不同："></a>ref 的值根据节点的类型而有所不同：</h3><ul>
<li><p>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</p>
</li>
<li><p>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。</p>
</li>
<li><p>你不能在函数组件上使用 ref 属性，因为他们没有实例。</p>
</li>
</ul>
<h2 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用原生 DOM API 使 text 输入框获得焦点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.textInput) <span class="keyword">this</span>.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，让文本框自动获得焦点</span></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React</span></span><br><span class="line">    <span class="comment">// 实例上（比如 this.textInput）</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.setTextInputRef&#125; /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以在组件间传递回调形式的 refs，就像你可以传递通过 React.createRef() 创建的对象 refs 一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;CustomTextInput inputRef=&#123;el =&gt; (this.inputElement = el)&#125; /</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转发-refs-到-DOM-组件"><a href="#转发-refs-到-DOM-组件" class="headerlink" title="转发 refs 到 DOM 组件"></a>转发 refs 到 DOM 组件</h2><p>Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="comment">// 当 ref 挂载完成，ref.current 将指向 &lt;button&gt; DOM 节点。</span></span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"FancyButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 你可以直接获取 DOM button 的 ref：</span></span><br><span class="line"><span class="regexp">const ref = React.createRef();</span></span><br><span class="line"><span class="regexp">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/</span>FancyButton&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="在高阶组件-HOC-中转发-refs"><a href="#在高阶组件-HOC-中转发-refs" class="headerlink" title="在高阶组件(HOC)中转发 refs"></a>在高阶组件(HOC)中转发 refs</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"old props:"</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"new props:"</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return LogProps;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class FancyButton extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  focus() &#123;&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default logProps(FancyButton);</span></span><br></pre></td></tr></table></figure>
<p>调用高阶组件：logProps组件，并且传递props时，高阶组件会透传props到他的包裹组件，但refs不会传递，因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。</p>
<h3 id="使用React-forwardRef在高阶组件中传递refs"><a href="#使用React-forwardRef在高阶组件中传递refs" class="headerlink" title="使用React.forwardRef在高阶组件中传递refs"></a>使用React.forwardRef在高阶组件中传递refs</h3><p>重写上面的高阶组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"old props:"</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"new props:"</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...rest &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // return LogProps;</span></span><br><span class="line"><span class="xml">  return React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class="line">    return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react/renderProps</title>
    <url>/2017/12/08/react-renderProps/</url>
    <content><![CDATA[<p>具有reader prop的组件，接受一个函数，该函数返回一个react元素，并调用它，而不是事先自己的渲染逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">)&#125;/</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如何分享一个组件封装到其他需要相同state组件的状态或行为并不是很容易</p>
<p>render prop是一个用于告知组件需要渲染什么内容的函数prop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse = this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p style=&#123;&#123; position: &quot;absolute&quot;, left: mouse.x, top: mouse.y &#125;&#125;&gt;猫咪&lt;/p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handelMouseMove = this.handelMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handelMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123;&#123; height: &quot;100%&quot; &#125;&#125; onMouseMove=&#123;this.handelMouseMove&#125;&gt;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标！&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; &lt;Cat mouse=&#123;mouse&#125; /&gt;&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MouseTracker;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>网站收藏</title>
    <url>/2018/07/10/site/</url>
    <content><![CDATA[<p><a href="https://www.phodal.com/" target="_blank" rel="noopener">phodal博客</a></p>
<p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></p>
<p><a href="https://github.com/happyrui/nestTodoList/tree/develop" target="_blank" rel="noopener">赵芮(微盟同事)的github</a></p>
<p><a href="https://blog.csdn.net/zr15829039341" target="_blank" rel="noopener">赵芮(微盟同事)的博客</a></p>
<p><a href="https://martindelophy.github.io/blog/" target="_blank" rel="noopener">杨海鑫（同事）的博客</a></p>
]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks 数据流</title>
    <url>/2020/08/04/react-hooks-dataStream/</url>
    <content><![CDATA[<h2 id="单组件数据流"><a href="#单组件数据流" class="headerlink" title="单组件数据流"></a>单组件数据流</h2><p>使用useState，毫无争议</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件间共享数据流"><a href="#组件间共享数据流" class="headerlink" title="组件间共享数据流"></a>组件间共享数据流</h2><p>我们首先想到的就是useContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建Context</span><br><span class="line">const CountContext = createContext&lt;any&gt;(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  let [count, setCount] = useState(1);</span><br><span class="line"></span><br><span class="line">  function add() &#123;</span><br><span class="line">    setCount(++count);</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    // 通过父级组件分发</span><br><span class="line">    &lt;CountContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt;</span><br><span class="line">      &lt;Card title=&quot;createContext&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">        &lt;Child2 /&gt;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    &lt;/CountContext.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">  let &#123; count, setCount &#125; = useContext(CountContext);</span><br><span class="line"></span><br><span class="line">  function add() &#123;</span><br><span class="line">    setCount(--count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;count:&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;add&#125;&gt;-&lt;/Button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">function Child2() &#123;</span><br><span class="line">  let &#123; count, setCount &#125; = useContext(CountContext);</span><br><span class="line"></span><br><span class="line">  function add() &#123;</span><br><span class="line">    setCount(count - 2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;count:&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;add&#125;&gt;-2&lt;/Button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题是数据与 UI 不解耦，我看到这里的时候，我也不是很明白，我感觉这个很好用，然后接着往下看</p>
<h2 id="数据流与组件解耦-hooks-state-unstated-next"><a href="#数据流与组件解耦-hooks-state-unstated-next" class="headerlink" title="数据流与组件解耦 hooks state + unstated-next"></a>数据流与组件解耦 hooks state + unstated-next</h2><p>unstated-next 是一个React轻量状态管理库，可以帮你把上面例子中，定义在 组件 中的数据单独出来，形成一个自定义数据管理 Hook：</p>
<p><a href="https://github.com/jamiebuilds/unstated-next" target="_blank" rel="noopener">unstated-next</a></p>
<p>简单的API介绍</p>
<ol>
<li><p>unstated-next提供 const Counter = createContainer(useCounter)方法， 创建一个状态管理类，相当于一个容器</p>
</li>
<li><p>Counter.Provider，包裹共享的数据，向应用中注入状态管理实例，</p>
</li>
<li><p>Counter.useContainer，在子组件使用共享的数据</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createContainer &#125; from &quot;unstated-next&quot;;</span><br><span class="line"></span><br><span class="line">// 自定义数据管理 Hook</span><br><span class="line">function useCounter() &#123;</span><br><span class="line">  const [state, setState] = useState&lt;any&gt;(&#123;a: 100, b: 200&#125;);</span><br><span class="line">  return &#123; ...state, setState &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const Counter = createContainer(useCounter);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Counter.Provider&gt;</span><br><span class="line">      &lt;CounterDisplay /&gt;</span><br><span class="line">    &lt;/Counter.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function CounterDisplay() &#123;</span><br><span class="line">  let &#123; a, b, setState &#125; = Counter.useContainer();</span><br><span class="line"></span><br><span class="line">  function changeA() &#123;</span><br><span class="line">    setState(&#123;a: a + 1&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeB()&#123;</span><br><span class="line">    setState(&#123;b: b + 1, a: a + 2&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;unstated-next&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;a:&#123;a&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;changeA&#125;&gt;A加一&lt;/Button&gt;</span><br><span class="line">      &lt;p&gt;b:&#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;changeB&#125;&gt;A加2，B加2&lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法解决了数据流与组件解耦，但是带来了新的问题，就是useState 无法合并更新</p>
<h2 id="合并更新"><a href="#合并更新" class="headerlink" title="合并更新"></a>合并更新</h2><p>为了让数据能够合并更新，我想到了useReducer 可以让数据合并更新，现在的思路就是：</p>
<p>hooks state + unstated-next + useReducer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createContainer &#125; from &quot;unstated-next&quot;;</span><br><span class="line"></span><br><span class="line">function useCounterR()&#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, &#123;a: 100, b: 200&#125;);</span><br><span class="line"></span><br><span class="line">  function reducer(state: any, action: any) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case &apos;add&apos;: </span><br><span class="line">        return &#123;...state, a: state.a + 2&#125;;</span><br><span class="line">      case &apos;dec&apos;:</span><br><span class="line">        return &#123;...state, a: state.a - 10&#125;;</span><br><span class="line">      case &apos;double&apos;:</span><br><span class="line">        return &#123;...state, b: state.b * 2&#125;;</span><br><span class="line">      case &apos;triple&apos;:</span><br><span class="line">        return &#123;...state, b: state.b * 3&#125;;</span><br><span class="line">      default:</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回state和修改state的dispatch</span><br><span class="line">  return &#123; ...state, dispatch &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const CounterR = createContainer(useCounterR);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;CounterR.Provider&gt;</span><br><span class="line">      &lt;ViewR /&gt;</span><br><span class="line">      &lt;ViewR2 /&gt;</span><br><span class="line">    &lt;/CounterR.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR() &#123;</span><br><span class="line">  let &#123;a, b, dispatch&#125; = CounterR.useContainer();</span><br><span class="line"></span><br><span class="line">  console.log(&apos;ViewR&apos;, a, b);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;reducer&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;a: &#123;a&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;b:&#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;add&apos;&#125;)&#125;&gt;</span><br><span class="line">        a + 2</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;triple&apos;&#125;)&#125;&gt;</span><br><span class="line">        b乘以3</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR2() &#123;</span><br><span class="line">  let &#123;b, dispatch&#125; = CounterR.useContainer();</span><br><span class="line"></span><br><span class="line">  console.log(&apos;ViewR2&apos;, b);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;reducer&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;b:&#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;triple&apos;&#125;)&#125;&gt;</span><br><span class="line">        b乘以3</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在终于能合并更新了，然后我发现了新的问题，就是子组件之间会相互影响，一个子组件修改了state，其他的子组件会一起重新渲染</p>
<p>这个原因是 Counter.useContainer 提供的数据流是一个引用整体，其子节点 引用变化后会导致整个 Hook 重新执行，继而所有引用它的组件也会重新渲染。</p>
<h2 id="按需更新"><a href="#按需更新" class="headerlink" title="按需更新"></a>按需更新</h2><p>所以我知道了redux为什么会比他们火的原因了</p>
<p>可以利用 Redux useSelector 实现按需更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &quot;redux&quot;;</span><br><span class="line">import &#123; Provider, useSelector, shallowEqual &#125; from &quot;react-redux&quot;;</span><br><span class="line"></span><br><span class="line">const defaultState = &#123;a: 100, b: 200, user: &#123;name: &apos;xinxin&apos;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state: any = defaultState, action: any) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;add&apos;: </span><br><span class="line">      return &#123;...state, a: state.a + 2&#125;;</span><br><span class="line">    case &apos;dec&apos;:</span><br><span class="line">      return &#123;...state, a: state.a - 10&#125;;</span><br><span class="line">    case &apos;double&apos;:</span><br><span class="line">      return &#123;...state, b: state.b * 2&#125;;</span><br><span class="line">    case &apos;triple&apos;:</span><br><span class="line">      return &#123;...state, b: state.b * 3&#125;;</span><br><span class="line">    case &apos;setUser&apos;:</span><br><span class="line">      return &#123;...state, user: &#123;name: &apos;xinxin222&apos;&#125;&#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;ViewR3 /&gt;</span><br><span class="line">      &lt;ViewR4 /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR3() &#123;</span><br><span class="line">  // useSelector 接受第一个参数selector函数</span><br><span class="line">  // 要保持这个selector是一个纯函数</span><br><span class="line">  // selector会返回任何值作为结果，并不仅仅是对象了。然后这个selector返回的结果，就会作为useSelector的返回结果。</span><br><span class="line">  // 当action被dispatched的时候，useSelector()将对前一个selector结果值和当前结果值进行浅比较。如果不同，那么就会被re-render。 反之亦然</span><br><span class="line">  // selector不会接收ownProps参数，但是，可以通过闭包(下面有示例)或使用柯里化selector来使用props。</span><br><span class="line">  // 使用记忆(memoizing) selector时必须格外小心(下面有示例)。</span><br><span class="line">  // useSelector()默认使用===(严格相等)进行相等性检查，而不是浅相等(==)。</span><br><span class="line">  const &#123; a &#125; = useSelector(</span><br><span class="line">    (state:any = &#123;&#125;) =&gt; (&#123; a: state.a &#125;),</span><br><span class="line">    shallowEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  const setA = (a: number) =&gt; a + 2;</span><br><span class="line"></span><br><span class="line">  console.log(1);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;redux&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;a: &#123;a&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;add&apos;, setA&#125;)&#125;&gt;</span><br><span class="line">        a + 2</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR4() &#123;</span><br><span class="line">  const &#123; b &#125; = useSelector(</span><br><span class="line">    (state:any = &#123;&#125;) =&gt; (&#123; b: state.b &#125;),</span><br><span class="line">    shallowEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  const setB = (b: number) =&gt; b + 3;</span><br><span class="line"></span><br><span class="line">  console.log(2);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;redux&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;b: &#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;setB&apos;, setB&#125;)&#125;&gt;</span><br><span class="line">        b + 3</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reducer 可以让子组件之间会相互不影响，一个子组件修改了state，其他的子组件不会一起重新渲染</p>
<p>然后有发现了一个新的问题：但 useSelector 的作用仅仅是计算结果不变化时阻止组件刷新，但并不能保证返回结果的引用不变化。</p>
<p>当state的值是引用类型的时候，每次都会返回一个新的引用，虽然属性值和数量都没有发生变化，但是还是会引起组件重新渲染，如果有子组件也会重新渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;ViewR5 /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR5() &#123;</span><br><span class="line">  const [myUser, setMyUser] = useState();</span><br><span class="line">  const &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">    (state: any) =&gt; (&#123;user: state.user&#125;),</span><br><span class="line">    shallowEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(myUser, user, Object.is(myUser, user));</span><br><span class="line">    setMyUser(user);</span><br><span class="line">  &#125;, [user])</span><br><span class="line"></span><br><span class="line">  const setUserName = (user: any) =&gt; (&#123;name: &apos;xinxin 22222&apos;&#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;使用Redux，防止数据引用频繁变化&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;userName: &#123;user.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;setUser&apos;, setUserName&#125;)&#125;&gt;</span><br><span class="line">        setUserName</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码console.log(myUser, user, Object.is(myUser, user));打印出来每次myUser, user这两个对象的属性数量和属性值都没发生变化，但是Object.is判断返回false，因为他们不是来自同一个引用类型的</p>
<h2 id="防止数据引用频繁变化"><a href="#防止数据引用频繁变化" class="headerlink" title="防止数据引用频繁变化"></a>防止数据引用频繁变化</h2><p>为了防止数据引用频繁变化而带来的组件重新渲染，浅比较shallowEqual是不起作用的，尝试使用deepEqual</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ViewR6() &#123;</span><br><span class="line">  const &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">    (state: any) =&gt; (&#123;user: state.user&#125;),</span><br><span class="line">    deepEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  const setUserName = (user: any) =&gt; (&#123;name: &apos;xinxin 22222&apos;&#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;使用Redux，防止数据引用频繁变化&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;userName: &#123;user.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;RChild name=&#123;user.name&#125;  /&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;setUser&apos;, setUserName&#125;)&#125;&gt;</span><br><span class="line">        setUserName</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">function RChild(props) &#123;</span><br><span class="line">  console.log(props.name);</span><br><span class="line">  return &lt;p&gt;&#123;props.name&#125;&lt;/p&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，发现组件不在重新渲染了，现在的问题是这段代码我们拿到的还是新的引用，只不过我们通过deepEqual对前后两次的值进行深比较，在useSelector不在返回新的引用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">  (state: <span class="built_in">any</span>) =&gt; (&#123;user: state.user&#125;),</span><br><span class="line">  deepEqual  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果换成通过机构计算函数去获取状态，像这样子</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">user: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">Object</span>.is(myUser, user)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myUser, user, <span class="built_in">Object</span>.is(myUser, user)); <span class="comment">// false</span></span><br><span class="line">    myUser = user;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">  (state: <span class="built_in">any</span>) =&gt; (&#123;user: getUser(state.user)&#125;),</span><br><span class="line">  deepEqual  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>运行代码，证明console.log(myUser, user, Object.is(myUser, user));会打印出false，说明这里计算函数不管每次接收到的参数是不是一样，每次接收到的都是一个新的引用，所以都会进行重新计算，如果计算函数是一个很复杂，消耗资源的函数，在拿到的引用类型属性值和数量是一样的时候不应该去重新计算</p>
<p>所以给大家介绍一个reselect 中间件，可以对引用进行缓存</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>了解react hooks 数据流</p>
</li>
<li><p>单组件数据流，使用useState</p>
</li>
<li><p>共享数据流，useContext，数据与 UI 不解耦</p>
</li>
<li><p>为了数据流与组件解耦， hooks state + unstated-next， 带来了新的问题，就是useState 无法合并更新</p>
</li>
<li><p>为了让数据能够合并更新，我想到了useReducer 可以让数据合并更新，问题是：子组件之间会相互影响</p>
</li>
<li><p>为了让子组件不相互影响，redux按需更新， 新问题：useSelector 的作用仅仅是计算结果不变化时阻止组件刷新，但并不能保证返回结果的引用不变化。引用变化了子组件会更新</p>
</li>
<li><p>防止数据引用频繁变化， deepEqual解决引用频繁变化</p>
</li>
<li><p>发现新的问题，计算函数消耗资源，reselect 中间件引用进行缓存</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>redux学习</title>
    <url>/2018/08/11/redux/</url>
    <content><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>
<p>redux三大原则：</p>
<ul>
<li><p>单一数据源</p>
</li>
<li><p>state是只读的</p>
</li>
<li><p>使用纯函数来改变state</p>
</li>
</ul>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>createStore()方法可以创建一个store，该方法接受一个reducer，reducer描述如何处理store的更新</p>
<p>store是一个对象，用来保存整个应用的状态，一个应用只能有一个store，作为数据的来源</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>提供 getState() 方法获取 当前的state；</p>
</li>
<li><p>提供 dispatch(action) 方法更新 state；stroe是不可以随意修改的，只能通过store.dispatch(action)来修改</p>
</li>
<li><p>通过 subscribe(listener) 注册监听器;</p>
</li>
<li><p>通过 subscribe(listener) 返回的函数注销监听器。</p>
</li>
</ul>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>getState() 方法获取 state，state是当前的状态，state和视图层是一一对应的</p>
<h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h3><p>通过store.dispatch(action)方法触发更新store，action定义当前应该如何更新store，具体的更新操作有reducer完成</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action是一个对象，对象中不可缺少的type属性，描述如何更新store，对象中也可以根据需要定义其他的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<p>它的主要作用是根据action来更新state，返回一个新的state</p>
<p>reducer必须是一个纯函数，同样的输入必须有同样的输出，也就是说同样action和state返回的新的state也必须是一样的</p>
<h3 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h3><p>设置监听函数，一旦store发生变化，就会自动执行这个store.subscribe()，主要是用来监听store的变化更新视图层</p>
<p>store.subscribe()返回一个函数，调用返回的函数，可以解除监听</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>一个结合react的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始的store</span></span><br><span class="line"><span class="keyword">const</span> defaultState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + action.payload;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REDUCE'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - action.payload;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testRedux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(defaultState);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(store.getState());</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="comment">// action</span></span><br><span class="line">  <span class="keyword">const</span> addAction = &#123;<span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> reduceAction = &#123;<span class="attr">type</span>: <span class="string">'REDUCE'</span>, <span class="attr">payload</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(store.getState());</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; &#123;store.dispatch(addAction)&#125;&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;store.dispatch(reduceAction)&#125;&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>项目特别大的时候，store的结构也会很复杂，像这样子，会有很多属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store = &#123;</span><br><span class="line">  count: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  todoList: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  list: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导致reducer函数也会十分庞大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;count, todoList&#125; = state;</span><br><span class="line">  <span class="keyword">const</span> &#123;type, payload&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: count + payload&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REDUCE'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: count - payload&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">todoList</span>: [...todoList, <span class="string">`这是一个待办<span class="subst">$&#123;todoList.length&#125;</span>`</span>]&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是不同的action会更新store不同的属性，往往是不相关的，可以把reducer拆分成函数，不同的reducer处理不同的属性，redux提供辅助函数combineReducers来合并reducer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countReducer = <span class="function">(<span class="params">count = defaultState.count, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;type, payload&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> count + payload;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REDUCE'</span>:</span><br><span class="line">      <span class="keyword">return</span> count - payload;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoReducer = <span class="function">(<span class="params">todoList = defaultState.todoList, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;type&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>: </span><br><span class="line">      <span class="keyword">return</span> [...todoList, <span class="string">`这是一个待办<span class="subst">$&#123;todoList.length&#125;</span>`</span>]</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> [...todoList];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  count: countReducer, <span class="attr">todoList</span>: todoReducer</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实际开发的时候，可以把所有的reducer写在一个文件中，然后统一引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(reducers)</span><br></pre></td></tr></table></figure>
<h2 id="redux的数据流方向"><a href="#redux的数据流方向" class="headerlink" title="redux的数据流方向"></a>redux的数据流方向</h2><p>严格的单向数据流是 Redux 架构的设计核心</p>
<h3 id="redux的工作流程"><a href="#redux的工作流程" class="headerlink" title="redux的工作流程"></a>redux的工作流程</h3><p>从redux的工作流程可以看出数据的流动方向</p>
<ul>
<li><p>首先创建store：通过createStore(reducer)方法传入一个reducer，创建一个store</p>
</li>
<li><p>提前写好reducer，reducer是一个函数，接受一个当前的state和action作为参数，并在函数中做我们要做的数据处理</p>
</li>
<li><p>通过store.getState() 方法获取当前的state，state和视图层是一一对应的</p>
</li>
<li><p>用户想要更新界面，也就是要更新state，需要调用store.dispatch(action)，来改变state，action也是提前写好的</p>
</li>
<li><p>store接受到dispatch之后会自动调用reducer方法，并把当前最新的state和dispatch方法接收到的action传入其中</p>
</li>
<li><p>reducer负责根据action 更新state。并返回一个新的state</p>
</li>
<li><p>state一旦有变化，store就会调用store.subscribe(listener)，store.subscribe()接受一个函数listener，在listener中可以通过store.getState() 方法获取被reducer处理过的state，然后更新界面</p>
</li>
<li><p>如果结合react，可以把setState()方法放在listener函数中去调用，然后以此更新界面</p>
</li>
</ul>
<h2 id="异步action"><a href="#异步action" class="headerlink" title="异步action"></a>异步action</h2><p>刚才写的全部都是同步更新state，store发出action之后自动调用reducer方法，state立即更新，然后就拿新的数据更新UI层</p>
<p>但是，很多情况下，都需要从接口拉取数据，根据异步请求的知识，等接口返回数据之后，在执行reducer，然后才会用接口返回的数据更新state，再拿新的state更新UI层，这就需要异步数据流来实现，来看一下redux是如何实现异步数据流的</p>
<p>这就涉及到一个知识点，如何让reducer在接口返回了数据之后自动执行，这就需要先了解一个知识点，叫中间件</p>
<h3 id="Middleware（中间件）"><a href="#Middleware（中间件）" class="headerlink" title="Middleware（中间件）"></a>Middleware（中间件）</h3><p>Middleware可以增强store.dispatch()，可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。</p>
<p>以异步获取接口数据为例子使用中间件：</p>
<p>异步action，就是发出三种action</p>
<ol>
<li><p>在发起请求接口，发出一个action，去请求接口</p>
</li>
<li><p>接口返回数据成功后，发出一个action，调用reducer，更新store，继而获取最新的state，然后更新UI</p>
</li>
<li><p>接口返回失败的时候，发出一个action，</p>
</li>
</ol>
<p>用户触发第一个action是没有问题的，那么如何才能在接口有返回数据的时候触发第二个action去更改state呢？就需要先知道一个知识点：Action Creator，这个东西呢是用来生成action的，一般同步的action 生成比较简单，也好理解，就是返回一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addAction</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: add,</span><br><span class="line">    payload</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候</span></span><br><span class="line">store.dispatch(addAction)</span><br></pre></td></tr></table></figure>
<p>异步的action Creator，返回一个函数，这个函数首先dispatch一个同步action，然后进行异步操作，也就是请求接口的数据，这里使用原生的fetch方法，等到接口有返回数据之后，在then（）函数里调用第二个dispatch，提前写好要用的reducer，我还写了一个按钮来调用action，简单的代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tagsReducer = <span class="function">(<span class="params">tags = defaultState.tags, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;type, payload = &#123;&#125;&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'requestData'</span>: </span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">loading</span>: <span class="literal">true</span>, <span class="attr">list</span>: []&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reciveData'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">list</span>: [...payload.list]&#125;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> &#123;...tags&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'requestData'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reciveData = <span class="function">(<span class="params">payload: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'reciveData'</span>,</span><br><span class="line">      payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span> =&gt;</span> (dispatch: any, <span class="attr">getState</span>: any) =&gt; &#123;</span><br><span class="line">    dispatch(requestData());</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">'/api/tags'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()).then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(reciveData(json)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;store.dispatch(fetchData)&#125;&#125;&gt;异步获取数据&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>点了按钮之后，发现代码报错：<code>Error: Actions must be plain objects. Use custom middleware for async actions.</code>，意思就是action必须是纯对象，如果是异步 action，需要使用自定义的中间件</p>
<p>现在就知道中间件的意义了，本来action只能是一个对象，store.dispatch（action）方法也只能接受一个对象，所以现在需要一个中间件，来让store.dispatch()能够接受一个函数作为参数</p>
<p>redux-thunk就是具有这样子功能的一个中间件，首先安装一下 <code>yarn add redux-thunk</code>，然后配合redux提供的applyMiddleware使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));</span><br></pre></td></tr></table></figure>
<p>createStore可以接受applyMiddleware作为第二个参数，applyMiddleware是一个方法，接受我们要使用的中间件，然后再次点击按钮，可以正常的使用了，没有报错，现在可以正常的使用redux处理异步数据流了</p>
<p>当然支持异步能支持异步数据流的中间件不只有redux-thunk，redux-promise也是一样可以的</p>
<p>关于redux的知识点看了这些之后差不多就会使用redux了</p>
<p>参考链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">阮一峰老师：Redux 入门教程（二）：中间件与异步操作</a></p>
<p><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">Redux 中文文档</a></p>
<p><a href="https://juejin.im/post/6856791557035524109#heading-14" target="_blank" rel="noopener">redux教程</a></p>
]]></content>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>编写可维护的webpack构建配置，进阶学习</title>
    <url>/2020/05/27/webpack-builder/</url>
    <content><![CDATA[<p>如何把webpack的配置编写的更加通用，把webpack的配置编写成一个构建包，在每个项目里都能快速使用</p>
<p>现在的webpack配置分为webpack.prod.js，  webpack.dev.js，  webpack.ssr.js，分别对应三个不同的环境场景，三个配置文件里面的配置有些都是相同的例如es6代码的转换，react的使用、处理less样式文件等，不得不每次复制到每个配置文件代码里面去，而不同的环境场景的配置又具有差异，解决思路就是新建一个webpack.base.js文件存放共用的配置，使用webpack-merge组件合并配置</p>
<p>在根目录新建build-webpack文件夹，cd build-webpack，进入目录，npm init -y初始化package.json文件</p>
<p>build-webpack文件夹下新建lib目录，存放webpack配置文件，在lib文件下新建webpack.base.js，webpack.prod.js，  webpack.dev.js，  webpack.ssr.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.base.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> FriendlyErrorsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置entry 和 htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index.jsx'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.jsx/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = entryFile;</span><br><span class="line">    htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        chunks: [<span class="string">'vendors'</span>, pageName],</span><br><span class="line">        inject: <span class="literal">true</span>,</span><br><span class="line">        minify: &#123;</span><br><span class="line">          html5: <span class="literal">true</span>,</span><br><span class="line">          preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          minifyCSS: <span class="literal">true</span>,</span><br><span class="line">          minifyJS: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlWebpackPlugin&#125; = setMPA();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(projectRoot, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            remUnit: <span class="number">75</span>, <span class="comment">// 转换率：1rem = 75px</span></span><br><span class="line">            remPrecision: <span class="number">8</span> <span class="comment">// 转换之后保留小数点后位数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...htmlWebpackPlugin,</span><br><span class="line">    <span class="keyword">new</span> FriendlyErrorsWebpackPlugin(),</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hooks.done.tab(<span class="string">'done'</span>, (stats) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf(<span class="string">'--watch'</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'build error'</span>);</span><br><span class="line">          process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  stats: <span class="string">'errors-only'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装 :<code>npm i webpack-merge -D</code></p>
<p>webpack.dev.js包括热更新和source-map，使用webpack-merge合并配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热更新，source-map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 服务基础目录</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 开启热更新</span></span><br><span class="line">    stats: <span class="string">'errors-only'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, devConfig);</span><br></pre></td></tr></table></figure>
<p>webpack.prod.jsb包括代码压缩，文件指纹,公共资源的提取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码压缩，文件指纹,公共资源的提取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react@16/umd/react.development.js'</span>,</span><br><span class="line">        global: <span class="string">'React'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react-dom@16/umd/react-dom.development.js'</span>,</span><br><span class="line">        global: <span class="string">'ReactDom'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: <span class="number">0</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: <span class="string">'commons'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, prodConfig);</span><br></pre></td></tr></table></figure>
<p>webpack.ssr.js主要是不解析css文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.ssr.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码压缩，文件指纹,公共资源的提取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: <span class="string">'ignore-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: <span class="string">'ignore-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react@16/umd/react.development.js'</span>,</span><br><span class="line">        global: <span class="string">'React'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react-dom@16/umd/react-dom.development.js'</span>,</span><br><span class="line">        global: <span class="string">'ReactDom'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: <span class="number">0</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: <span class="string">'commons'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, prodConfig);</span><br></pre></td></tr></table></figure>
<p>新建.gitignore文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/node_modules</span><br><span class="line">/logs</span><br></pre></td></tr></table></figure>
<h2 id="使用eslint规范构建脚本"><a href="#使用eslint规范构建脚本" class="headerlink" title="使用eslint规范构建脚本"></a>使用eslint规范构建脚本</h2><p>eslint可以帮助在构建之前检查代码的规范，而不是等到运行的时候在报错</p>
<p>在build-webpack目录安装eslint以及eslint所需要的依赖：<code>npm i eslint eslint-config-airbnb-base babel-eslint -D</code></p>
<p>新建.eslintrc.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build-webpack/.eslintrc.</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"airbnb-base"</span>,</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"node"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在package.json增加eslint script</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// build-webpack/package.json</span><br><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "eslint": "eslint ./lib --fix"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run eslint可以帮助在构建之前检查规范，</p>
<p>在命令行运行npm run eslint</p>
<p><img src="/img/webpack/w17.png" alt="图片"></p>
<p>这边的报错是因为我的webpack配置中使用的插件没有安装</p>
<p>根据报错一次安装插件到dependencies，根据提示解决报错</p>
<h2 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h2><p>冒烟测试确保构建没有大问题，检测一些基本的功能可用</p>
<p>例如构建是否成功，每次构建完成是否正确的打包静态资源</p>
<p>在test新建template目录，作为模版目录，也就是要使用构建脚本构建的项目，可以把之前的项目复制一份进来，删除不需要的文件：</p>
<p><img src="/img/webpack/w18.png" alt="图片"></p>
<p>在build-webpack目录新建test目录，test新建smoke目录，smoke新建index.js文件用来编写测试脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/smoke/index.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> rimraf = <span class="built_in">require</span>(<span class="string">'rimraf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入tamplate，__dirname代表运行时候的目录</span></span><br><span class="line">process.chdir(path.join(__dirname, <span class="string">'template'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次构建之前，删除dist目录</span></span><br><span class="line">rimraf(<span class="string">'./dist'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 引入配置</span></span><br><span class="line">  <span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">'../../lib/webpack.prod.js'</span>);</span><br><span class="line">  <span class="comment">// 通过webpack对template目录的代码运行prodConfig这个配置</span></span><br><span class="line">  webpack(prodConfig, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      process.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(stats.toString(&#123;</span><br><span class="line">      color: <span class="literal">true</span>,</span><br><span class="line">      modules: <span class="literal">false</span>,</span><br><span class="line">      children: <span class="literal">false</span></span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在build-webpack目录安装： <code>npm i rimraf -S</code></p>
<p>修改webpack.base.js文件，增加projectRoot，修改执行的目录为tamplate目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.base.js</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = process.cwd(); <span class="comment">// 当前目录</span></span><br><span class="line"><span class="keyword">const</span> setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(projectRoot, <span class="string">'./src/*/index.jsx'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(projectRoot, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在终端运行：<code>node test/smoke/index.js</code></p>
<h3 id="检查dist目录是否有构建出来的文件"><a href="#检查dist目录是否有构建出来的文件" class="headerlink" title="检查dist目录是否有构建出来的文件"></a>检查dist目录是否有构建出来的文件</h3><p>使用mocha编写单元测试的测试用例，安装： <code>npm i mocha -D</code></p>
<p><code>npm i glob-all -D</code></p>
<p>新建smoke/html-test.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob-all'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'checking generated html files'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should genarate html files'</span>, (done) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> files = glob.sync([<span class="string">'./dist/index.html'</span>, <span class="string">'./dist/search.html'</span>]);</span><br><span class="line">    <span class="keyword">if</span>(files.length &gt; <span class="number">0</span>) done();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'no html files genarated'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>新建smoke/css-js-test.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob-all'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'checking generated css js files'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should genarate css js files'</span>, (done) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> files = glob.sync([<span class="string">'./dist/index_*.js'</span>, <span class="string">'./dist/search_*.js'</span>, <span class="string">'./dist/index_*.css'</span>, <span class="string">'./dist/search_*.css'</span>]);</span><br><span class="line">    <span class="keyword">if</span>(files.length &gt; <span class="number">0</span>) done();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'no css js files genarated'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>修改smoke/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /...</span></span><br><span class="line"><span class="keyword">const</span> Mocha = <span class="built_in">require</span>(<span class="string">'mocha'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mocha = <span class="keyword">new</span> Mocha(&#123;</span><br><span class="line">  timeout: <span class="string">'10000ms'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 每次构建之前，删除dist目录</span></span><br><span class="line">rimraf(<span class="string">'./dist'</span>, () =&gt; &#123;</span><br><span class="line">  webpack(prodConfig, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'webpack build success, begin run test'</span>);</span><br><span class="line">    mocha.addFile(path.join(__dirname, <span class="string">'html-test.js'</span>));</span><br><span class="line">    mocha.addFile(path.join(__dirname, <span class="string">'css-js-test.js'</span>));</span><br><span class="line">    mocha.run();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在终端运行：<code>node test/smoke/index.js</code>，冒烟测试成功之后会在终端打印</p>
<p><img src="/img/webpack/w19.png" alt="图片"></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>使用抹茶和断言库进行单元测试</p>
<p>安装断言库：<code>npm i assert -D</code></p>
<p>在test目录新建index文件，作为单元测试的入口，在test目录新建unit目录，这个目录放单元测试的代码</p>
<p>测试webpack.base配置，test/unit/webpack-base-test.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/unit/webpack-base-test.js</span></span><br><span class="line">describe(<span class="string">'webpack.base.js test case'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'../../lib/webpack.base'</span>);</span><br><span class="line">  <span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line">  <span class="comment">// console.log(baseConfig)</span></span><br><span class="line">  <span class="comment">// 测试entry字段</span></span><br><span class="line">  it(<span class="string">'entry'</span>, () =&gt; &#123;</span><br><span class="line">    assert.equal(baseConfig.entry.index, <span class="string">'/Users/lizhaoxin/mypro/webpack-first/build-webpack/test/smoke/template/src/index/index.jsx'</span>);</span><br><span class="line">    assert.equal(baseConfig.entry.search, <span class="string">'/Users/lizhaoxin/mypro/webpack-first/build-webpack/test/smoke/template/src/search/index.jsx'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>test/index：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入tamplate, __dirname代表运行时候的目录</span></span><br><span class="line">process.chdir(path.join(__dirname, <span class="string">'smoke/template'</span>));</span><br><span class="line"><span class="comment">// 引入测试代码</span></span><br><span class="line">describe(<span class="string">'builder-webpack test case'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./unit/webpack-base-test'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>修改build-webpack/package.json，增加test运行脚本</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "./node_modules/.bin/_mocha",</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run test:测试用例成功了，会在前面打勾</p>
<p><img src="/img/webpack/w20.png" alt="图片"></p>
<p>测试覆盖率， istanbul是一个单元测试代码覆盖率检查工具，可以很直观地告诉我们，单元测试对代码的控制程度。，安装 npm i istanbul -D, 修改build-webpack/package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "istanbul cover ./node_modules/.bin/_mocha",</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run build,可以在终端看到，测试用例的覆盖情况,例如单元测试覆盖了多少函数，多少代码行数，多少分支：</p>
<p><img src="/img/webpack/w21.png" alt="图片"></p>
<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建速度、体积分析和优化</title>
    <url>/2020/06/16/webpack-optimize/</url>
    <content><![CDATA[<p><img src="/img/webpack/36.png" alt="图片"></p>
<h2 id="初级分析：构建体积和速度"><a href="#初级分析：构建体积和速度" class="headerlink" title="初级分析：构建体积和速度"></a>初级分析：构建体积和速度</h2><p>基本的分析可以使用webpack内置的stats进行构建的统计分析，例如总共消耗的时间和每个构建资源的大小，使用方法就是在根目录的package.json方法里面添加运行脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build:stats": "webpack --config webpack.prod.js --json &gt; stats.json"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run build:stats会在根目录生成一个stats.json文件，里面包含构建资源的信息，是否构架成功，大致用了多少时间构建，但是这个分析只是作为一个基础的分析，颗粒度泰国粗糙</p>
<h2 id="精细分析：构建速度分析"><a href="#精细分析：构建速度分析" class="headerlink" title="精细分析：构建速度分析"></a>精细分析：构建速度分析</h2><p>借助speed-measure-webpack-plugin 插件分析详细的构建速度，可以清晰的看到每个loader和plugin的耗时情况</p>
<p>安装：<code>npm i speed-measure-webpack-plugin -D</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> SpeedMeasireWebpackPlugin = <span class="built_in">require</span>(<span class="string">'speed-measure-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasireWebpackPlugin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在终端运行npm run build，结果：</p>
<p><img src="/img/webpack/w22.png" alt="图片"></p>
<p>速度正常的会用绿色显示，速度稍慢的会用黄色表示，速度很慢需要重点关注的会用红色表示，然后可以做一下调整的优化方便的工作</p>
<h2 id="构建体积的分析"><a href="#构建体积的分析" class="headerlink" title="构建体积的分析"></a>构建体积的分析</h2><p>借助webpack-bundle-analyzer可以分析构建体积</p>
<p>安装：<code>npm install webpack-bundle-analyzer -D</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 会在浏览器自动打开一个<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a> 页面，页面里面展示的是构建包的体积大小，可以针对性的找出是哪个包的体积大，还是某个组件的体积太大，针对性的作出处理</p>
<h2 id="高版本的webpack"><a href="#高版本的webpack" class="headerlink" title="高版本的webpack"></a>高版本的webpack</h2><p><img src="/img/webpack/w23.png" alt="图片"></p>
<h2 id="多进程-多实例构建"><a href="#多进程-多实例构建" class="headerlink" title="多进程/多实例构建"></a>多进程/多实例构建</h2><p>使用happypack实现多进程：安装<code>npm i happypack -D</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        <span class="comment">// use: ['babel-loader', 'eslint-loader']</span></span><br><span class="line">        use: [<span class="string">'happypack/loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      loaders: [<span class="string">'babel-loader'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>先看一下没有使用happypack前的构建速度,3726ms</p>
<p><img src="/img/webpack/w24.png" alt="图片"></p>
<p>使用了happypack之后的构建速度：</p>
<p><img src="/img/webpack/w24.png" alt="图片"></p>
<p>可以看到happy默认启用了三个线程构建，构建速度2605ms，速度的提升还是很明显的</p>
<p>再看一下使用webpack提供的thread-loader实现多进程的构建，安装： <code>npm i thread-loader -D</code>,</p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>, &#123;<span class="attr">loader</span>: <span class="string">'thread-loader'</span>, <span class="attr">options</span>: &#123;<span class="attr">workers</span>: <span class="number">3</span>&#125;&#125;]</span><br><span class="line">        <span class="comment">// use: ['happypack/loader']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// new HappyPack(&#123;</span></span><br><span class="line">    <span class="comment">//   loaders: ['babel-loader']</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在终端查看构建速度，2122ms</p>
<p><img src="/img/webpack/26.png" alt="图片"></p>
<h2 id="多进程并行压缩"><a href="#多进程并行压缩" class="headerlink" title="多进程并行压缩"></a>多进程并行压缩</h2><p>在webpack推荐使用TerserPlugin，安装：<code>npm install terser-webpack-plugin --save-dev</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="literal">true</span></span><br><span class="line">    &#125;)]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>添加并行压缩前后构建时间对比：</p>
<p><img src="/img/webpack/27.png" alt="图片"></p>
<p><img src="/img/webpack/28.png" alt="图片"></p>
<h2 id="分包-预编译资源模块"><a href="#分包-预编译资源模块" class="headerlink" title="分包-预编译资源模块"></a>分包-预编译资源模块</h2><p>前面使用的HtmlWebpackExternalsPlugin，可以把一些静态资源通过cdn的方式引入，以减少构建包的体积，那么如果这种静态引入的包越多，就需要每个配置，然后在模版页面每个引入</p>
<p>可以使用DLLPlugin可以对多个组件或者框架哭进行提取</p>
<p>根目录新建webpack.dll.js配置文件，配置dll预编译的配置:先给目前使用的react相关的进行分包预编译配置，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    library: [</span><br><span class="line">      <span class="string">'react'</span>, <span class="string">'react-dom'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash].dll.js'</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">'build/library'</span>),</span><br><span class="line">    library: <span class="string">'[name]'</span></span><br><span class="line">  &#125;, </span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">      path: path.join(__dirname, <span class="string">'build/library/[name].json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根目录的的package.json增加dll命令脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "dll": "webpack --config webpack.dll.js"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run dll，会在根目录生成一个build文件夹，里面是预编译的react代码，同时会生成一个json文件，包含预编译代码的信息，</p>
<p>然后在webpack.prod.js中引用预编译的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: <span class="string">'./build/library/library.json'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h2 id="利用缓存提升二次构建的速度"><a href="#利用缓存提升二次构建的速度" class="headerlink" title="利用缓存提升二次构建的速度"></a>利用缓存提升二次构建的速度</h2><p>缓存对二次构建速度有用，先看一下没有开启缓存之前的构建速度：</p>
<p><img src="/img/webpack/29.png" alt="图片"></p>
<p>目前的项目比较小，构建一下大概2秒多一点</p>
<h3 id="babel-loader开启转换缓存"><a href="#babel-loader开启转换缓存" class="headerlink" title="babel-loader开启转换缓存"></a>babel-loader开启转换缓存</h3><p>babel转换js的语法缓存，在缓存之后下一次再构建的时候就可以直接使用缓存好的转换结果，从而提升转换的速度，开启babel-loader缓存的方法很简单，在webpack.prod.js文件中给babel-loader加一个开启缓存的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader?cacheDirectory=true'</span>, &#123;<span class="attr">loader</span>: <span class="string">'thread-loader'</span>, <span class="attr">options</span>: &#123;<span class="attr">workers</span>: <span class="number">3</span>&#125;&#125;]</span><br><span class="line">        <span class="comment">// use: ['happypack/loader']</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>加好缓存之后，运行一次npm run build，这次build会生成缓存，在node_modules问价夹下生成一个.cache文件夹，里面存放的是缓存资源</p>
<p><img src="/img/webpack/30.png" alt="图片"></p>
<p>然后，第二次执行npm run build，因为使用了缓存，速度的提升还是有的，只不过因为项目太小了，不是很明显</p>
<p><img src="/img/webpack/31.png" alt="图片"></p>
<h3 id="terser开启压缩缓存"><a href="#terser开启压缩缓存" class="headerlink" title="terser开启压缩缓存"></a>terser开启压缩缓存</h3><p>开启压缩缓存提升压缩速度，也是很简单，在webpack.prod.js中开启terser的缓存参数就好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      cache: <span class="literal">true</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>开启压缩缓存之后，第一次运行npm run build:</p>
<p><img src="/img/webpack/32.png" alt="图片"></p>
<p>再一次运行npm run build:</p>
<p><img src="/img/webpack/33.png" alt="图片"></p>
<h3 id="针对模块的缓存"><a href="#针对模块的缓存" class="headerlink" title="针对模块的缓存"></a>针对模块的缓存</h3><p>HardSourceWebpackPlugin为模块提供中间缓存，使用方法：</p>
<p>安装：<code>npm install --save-dev hard-source-webpack-plugin</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HardSourceWebpackPlugin = <span class="built_in">require</span>(<span class="string">'hard-source-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>配置好之后，第一次运行npm run build，可以看到这个插件在写入缓存</p>
<p><img src="/img/webpack/34.png" alt="图片"></p>
<p>第二次运行之后，可以看到插件提示使用了1M的缓存，速度也是有了明显的提升</p>
<p><img src="/img/webpack/35.png" alt="图片"></p>
<h2 id="缩小构建体积"><a href="#缩小构建体积" class="headerlink" title="缩小构建体积"></a>缩小构建体积</h2><p>webpack自带的配置也可以用来缩小构建体积，例如配置模块查找字段resolve,include,exclude等字段</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">'src'</span>),</span><br><span class="line">        use: [<span class="string">'babel-loader?cacheDirectory=true'</span>, &#123;<span class="attr">loader</span>: <span class="string">'thread-loader'</span>, <span class="attr">options</span>: &#123;<span class="attr">workers</span>: <span class="number">3</span>&#125;&#125;]</span><br><span class="line">        <span class="comment">// use: ['happypack/loader']</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react/umd/react.production.min.js'</span>),</span><br><span class="line">      <span class="string">'react-dom'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react-dom/umd/react-dom.production.min.js'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>],</span><br><span class="line">    mainFields: [<span class="string">'main'</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h2 id="tree-shaking清除无用的代码"><a href="#tree-shaking清除无用的代码" class="headerlink" title="tree shaking清除无用的代码"></a>tree shaking清除无用的代码</h2><p>purgecss-webpack-plugin擦除无用的css，安装： <code>npm i purgecss-webpack-plugin -D</code></p>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> purgecssWebpackplugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PATHS = &#123;</span><br><span class="line">  src: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    <span class="keyword">new</span> purgecssWebpackplugin(&#123;</span><br><span class="line">      paths: glob.sync(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>,  &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>写一行没有用到的css，运行npm run build，样式并没有被打包到bundle文件中去</p>
<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>安装loader: <code>npm install image-webpack-loader --save-dev</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            mozjpeg: &#123;</span><br><span class="line">              progressive: <span class="literal">true</span>,</span><br><span class="line">              quality: <span class="number">65</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">            optipng: &#123;</span><br><span class="line">              enabled: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            pngquant: &#123;</span><br><span class="line">              quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">              speed: <span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            gifsicle: &#123;</span><br><span class="line">              interlaced: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// the webp option will enable WEBP</span></span><br><span class="line">            webp: &#123;</span><br><span class="line">              quality: <span class="number">75</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h2 id="动态polyfill"><a href="#动态polyfill" class="headerlink" title="动态polyfill"></a>动态polyfill</h2><p>polyfill可以垫平不同浏览器之间的差异，但是有些浏览器版本较高，对于es6的语法支持很好，依然还是会使用polyfill，其实这些高版本的浏览器都是不需要的，所有会造成浪费，动态polyfill会判断当前浏览器的内核以及版本，动态的返回这个浏览器所需要的代码，从而提升速度</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个Promise，了解Promise核心原理</title>
    <url>/2019/10/23/my-promise/</url>
    <content><![CDATA[<p>使用promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一段耗时的异步操作</span></span><br><span class="line">    resolve(<span class="string">'成功'</span>) <span class="comment">// 数据处理完成</span></span><br><span class="line">    <span class="comment">// reject('失败') // 数据处理出错</span></span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  (res) =&gt; &#123;<span class="built_in">console</span>.log(res)&#125;,  <span class="comment">// 成功</span></span><br><span class="line">  (err) =&gt; &#123;<span class="built_in">console</span>.log(err)&#125; <span class="comment">// 失败</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这是最简单的使用promise，我的目的就是使用自己写的MyPromise替换原生的Promise</p>
<h2 id="定义整体的结构"><a href="#定义整体的结构" class="headerlink" title="定义整体的结构"></a>定义整体的结构</h2><h3 id="第一步-先写出构造函数，将Promise向外暴露"><a href="#第一步-先写出构造函数，将Promise向外暴露" class="headerlink" title="第一步,先写出构造函数，将Promise向外暴露"></a>第一步,先写出构造函数，将Promise向外暴露</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise构造函数</span></span><br><span class="line"><span class="comment">  executor:执行器函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露Promise</span></span><br><span class="line">  <span class="built_in">window</span>.MyPromise = <span class="built_in">Promise</span>;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h3 id="添加Promise原型对象上的方法"><a href="#添加Promise原型对象上的方法" class="headerlink" title="添加Promise原型对象上的方法"></a>添加Promise原型对象上的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Promise原型对象的then</span></span><br><span class="line"><span class="comment">    指定一个成功/失败的回调函数</span></span><br><span class="line"><span class="comment">    返回一个新的promise对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Promise原型对象的.catch</span></span><br><span class="line"><span class="comment">    指定一个失败的回调函数</span></span><br><span class="line"><span class="comment">    返回一个新的promise对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加Promise函数对象上的方法"><a href="#添加Promise函数对象上的方法" class="headerlink" title="添加Promise函数对象上的方法"></a>添加Promise函数对象上的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的resovle方法</span></span><br><span class="line"><span class="comment">  返回一个指定结果的promise对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的reject方法</span></span><br><span class="line"><span class="comment">  返回一个指定reason的失败状态的promise对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的all方法</span></span><br><span class="line"><span class="comment">  返回一个promise对象，只有当所有promise都成功时返回的promise状态才成功</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的race方法</span></span><br><span class="line"><span class="comment">  返回一个promise对象，状态由第一个完成的promise决定</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise构造函数"><a href="#实现Promise构造函数" class="headerlink" title="实现Promise构造函数"></a>实现Promise构造函数</h2><p>首先看一下，平时是如何使用Promise的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 一段耗时的异步操作</span></span><br><span class="line">    resolve(<span class="string">'resolve'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promiseA.then(</span><br><span class="line">  (res) =&gt; &#123;<span class="built_in">console</span>.log(res)&#125;,  <span class="comment">// 成功</span></span><br><span class="line">  (err) =&gt; &#123;<span class="built_in">console</span>.log(err)&#125; <span class="comment">// 失败</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>通过new实例化一个Promise对象，Promise构造函数接受一个函数参数，这个函数可以叫做executor（执行器函数），执行器函数会被被立即执行，这个执行器函数接受两个函数作为参数：resolve和reject，执行器函数内部会立即执行resolve和reject，resolve和reject函数是Promise内部函数，需要逐步实现这两个函数，先声明resolve和reject函数，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise构造函数</span></span><br><span class="line"><span class="comment">  executor:执行器函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resovle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即同步执行executor</span></span><br><span class="line">    executor(resovle,reject)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露Promise</span></span><br><span class="line">  <span class="built_in">window</span>.MyPromise = <span class="built_in">Promise</span>;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>然后程序运行到promiseA.then()，首先知道一个知识点Promise有三个状态：</p>
<ol>
<li>pending[待定]初始状态</li>
<li>fulfilled[实现]操作成功</li>
<li>rejected[被否决]操作失败</li>
</ol>
<p>并且promise状态一经改变，不会再变。只能改变一次，需要声明一个status变量表示当前状态，并且每一个Promise都有一个data值用来存储数据结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise构造函数</span></span><br><span class="line"><span class="comment">  executor:执行器函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = <span class="string">'pending'</span> <span class="comment">// 给promise对象指定status属性，初始值为pending</span></span><br><span class="line">    self.data = <span class="literal">undefined</span> <span class="comment">// 给promise对象指定一个存储结果的data</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resovle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即同步执行executor</span></span><br><span class="line">    executor(resovle,reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露Promise</span></span><br><span class="line">  <span class="built_in">window</span>.MyPromise = <span class="built_in">Promise</span>;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>当程序运行到promiseA.then()的时候，从代码可以看出来，then函数接受两个函数参数，当Promise状态为fulfilled的时候执行第一个参数函数，状态为rejected的时候执行第二个函数参数，</p>
<p>但是当程序运行到promiseA.then()的时候，有可能所以promise的状态还是pending，这时要把then里面的回调函数保存起来，所以需要个callbacks数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise构造函数</span></span><br><span class="line"><span class="comment">  executor:执行器函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = <span class="string">'pending'</span> <span class="comment">// 给promise对象指定status属性，初始值为pending</span></span><br><span class="line">    self.data = <span class="literal">undefined</span> <span class="comment">// 给promise对象指定一个存储结果的data</span></span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    self.callbacks = []  <span class="comment">// 每个元素的结构：&#123;onResolved()&#123;&#125;，onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resovle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即同步执行executor</span></span><br><span class="line">    executor(resovle,reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露Promise</span></span><br><span class="line">  <span class="built_in">window</span>.MyPromise = <span class="built_in">Promise</span>;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>resolve和reject函数，resolve函数执行callbacks里的函数，并保存data，并将当前promise状态改为resolved。reject函数也是这个道理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise构造函数</span></span><br><span class="line"><span class="comment">  executor:执行器函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = <span class="string">'pending'</span> <span class="comment">// 给promise对象指定status属性，初始值为pending</span></span><br><span class="line">    self.data = <span class="literal">undefined</span> <span class="comment">// 给promise对象指定一个存储结果的data</span></span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    self.callbacks = []  <span class="comment">// 每个元素的结构：&#123;onResolved()&#123;&#125;，onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resovle</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前状态不是pending，则不执行</span></span><br><span class="line">      <span class="keyword">if</span>(self.status !== <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将状态改为resolved</span></span><br><span class="line">      self.status = <span class="string">'resolved'</span>;</span><br><span class="line">      <span class="comment">// 保存value的值</span></span><br><span class="line">      self.data = value</span><br><span class="line">      <span class="comment">// 如果有待执行的callback函数，立即异步执行回调函数onResolved</span></span><br><span class="line">      <span class="keyword">if</span> (self.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">callbackObj</span>=&gt;</span>&#123;</span><br><span class="line">          callbackObj.onResolved(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前状态不是pending，则不执行</span></span><br><span class="line">      <span class="keyword">if</span>(self.status !== <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将状态改为rejected</span></span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      <span class="comment">// 保存value的值</span></span><br><span class="line">      self.data = value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果有待执行的callback函数，立即异步执行回调函数onResolved</span></span><br><span class="line">      <span class="keyword">if</span> (self.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">callbackObj</span>=&gt;</span>&#123;</span><br><span class="line">            callbackObj.onRejected(value);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即同步执行executor</span></span><br><span class="line">    executor(resovle,reject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露Promise</span></span><br><span class="line">  <span class="built_in">window</span>.MyPromise = <span class="built_in">Promise</span>;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>try catch函数捕获executor执行器函数运行异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise构造函数</span></span><br><span class="line"><span class="comment">  executor:执行器函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = <span class="string">'pending'</span> <span class="comment">// 给promise对象指定status属性，初始值为pending</span></span><br><span class="line">    self.data = <span class="literal">undefined</span> <span class="comment">// 给promise对象指定一个存储结果的data</span></span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    self.callbacks = []  <span class="comment">// 每个元素的结构：&#123;onResolved()&#123;&#125;，onRejected()&#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resovle</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前状态不是pending，则不执行</span></span><br><span class="line">      <span class="keyword">if</span>(self.status !== <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将状态改为resolved</span></span><br><span class="line">      self.status = <span class="string">'resolved'</span>;</span><br><span class="line">      <span class="comment">// 保存value的值</span></span><br><span class="line">      self.data = value</span><br><span class="line">      <span class="comment">// 如果有待执行的callback函数，立即异步执行回调函数onResolved</span></span><br><span class="line">      <span class="keyword">if</span> (self.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">callbackObj</span>=&gt;</span>&#123;</span><br><span class="line">          callbackObj.onResolved(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果当前状态不是pending，则不执行</span></span><br><span class="line">      <span class="keyword">if</span>(self.status !== <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将状态改为rejected</span></span><br><span class="line">      self.status = <span class="string">'rejected'</span>;</span><br><span class="line">      <span class="comment">// 保存value的值</span></span><br><span class="line">      self.data = value;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果有待执行的callback函数，立即异步执行回调函数onResolved</span></span><br><span class="line">      <span class="keyword">if</span> (self.callbacks.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        self.callbacks.forEach(<span class="function"><span class="params">callbackObj</span>=&gt;</span>&#123;</span><br><span class="line">            callbackObj.onRejected(value);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 立即同步执行executor</span></span><br><span class="line">      executor(resolve,reject);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e) &#123; <span class="comment">// 如果执行器抛出异常，promise对象变为rejected状态</span></span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向外暴露Promise</span></span><br><span class="line">  <span class="built_in">window</span>.MyPromise = <span class="built_in">Promise</span>;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h2 id="实现then方法"><a href="#实现then方法" class="headerlink" title="实现then方法"></a>实现then方法</h2><p>Promise.then接受两个参数onResolved,onRejected，分别在Promise状态为pending和rejected的时候执行，当Promise状态是pending的时候，会把onResolved和onRejected函数push进之前声明的callbacks数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">      self.callbacks.push(&#123;</span><br><span class="line">          onResolved()&#123;onResolved(self.data)&#125;,</span><br><span class="line">          onRejected()&#123;onRejected(self.data)&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当Promise状态是resolved或者rejected状态，此时就不用把回调保存起来，直接执行onResolved或onRejected方法。注意是异步执行。而且是做为微任务的，这里我们简单的用setTimeout来实现就好了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">      self.callbacks.push(&#123;</span><br><span class="line">          onResolved()&#123;onResolved(self.data)&#125;,</span><br><span class="line">          onRejected()&#123;onRejected(self.data)&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      onResolved(self.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      onResolved(self.data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完then是要返回一个新的promise的，而新的promise的状态则由当前then的执行结果来确定。所以先来return一个新的Promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">      self.callbacks.push(&#123;</span><br><span class="line">          onResolved()&#123;onResolved(self.data)&#125;,</span><br><span class="line">          onRejected()&#123;onRejected(self.data)&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line">      <span class="comment">// 新增代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        onResolved(self.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 新增代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        onResolved(self.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Promise有一个优点：链式调用，如下代码里面的：<code>promise.then().then()</code>，在创建Promise的时候，执行到第一个then函数，由于then函数里面也会返回一个Promise，所以创建的第一个Promise就称他为当前Promise，当前的Promise状态为resolved的时候，会运行到then函数里面的<code>else if(self.status === &#39;resolved&#39;)</code>语句，然后会执行<code>onResolved(self.data)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  </span><br><span class="line">).then(</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当then的回调函数返回的不是promise，那么then函数中return的新promise的状态是则是resolved，value就是返回的值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  value=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> value <span class="comment">//返回的不是promise，是value</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>所以then函数可以这样子写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">      self.callbacks.push(&#123;</span><br><span class="line">          onResolved()&#123;onResolved(self.data)&#125;,</span><br><span class="line">          onRejected()&#123;onRejected(self.data)&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line">      <span class="comment">// 新增代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = onResolved(self.data);</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 1. 如果回调函数返回的不是promise，return的promise的状态是resolved，value就是返回的值。</span></span><br><span class="line">          <span class="comment">// resolve函数将当前新的promise的状态改为resolved，同时将value保存到当前新的promise的data中。</span></span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 新增代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        onResolved(self.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当then的回调函数返回的是promise，then函数中return的promise的结果就是这个promise的结果，如下代码所示，then函数的回调函数返回一个新的promise。如果这个promise执行了resolve，then函数中返回的新的promise的状态则是resolved的。否则为rejected</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">    value=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            resolve(<span class="number">2</span>)</span><br><span class="line">            <span class="comment">//或者</span></span><br><span class="line">            <span class="comment">//reject(error)</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>所以then函数可以这样子写，try catch来实现如果执行then回调函数这段代码的时候抛出错误，则返回的promise的状态为rejected，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">      self.callbacks.push(&#123;</span><br><span class="line">          onResolved()&#123;onResolved(self.data)&#125;,</span><br><span class="line">          onRejected()&#123;onRejected(self.data)&#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line">      <span class="comment">// 新增代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">const</span> result = onResolved(self.data);</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">            <span class="comment">// 2. 如果回调函数返回的是promise，return的promise的结果就是这个promise的结果</span></span><br><span class="line">            result.then(</span><br><span class="line">              value =&gt; &#123;resolve(value)&#125;,</span><br><span class="line">              reason =&gt; &#123;reject(reason)&#125;</span><br><span class="line">            )</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 如果回调函数返回的不是promise，return的promise的状态是resolved，value就是返回的值。</span></span><br><span class="line">            <span class="comment">// resolve函数将当前新的promise的状态改为resolved，同时将value保存到当前新的promise的data中。</span></span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="comment">//  3.如果执行onResolved的时候抛出错误，则返回的promise的状态为rejected</span></span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 新增代码</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        onResolved(self.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的第一个Promise就称他为当前Promise，当前的Promise状态为rejected的时候，道理和状态为resolved的时候一样，所以代码也是一样的，<br>可以封装一下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    调用指定回调函数的处理，根据执行结果。改变return的promise状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = callback(self.data)</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">          <span class="comment">// 2. 如果回调函数返回的是promise，return的promise的结果就是这个promise的结果</span></span><br><span class="line">          result.then(</span><br><span class="line">            value =&gt; &#123;resolve(value)&#125;,</span><br><span class="line">            reason =&gt; &#123;reject(reason)&#125;</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 1. 如果回调函数返回的不是promise，return的promise的状态是resolved，value就是返回的值。</span></span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">//  3.如果执行onResolved的时候抛出错误，则返回的promise的状态为rejected</span></span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">      <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">      self.callbacks.push(&#123;</span><br><span class="line">        onResolved()&#123;</span><br><span class="line">          handle(onResolved);</span><br><span class="line">        &#125;,</span><br><span class="line">        onRejected()&#123;onRejected(self.data)&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        handle(onResolved);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        handle(onRejected);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>promise会发生值传透，所以最终的then函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise原型对象的then</span></span><br><span class="line"><span class="comment">  指定一个成功/失败的回调函数</span></span><br><span class="line"><span class="comment">  返回一个新的promise对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当then中传入的不算函数，则这个then返回的promise的data，将会保存上一个的promise.data。这就是发生值穿透的原因。而且每一个无效的then所返回的promise的状态都为resolved。</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span>? onResolved: <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span>? onRejected: <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      调用指定回调函数的处理，根据执行结果。改变return的promise状态</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="keyword">const</span> result = callback(self.data)</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">            <span class="comment">// 2. 如果回调函数返回的是promise，return的promise的结果就是这个promise的结果</span></span><br><span class="line">            result.then(</span><br><span class="line">              value =&gt; &#123;resolve(value)&#125;,</span><br><span class="line">              reason =&gt; &#123;reject(reason)&#125;</span><br><span class="line">            )</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 如果回调函数返回的不是promise，return的promise的状态是resolved，value就是返回的值。</span></span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="comment">//  3.如果执行onResolved的时候抛出错误，则返回的promise的状态为rejected</span></span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(self.status === <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="comment">// promise当前状态还是pending状态，将回调函数保存起来</span></span><br><span class="line">        self.callbacks.push(&#123;</span><br><span class="line">          onResolved()&#123;</span><br><span class="line">            handle(onResolved);</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected()&#123;onRejected(self.data)&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === <span class="string">'resolved'</span>)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          handle(onResolved);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          handle(onRejected);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现catch方法"><a href="#实现catch方法" class="headerlink" title="实现catch方法"></a>实现catch方法</h2><p>catch方法的作用跟then里的第二个回调函数一样，因此我们可以这样来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise原型对象的.catch</span></span><br><span class="line"><span class="comment">  指定一个失败的回调函数</span></span><br><span class="line"><span class="comment">  返回一个新的promise对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>,onRejected)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-resolve"><a href="#实现Promise-resolve" class="headerlink" title="实现Promise.resolve"></a>实现Promise.resolve</h2><p>Promise.resolve方法可以传三种值</p>
<ol>
<li>不是promise</li>
<li>成功状态的promise</li>
<li>失败状态的promise</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.reject(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>具体的实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的resovle方法</span></span><br><span class="line"><span class="comment">  返回一个指定结果的promise对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果value 是promise</span></span><br><span class="line">        value.then(</span><br><span class="line">            value =&gt; &#123;resolve(value)&#125;,</span><br><span class="line">            reason =&gt; &#123;reject(reason)&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果value不是promise</span></span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-reject"><a href="#实现Promise-reject" class="headerlink" title="实现Promise.reject"></a>实现Promise.reject</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的reject方法</span></span><br><span class="line"><span class="comment">  返回一个指定reason的失败状态的promise对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all"></a>实现Promise.all</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的all方法</span></span><br><span class="line"><span class="comment">  返回一个promise对象，只有当所有promise都成功时返回的promise状态才成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length)</span><br><span class="line">  <span class="keyword">var</span> resolvedCount = <span class="number">0</span> <span class="comment">//计状态为resolved的promise的数量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历promises，获取每个promise的结果</span></span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">p,index</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">        value =&gt; &#123;</span><br><span class="line">          <span class="comment">// p状态为resolved，将值保存起来</span></span><br><span class="line">          values[index] = value</span><br><span class="line">          resolvedCount++;</span><br><span class="line">          <span class="comment">// 如果全部p都为resolved状态，return的promise状态为resolved</span></span><br><span class="line">          <span class="keyword">if</span>(resolvedCount === promises.length)&#123;</span><br><span class="line">            resolve(values)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        reason =&gt; &#123; <span class="comment">//只要有一个失败，return的promise状态就为reject</span></span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      )    </span><br><span class="line">    &#125;)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Promise-race"><a href="#实现Promise-race" class="headerlink" title="实现Promise.race"></a>实现Promise.race</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Promise函数对象的race方法</span></span><br><span class="line"><span class="comment">  返回一个promise对象，状态由第一个完成的promise决定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历promises，获取每个promise的结果</span></span><br><span class="line">    promises.forEach(<span class="function">(<span class="params">p,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">            value =&gt; &#123;</span><br><span class="line">                <span class="comment">// 只要有一个成功，返回的promise的状态九尾resolved</span></span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;,</span><br><span class="line">            reason =&gt; &#123; <span class="comment">//只要有一个失败，return的promise状态就为reject</span></span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-进阶配置</title>
    <url>/2020/05/27/webpack-advanced/</url>
    <content><![CDATA[<h2 id="每次构建之前首先自动删除dist目录"><a href="#每次构建之前首先自动删除dist目录" class="headerlink" title="每次构建之前首先自动删除dist目录"></a>每次构建之前首先自动删除dist目录</h2><p>在学习基础配置的时候，给webpack配置添加了文件指纹来做文件的版本管理，如果某个文件有改动，就会生成新的构建文件，故此会在一次次的构建过程中dist目录会留下很多版本的文件，所有每次构建之前不得不手动删除dist目录，很是麻烦</p>
<p>webpack提供了一个插件，可以在每次构建之前首先自动删除dist目录：clean-webpack-plugin插件</p>
<p>首先安装一下：<code>npm i clean-webpack-plugin -D</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>之后运行npm run build，webpack都会先删除dist，在构建</p>
<p>loader是有严格的顺序的，plugin的顺序要求并不严格，不放心的可以把CleanWebpackPlugin插件放在plugin数组的第一个</p>
<h2 id="自动补全css3前缀"><a href="#自动补全css3前缀" class="headerlink" title="自动补全css3前缀"></a>自动补全css3前缀</h2><p>有时候为了使用最新的css样式，需要为不同的浏览器手动的补齐带有各自浏览器内核的前缀，webpack提供的postcss-loader和autoprefixer插件，可以设置为不同的浏览器自动补齐前缀</p>
<p>安装： <code>npm i postcss-loader autoprefixer -D</code></p>
<p>然后在webpack.prod.js中配置：找到.less的loader配置，添加一个postcss-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在src/index.less样式文件中写一个比较新的样式来进行测试</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/index.less */</span></span><br><span class="line">@base: #f938ab;</span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: @base;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，查看dist/index.css-loader自动添加了浏览器前缀：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dist/index.less */</span></span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">color</span>:<span class="number">#f938ab</span>;<span class="attribute">display</span>:-webkit-box;<span class="attribute">display</span>:-webkit-flex;<span class="attribute">display</span>:-ms-flexbox;<span class="attribute">display</span>:flex&#125;</span><br></pre></td></tr></table></figure>
<p>postcss-loader要求在css-loader之前执行，所有在数组中的顺序必须要放在css-loader之后，否则运行会报错</p>
<h2 id="自动转换px为rem"><a href="#自动转换px为rem" class="headerlink" title="自动转换px为rem"></a>自动转换px为rem</h2><p>为了兼容移动设备不同屏幕的分辨率，适配页面，可以使用rem这个单位来编写样式，webpack提供了px2rem-loader这个loader可以帮助px转换为rem单位</p>
<p>借助手淘的一个lib-flexible库，可以在页面渲染时动态计算出跟元素的font-size值</p>
<p>安装：<code>npm i px2rem-loader -D</code></p>
<p>安装：<code>npm i lib-flexible -S</code></p>
<p>在webpack.prod.js中添加配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            remUnit: <span class="number">75</span>, <span class="comment">// 转换率：1rem = 75px</span></span><br><span class="line">            remPrecision: <span class="number">8</span> <span class="comment">// 转换之后保留小数点后位数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在src/index.less样式文件中写一个宽度的样式来进行测试</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/index.less */</span></span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，查看dist/index.less，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dist/index.less */</span></span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">width</span>:<span class="number">6.66666667rem</span>&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以看到px已经被转换成rem单位，然后还需要根据不同的屏幕尺寸，设定不同的跟元素字体，这个就需要使用已经安装好的lib-flexible，</p>
<p>lib-flexible是一个比较稳定的库，属于静态资源，所有现在要学习一下如何把静态资源内联进构建目录</p>
<h2 id="静态资源内联"><a href="#静态资源内联" class="headerlink" title="静态资源内联"></a>静态资源内联</h2><p><img src="/img/webpack/w12.png" alt="图片"></p>
<h3 id="html和js内联"><a href="#html和js内联" class="headerlink" title="html和js内联"></a>html和js内联</h3><p>使用raw-loader</p>
<p><code>npm i raw-loader@0.5.1 -D</code></p>
<h2 id="多页面应用打包"><a href="#多页面应用打包" class="headerlink" title="多页面应用打包"></a>多页面应用打包</h2><p>每次增加一个新的页面入口的时候，都需要手动的修改webpack 的配置文件，修改entry字段，增加入口配置，修改plugin里面的HtmlWebpackPlugin配置，因为每个html入口文件对应一个HtmlWebpackPlugin，这样子及其不方便，</p>
<p>推荐使用glob这个库，通过约定文件目录，glob可以动态找到要配置的入口文件，借助这个可以动态生成entry，和HtmlWebpackPlugin数组，而不需要在每次添加一个entry的时候都去手动的修改webpack配置。</p>
<p>首先来整理一下目录：有两个entry，分别是index.js和search.js，在src下新建一个index文件夹，把之前在src下的index.js和index.less移动到index文件夹下面，在index文件夹下新建一个index.html作为index.js生成html文件的模版文件，可以直接从原来的public/index.html复制过来，新建一个src/search文件夹，在这个文件夹下新建模版文件index.html，入口文件index.js，index.less样式文件，</p>
<p>最后的文件目录：</p>
<p><img src="/img/webpack/w13.png" alt="图片"></p>
<p>安装glob: <code>npm i glob -D</code></p>
<p>修改webpack.prod.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置entry 和 htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index.js'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.js/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = entryFile;</span><br><span class="line">    htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        chunks: [pageName],</span><br><span class="line">        inject: <span class="literal">true</span>,</span><br><span class="line">        minify: &#123;</span><br><span class="line">          html5: <span class="literal">true</span>,</span><br><span class="line">          preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          minifyCSS: <span class="literal">true</span>,</span><br><span class="line">          minifyJS: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlWebpackPlugin&#125; = setMPA();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ...htmlWebpackPlugin,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>再次运行npm run build，查看dist目录，可以检测效果，假如以后要增加一个entry，只需要按照约定新建目录，即可，无需修改webpack配置文件</p>
<p>同样到配置代码，复制一份到webpack.dev.js中</p>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">JavaScript Source Map 详解</a></p>
<h2 id="提取页面公共资源"><a href="#提取页面公共资源" class="headerlink" title="提取页面公共资源"></a>提取页面公共资源</h2><p>提取页面公共资源可以减少构建文件的体积</p>
<h3 id="基础库的分离"><a href="#基础库的分离" class="headerlink" title="基础库的分离"></a>基础库的分离</h3><p>使用html-webpack-externals-plugin，react\react-dom通过cdn引入，不打包进bundle中</p>
<p>安装：<code>npm i html-webpack-externals-plugin -D</code>，</p>
<p>在webpack.prod.js配置文件中使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react@16/umd/react.development.js'</span>,</span><br><span class="line">        global: <span class="string">'React'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react-dom@16/umd/react-dom.development.js'</span>,</span><br><span class="line">        global: <span class="string">'ReactDom'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>没有配置之前的构建文件先看一下，构建出来的js文件129k,</p>
<p><img src="/img/webpack/w14.png" alt="图片"></p>
<p>配置之后的构建文件，js文件10k不到，差别还是很明显的</p>
<p><img src="/img/webpack/w15.png" alt="图片"></p>
<p>最后分别在入口文件的模版html中引入react/react-dom：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/index/index.html --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- src/search/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- zhengwen --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="SplitChunksPlugin-基础包的分离"><a href="#SplitChunksPlugin-基础包的分离" class="headerlink" title="SplitChunksPlugin 基础包的分离"></a>SplitChunksPlugin 基础包的分离</h3><p>把react和react-dom进行单独的分离提取出来，叫vendors.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index.js'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.js/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = entryFile;</span><br><span class="line">    htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        chunks: [<span class="string">'vendors'</span>, pageName],</span><br><span class="line">        inject: <span class="literal">true</span>,</span><br><span class="line">        minify: &#123;</span><br><span class="line">          html5: <span class="literal">true</span>,</span><br><span class="line">          preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          minifyCSS: <span class="literal">true</span>,</span><br><span class="line">          minifyJS: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: <span class="regexp">/(react|react-dom)/</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 查看dist目录，构建出一个vendors.js文件，就是成功提取出的react和react-dom</p>
<h3 id="SplitChunksPlugin-分离页面公共的代码"><a href="#SplitChunksPlugin-分离页面公共的代码" class="headerlink" title="SplitChunksPlugin 分离页面公共的代码"></a>SplitChunksPlugin 分离页面公共的代码</h3><p>通过配置，把页面使用多次的代码提取出一个公共的文件，叫commons.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: <span class="number">0</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: <span class="string">'commons'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span> <span class="comment">// 最少使用次数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 查看dist目录，构建出一个commons.js文件，就是成功提取出的公共的代码</p>
<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><p>摇树优化，一个模块可能有多个方法，只要有其中一个方法被用到了，整个模块就会被打包到bundle里面去，tree shaking就是把用到的方法打包进去，多余的代码在uglify阶段就会被清除掉</p>
<p>删除无用代码的工作原理：</p>
<ul>
<li><p>不会执行到的代码，不会到达的代码</p>
</li>
<li><p>代码执行的结果不会被用到</p>
</li>
<li><p>代码只写不读</p>
</li>
</ul>
<p>tree shaking原理：利用es6模块的特点，import 、export都是出现在顶层，并且import进来的代码不可修改，tree shaking对模块的代码静态分析，在编译阶段分析哪些代码没有用到，对这些代码进行标记，在uglify阶段把它清除掉</p>
<p>在webpack config的配置文件中，设置<code>mode: &#39;production&#39;,</code>就会自动开始tree shaking</p>
<h2 id="scope-hoisting"><a href="#scope-hoisting" class="headerlink" title="scope hoisting"></a>scope hoisting</h2><p>对于每一个模块打包出来的文件都会有一个包裹的函数，模块数量越多，导致大量的函数闭包导致bundle的体积很大，而且打包的时候还增加内存的消耗</p>
<p>scope hoisting原理：将所有的模块按照引用的顺序包裹在一个函数里，适当的重命名变量防止变量冲突</p>
<p>在webpack config的配置文件中，设置<code>mode: &#39;production&#39;,</code>就会自动开始scope hoisting</p>
<h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><p>代码分割的适用场景：js懒加载，抽离相同的代码到一个共享模块</p>
<p>代码分割搭配动态import使用，动态import并不被原生的es6支持，需要安装一个babel-plugin-syntax-dynamic-import插件</p>
<p><code>npm install --save-dev @babel/plugin-syntax-dynamic-import</code></p>
<p>在.babelrc文件中配置，引入这个插件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  // ..</span><br><span class="line">  "plugins": ["@babel/plugin-syntax-dynamic-import"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个动态加载的js函数，在组建中使用这个函数，动态import返回的是一个promise对象：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./testSync'</span>).then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(text.default);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在动态加载的时候使用jsonp的形式加载动态加载的js文件</p>
<h2 id="使用ESLint"><a href="#使用ESLint" class="headerlink" title="使用ESLint"></a>使用ESLint</h2><p>安装eslint 一套 <code>npm i eslint eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-import -D</code></p>
<p>安装eslint-loader: <code>npm i eslint-loader -D</code></p>
<p>安装babel-eslint:<code>npm i babel-eslint -D</code></p>
<p>安装：<code>npm i eslint-config-airbnb -D</code></p>
<p>在根目录新建.eslintrc.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"node"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行构建</p>
<h2 id="webpack打包库和组件"><a href="#webpack打包库和组件" class="headerlink" title="webpack打包库和组件"></a>webpack打包库和组件</h2><p>新建项目根目录 large-number，进入项目目录,<code>npm init -y</code>初始化package.json</p>
<p>安装webpack，webpack-cli:<code>npm i webpack webpack-cli -D</code></p>
<p>在根目录新建src/index.js，写一个库函数，例如大数相加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="comment">// 大整数相加</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = a.length - <span class="number">1</span>; <span class="comment">// 从个位开始相加</span></span><br><span class="line">  <span class="keyword">let</span> j = b.length - <span class="number">1</span>; <span class="comment">// b的个位数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        x = a[i] - <span class="number">0</span>;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        y = b[j] - <span class="number">0</span>;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; </span><br><span class="line">      sum = x + y + carry;</span><br><span class="line">      <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        carry = <span class="number">1</span>;</span><br><span class="line">        sum = sum - <span class="number">10</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = sum + ret;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(carry) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret = carry + ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add('9999', '666');</span></span><br></pre></td></tr></table></figure>
<p>写好之后，在根目录新建webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>); <span class="comment">//npm i terser-webpack-plugin -D</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'none'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'large-number'</span>: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    <span class="string">'large-number.min'</span>: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    library: <span class="string">'largeNumber'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    libraryExport: <span class="string">'default'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(</span><br><span class="line">        &#123;<span class="attr">include</span>: <span class="regexp">/\.min\.js$/</span>&#125;</span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改packagr.json，增加build命令和prepublish</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack",</span><br><span class="line">    "prepublish": "webpack" // 发布的时候使用</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>在根目录新建index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV = <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./dist/large-number.min.js'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./dist/large-number.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>npm login登陆npm账号</p>
<p>npm publish发布组件到npm库</p>
<h2 id="SSR打包"><a href="#SSR打包" class="headerlink" title="SSR打包"></a>SSR打包</h2><p>SSR指的是在服务端渲染页面然后返回给前端浏览器做显示</p>
<p>根目录新建server目录，新建server/index.js，编写服务端渲染的代码逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  global.window = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; renderToString &#125; = <span class="built_in">require</span>(<span class="string">'react-dom/server'</span>);</span><br><span class="line"><span class="keyword">const</span> SSR = <span class="built_in">require</span>(<span class="string">'../dist/search-server.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="function">(<span class="params">port</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = express();</span><br><span class="line">  app.use(express.static(<span class="string">'dist'</span>));</span><br><span class="line">  app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> html = renderMarkup(renderToString(SSR));</span><br><span class="line">    res.status(<span class="number">200</span>).send(html);</span><br><span class="line">  &#125;);</span><br><span class="line">  app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server is running on port:'</span> + port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server(process.env.PORT || <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderMarkup = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">  &lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="root"&gt;<span class="subst">$&#123;str&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根目录新建webpack.ssr.js文件，编写服务端打包的webpack配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置entry 和 htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index-server.jsx'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index-server\.jsx/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(entryFile)</span><br><span class="line">    <span class="keyword">if</span>(pageName) &#123;</span><br><span class="line">      entry[pageName] = entryFile;</span><br><span class="line">      htmlWebpackPlugin.push(</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">          filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">          chunks: [<span class="string">'vendors'</span>, pageName],</span><br><span class="line">          inject: <span class="literal">true</span>,</span><br><span class="line">          minify: &#123;</span><br><span class="line">            html5: <span class="literal">true</span>,</span><br><span class="line">            preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">            removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlWebpackPlugin&#125; = setMPA();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]-server.js'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>, <span class="string">'eslint-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            remUnit: <span class="number">75</span>, <span class="comment">// 转换率：1rem = 75px</span></span><br><span class="line">            remPrecision: <span class="number">8</span> <span class="comment">// 转换之后保留小数点后位数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ...htmlWebpackPlugin,</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: <span class="regexp">/(react|react-dom)/</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>安装：<code>npm i express -D</code></p>
<p>新建src/search/index-server.js，编写一个服务端渲染页面的页面代码，注意使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      ssr test</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = &lt;Index /</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>运行npm run build查看dist目录</p>
<h3 id="使用打包出来的浏览器端的html文件作为，模版可以显示样式"><a href="#使用打包出来的浏览器端的html文件作为，模版可以显示样式" class="headerlink" title="使用打包出来的浏览器端的html文件作为，模版可以显示样式"></a>使用打包出来的浏览器端的html文件作为，模版可以显示样式</h3><p>修改server/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = fs.readFileSync(path.join(__dirname, <span class="string">'../dist/search.html'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderMarkup = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 打包好的模版里面会有注释的占位符，然后用服务端渲染好的代码替换注释</span></span><br><span class="line">  <span class="keyword">return</span> template.replace(<span class="string">'&lt;!--HTML_PLACEHOLDER--&gt;'</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改search/index.html模版文件，添加一个占位符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="comment">&lt;!--HTML_PLACEHOLDER--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="服务端获取数据"><a href="#服务端获取数据" class="headerlink" title="服务端获取数据"></a>服务端获取数据</h3><p>新建server/data.json</p>
<p>修改search/index.html模版文件，添加一个数据占位符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--INITIAL_DATA_PLACEHOLDER--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改server/index.js加载数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="built_in">require</span>(<span class="string">'./data.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderMarkup = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dataStr = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="keyword">return</span> template.replace(<span class="string">'&lt;!--HTML_PLACEHOLDER--&gt;'</span>, str).replace(<span class="string">'&lt;!--INITIAL_DATA_PLACEHOLDER--&gt;'</span>, <span class="string">`&lt;script&gt;window.__initial_data=<span class="subst">$&#123;dataStr&#125;</span>&lt;/script&gt;`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把数据加载到页面，后续就可以使用数据渲染页面</p>
<h2 id="构建时候命令行的日志展示优化"><a href="#构建时候命令行的日志展示优化" class="headerlink" title="构建时候命令行的日志展示优化"></a>构建时候命令行的日志展示优化</h2><p>在webpack.config.js设置stats字段</p>
<p>stats预设值：</p>
<p><img src="/img/webpack/w16.png" alt="图片"></p>
<h3 id="Friendly-errors-webpack-plugin"><a href="#Friendly-errors-webpack-plugin" class="headerlink" title="Friendly-errors-webpack-plugin"></a>Friendly-errors-webpack-plugin</h3><p>Friendly-errors-webpack-plugin识别某些类别的webpack错误，并清理，聚合和优先级，以提供更好的开发人员体验。</p>
<p>安装：<code>npm install friendly-errors-webpack-plugin --save-dev</code></p>
<p>安装好了之后，在webpack.prod.js和webpack.dev.js中分别引入，并使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FriendlyErrorsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> FriendlyErrorsWebpackPlugin()</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>
<p>之后在运行npm run build活着npm run dev的时候，在构建成功会用绿色提示，并显示构建所需要的时间，有警告的时候会使用黄色的提示，编译报错的时候使用红色的颜色标记</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack配置-基础配置</title>
    <url>/2020/05/13/webpack-start/</url>
    <content><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>新建空的目录webpack-first</p>
<p>初始化package.json文件：进入webpack-first文件夹运行 <code>npm init -y</code>命令</p>
<p>在项目内安装webpack：命令行运行 <code>npm install webpack webpack-cli --save-dev</code></p>
<p>新建src目录，在src目录下新建index.js文件</p>
<p>安装完成，打印一下webpack版本：命令行执行<code>./node_modules/.bin/webpack</code>命令</p>
<p><img src="/img/webpack/w1.png" alt="打印webpack版本"></p>
<h2 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h2><p>webpack的配置文件是在根目录下webpack.config.js文件里面配置</p>
<p>webpack的配置主要配置的是：</p>
<ol>
<li><p>基础功能：入口，出口文件配置</p>
</li>
<li><p>转换器loader</p>
</li>
<li><p>插件plugins</p>
</li>
</ol>
<p>在根目录新建webpack.config.js这个文件，简单配置一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'boundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在src新建helloWorld文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/helloWorld.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js引入helloWorld</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; helloWorld &#125; <span class="keyword">from</span> <span class="string">'./helloWorld'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(helloWorld());</span><br></pre></td></tr></table></figure>
<p>运行 <code>./node_modules/.bin/webpack</code>，不添加任何参数就是不指定配置文件，打包结果会在根目录下面的dist目录生成一个boundle.js文件</p>
<h3 id="每次运行-node-modules-bin-webpack一长串太麻烦了"><a href="#每次运行-node-modules-bin-webpack一长串太麻烦了" class="headerlink" title="每次运行./node_modules/.bin/webpack一长串太麻烦了"></a>每次运行<code>./node_modules/.bin/webpack</code>一长串太麻烦了</h3><p>./node_modules/.bin/目录下存放的是该项目所有依赖的软连接，所有需要从./node_modules/.bin/目录启动webpack来打包项目，实际上呢package.json文件可以默认读取到./node_modules/.bin/目录下的命令，在package.json增加一个scripts配置，执行build命令的时候会去./node_modules/.bin/目录下寻找webpack命令，然后执行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-first"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以直接执行<code>npm run build</code>打包项目了</p>
<h2 id="简单了解webpack核心概念"><a href="#简单了解webpack核心概念" class="headerlink" title="简单了解webpack核心概念"></a>简单了解webpack核心概念</h2><h3 id="entry指定打包的入口"><a href="#entry指定打包的入口" class="headerlink" title="entry指定打包的入口"></a>entry指定打包的入口</h3><p>webpack是模块打包器，一切皆模块，不仅是代码模块，图片、字体、文本都会当成一个个模块，模块之间的依赖关系根据入口文件entry寻找，生成一颗依赖树，在打包的过程中如果发现依赖关系，就把文件加入依赖树中，最终生成打包后的资源</p>
<p>单入口的entry是一个字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: <span class="string">'./src/index.js'</span>,</span><br></pre></td></tr></table></figure>
<p>多入口的entry是一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  pc: <span class="string">'./src/pc.js'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="output指定webpack编译打包后的文件如何输出到磁盘"><a href="#output指定webpack编译打包后的文件如何输出到磁盘" class="headerlink" title="output指定webpack编译打包后的文件如何输出到磁盘"></a>output指定webpack编译打包后的文件如何输出到磁盘</h3><p>单入口对应单个的output配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">''</span>,</span><br><span class="line">  path: <span class="string">''</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>多入口对应多个output配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  path: <span class="string">''</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="尝试多入口配置"><a href="#尝试多入口配置" class="headerlink" title="尝试多入口配置"></a>尝试多入口配置</h3><p>在src目录下新建一个login.js文件作为另外一个入口文件，随便写点什么可执行的代码进去</p>
<p>然后修改webpack.config.js这个文件，修改entry字段和output字段以配置多入口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    login: <span class="string">'./src/login.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>, <span class="comment">// 使用占位符为每个入口打包之后的文件命名</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行<code>rm -rf dist/</code>删除dist目录下已经生成的打包文件，再次执行npm run build 会发现dist目录下面新生成了两个文件：index.js,login.js</p>
<h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p>对于webpack不能解析的文件（es6,7以及更高版本，less文件，image文件等）通过loaders先转换一下</p>
<p>基本用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.txt$/</span>, <span class="comment">// 匹配规则</span></span><br><span class="line">        use: <span class="string">'css-loader'</span> <span class="comment">// 要使用的loader</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>用于优化打包出来的文件，资源管理和环境变量的注入，作用于整个构建过程</p>
<h3 id="mode-webpack4新提出的概念"><a href="#mode-webpack4新提出的概念" class="headerlink" title="mode  webpack4新提出的概念"></a>mode  webpack4新提出的概念</h3><p>指定当前的构建环境：production（默认），development，none</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td>设置process.env.NODE_ENV设置为development，开启 NamedChunksPlugin和NamedModulesPlugin</td>
<td>NamedChunksPlugin：把chunk id变为一个字符串标识符。NamedModulesPlugin：当开启 HMR 的时候使用该插件会显示模块的相对路径，建议用于开发环境。</td>
</tr>
<tr>
<td>production</td>
<td>设置process.env.NODE_ENV设置为production，开启 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin</td>
<td>启用生产环境适用的插件，比如代码压缩，去注释等</td>
</tr>
</tbody>
</table>
<h2 id="了解webpack基础用法"><a href="#了解webpack基础用法" class="headerlink" title="了解webpack基础用法"></a>了解webpack基础用法</h2><h3 id="在浏览器中查看页面"><a href="#在浏览器中查看页面" class="headerlink" title="在浏览器中查看页面"></a>在浏览器中查看页面</h3><p>为了查看webpack基础用法配置之后的页面，需要 html 文件，可以使用 html-webpack-plugin 插件来帮助。</p>
<p>首先安装一下：<code>npm install html-webpack-plugin -D</code></p>
<p>新建 public 目录，并在其中新建一个 index.html 文件( 文件内容使用 html:5 快捷生成即可)</p>
<p>修改 webpack.config.js 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先引入插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">                collapseWhitespace: <span class="literal">false</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// hash: true //是否加上hash，默认是 false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行npm run build，dist目录下新生成一个index.html的文件，打开dist目录，双击在浏览器打开这个文件，可以看到页面内显示的hello world文本</p>
<h3 id="Babel-loader-解析es6和jsx"><a href="#Babel-loader-解析es6和jsx" class="headerlink" title="Babel-loader 解析es6和jsx"></a>Babel-loader 解析es6和jsx</h3><h4 id="babel如何解析es语法"><a href="#babel如何解析es语法" class="headerlink" title="babel如何解析es语法"></a>babel如何解析es语法</h4><p>首先安装：<code>npm i @babel/core @babel/preset-env babel-loader -D</code></p>
<p>Babel-loader执行依赖Babel的配置文件.babelrc，在根目录新建.babelrc文件，写入代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>] <span class="comment">//预设一组es6的插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改webpack.config.js这个文件，增加babel-sloader的配置，手动设置一下<code>mode: &#39;development&#39;</code>，一会打包的时候可以看到打包出来的代码不会被压缩</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>测试一下：打开之前新建的src/login文件，修改代码：特意使用es6的箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/login</span></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'login page'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行npm run build可以看到在dist目录下构建出的login.js里面的函数被转换成普通的function函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dist/login.js代码片段</span></span><br><span class="line"><span class="comment">/***/</span> <span class="string">"./src/login.js"</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/login.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/*! no static exports found */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var login = function login() &#123;\n  console.log('login page');\n&#125;;\n\n//# sourceURL=webpack:///./src/login.js?"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Babel如何转换jsx或者vuex语法"><a href="#Babel如何转换jsx或者vuex语法" class="headerlink" title="Babel如何转换jsx或者vuex语法"></a>Babel如何转换jsx或者vuex语法</h4><p>为了测试babel解析jsx语法，首先安装一下react以及要解析jsx所需要的的babel/preset-react：<code>npm i react react-dom @babel/preset-react -D</code></p>
<p>安装完成在.babelrc文件增加preset-react配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [..., <span class="string">"@babel/preset-react"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了测试效果，修改src/index.js文件的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> reactdom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world react<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reactdom.render(<span class="xml"><span class="tag">&lt;<span class="name">Index</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure>
<p>在public/index.html新增target节点 id=”root”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 新增 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行npm run build，在浏览器刷新index.html页面，发现网页显示的文本变成hello world react</p>
<h3 id="解析css"><a href="#解析css" class="headerlink" title="解析css"></a>解析css</h3><h4 id="css-loader用于加载-css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中"><a href="#css-loader用于加载-css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中" class="headerlink" title="css-loader用于加载.css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中"></a>css-loader用于加载.css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中</h4><p>首先安装css-loader，style-loader: <code>npm i style-loader css-loader -D</code></p>
<p>新建src/index.css文件，写入样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在index.js文件中引入这个样式，并且修改react组件使用这个样式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">"text"</span>&gt;</span>hello world react<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最后不要忘了在webpack.config.js文件配置css-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>注意loader的解析是链式解析，总右往左，所以上面的loader的执行顺序是先使用css-loader解析css，然后将解析好的文件传递给style-loader再进行下一步的工作</p>
<p>运行npm run build，在浏览器刷新index.html，可以看到文字变成了粉色</p>
<h4 id="如何使用less-loader和sass-loader"><a href="#如何使用less-loader和sass-loader" class="headerlink" title="如何使用less-loader和sass-loader"></a>如何使用less-loader和sass-loader</h4><p>less-loader和sass-loader的使用和css-loader的使用方法类似，以下以less为例，less-loader就是将less.css转换成css，</p>
<p>首先安装less 和 less-loader：<code>npm i less less-loader -D</code></p>
<p>修改刚才的index.css文件后缀名为index.less，并写点简单的样式：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.less</span></span><br><span class="line"><span class="variable">@base:</span> <span class="number">#f938ab</span>;</span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@base</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js中引入index.less</p>
<p>在webpack.config.js文件配置less-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在浏览器刷新index.html，可以看到文字变成新设置的颜色</p>
<h3 id="解析图片和字体资源"><a href="#解析图片和字体资源" class="headerlink" title="解析图片和字体资源"></a>解析图片和字体资源</h3><h4 id="file-loader解析图片文件"><a href="#file-loader解析图片文件" class="headerlink" title="file-loader解析图片文件"></a>file-loader解析图片文件</h4><p>使用<code>file-loader</code>解析文件资源，首先安装一下:<code>npm i file-loader -D</code>，安装完成之后，在src下新建一个img文件夹，用来存放图片资源，照一张漂亮的图片放进img文件夹</p>
<p>在index.js中引用这张图片：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xiaozhan <span class="keyword">from</span> <span class="string">'./img/zhanzhan.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">      &lt;img src=&#123;xiaozhan&#125; /&gt;</span><br><span class="line">    &lt;/&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在webpack.config.js文件配置file-loader，匹配一些常用的图片文件后缀</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在浏览器刷新index.html，可以看到页面增加了一个图片文件</p>
<p><img src="/img/webpack/w3.png" alt="图片"></p>
<h4 id="file-loader解析字体"><a href="#file-loader解析字体" class="headerlink" title="file-loader解析字体"></a>file-loader解析字体</h4><p>字体文件的解析与图片文件一样可以使用file-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h4 id="解析图片和字体文件也可以使用url-loader"><a href="#解析图片和字体文件也可以使用url-loader" class="headerlink" title="解析图片和字体文件也可以使用url-loader"></a>解析图片和字体文件也可以使用url-loader</h4><p>url-loader可以较小资源自动base64转换，看一下使用的效果</p>
<p>首先安装：<code>npm i url-loader -D</code></p>
<p>然后修改webpack.config.js的配置，把file-loader替换成url-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10240</span>, <span class="comment">// 图片小于10k，webpack在打包的时候会自动用base64转换</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>找一个小于10k的图片测试一下，首先看一下使用file-loader打包的文件，dist目录下打包出来了图片文件，index.js是848k，图片文件6.9k</p>
<p><img src="/img/webpack/w4.png" alt="图片"></p>
<p>然后删除掉dist目录，使用url-loader的配置再打包一次，</p>
<p><img src="/img/webpack/w5.png" alt="图片"></p>
<p>可以看到，dist目录下打包出来的文件并没有图片文件，而index.js文件变成了857k，因为图片使用base64转行进去了，刷新页面，看到的页面和刚才一样的</p>
<h3 id="webpack中文件的监听"><a href="#webpack中文件的监听" class="headerlink" title="webpack中文件的监听"></a>webpack中文件的监听</h3><p>刚才一系列操作，每次做点什么代码上的改动都要手动build，手动刷新页面，极其不方便</p>
<p>文件的监听就是在发现源代码发生变化的时候，自动重新构建出新的输出文件</p>
<p>webpack中开启监听有两种方式：</p>
<ul>
<li>启动webpack命令时带上 –watch参数，在package.json增加一个scripts配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack",</span><br><span class="line">    "watch": "webpack --watch"</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改了之后，在命令行输入 npm run watch，命令行提示 ：webpack is watching the files…</p>
<p><img src="/img/webpack/w6.png" alt="图片"></p>
<p>然后随便做点修改，保存，webpack就会监听到文件发生了变化，就会重新构建出新的输出文件，并在命令行生成一个记录</p>
<p><img src="/img/webpack/w7.png" alt="图片"></p>
<p>这个时候在手动刷新一些浏览器，可以看到浏览器显示了修改之后的效果，这个方法的缺陷就是还是需要手动刷新浏览器</p>
<ul>
<li>webpack.config.js中配置watch: true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  watch: <span class="literal">true</span>, <span class="comment">//默认false</span></span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>, <span class="comment">//不监听的文件夹，支持正则匹配</span></span><br><span class="line">    aggregateTimeout: <span class="number">300</span>, <span class="comment">//监听到发生变化后等待300秒再去执行</span></span><br><span class="line">    poll: <span class="number">1000</span> <span class="comment">//每秒询问1000次文件是否发生变化</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>watch: true原理：轮询判断文件的最后编辑时间是否发生变化，设置了aggregate: 300,，检测到某个文件发生了变化，不会立即执行，而是先缓存起来，等待300秒之后再去执行，如果在此期间其他的文件也发生了变化，会一起打包</p>
<p>在命令行运行npm run build，wabpack会进入监听模式。这个方法的缺陷也是需要手动刷新浏览器，所以就需要热更新</p>
<h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>webpack-dev-server配合HotModuleReplacementPlugin插件一起使用，以达到热更新的目的</p>
<p>webpack-dev-server：不刷新浏览器，不输入文件，而是放在内存中，构建速度有一定的优势</p>
<p>安装： <code>npm install webpack-dev-server</code></p>
<p>在package.json文件增加一个scripts配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack",</span><br><span class="line">    "watch": "webpack --watch",</span><br><span class="line">    "dev": "webpack-dev-server --open"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>webpack-dev-server在开发过程中是不需要使用的，所以修改webpack.config.js文件中的mode配置为development，然后引入webpack内置插件：HotModuleReplacementPlugin插件，同时设置devServer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 服务基础目录</span></span><br><span class="line">    hot: <span class="literal">true</span> <span class="comment">// 开启热更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>设置好了之后在命令行运行npm run dev，webpack会自动在浏览器打开页面，尝试修改，浏览器也会自动刷新修改后的内容</p>
<p>另外一种热更新的方式webpack-dev-middleWare</p>
<h4 id="webpack-dev-middleWare"><a href="#webpack-dev-middleWare" class="headerlink" title="webpack-dev-middleWare"></a>webpack-dev-middleWare</h4><p>webpack-dev-middleWare将输出的文件传送给服务器</p>
<h4 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h4><p><img src="/img/webpack/w8.png" alt="图片"></p>
<p>热更新的过程</p>
<ol>
<li><p>启动阶段，在文件系统里把文件用webpack compile进行编译，把编译好的文件传输给bundle server,bundle server让打包出来的文件以server的方式浏览器能够访问的到，</p>
</li>
<li><p>如果源代码文件发生了修改，会再次用webpack compile进行编译，编译完成后将代码发送给HMR Server，HMR Server就会知道哪些模块发生了改变，然后通知HMR Runtime哪些文件发生了变化，HMR Runtime负责更新代码，以达到不刷新浏览器改变代码的目的</p>
</li>
</ol>
<h3 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h3><p>打包后输出文件的后缀，做文件的版本的管理，在发布版本的时候，可以只更新有改动的文件，对于没有修改的文件，可以继续使用浏览器的缓存</p>
<p><img src="/img/webpack/w9.png" alt="图片"></p>
<p>由于在开发换进和生产环境可能需要不同的webpack配置，例如热更新只需要在开发环境使用，而文件指纹hash是在开发环境支持的，所有需要区分一下生产环境和开发环境的webpack配置，做法就是首先把之前的webpack.config.js改成webpack.dev.js作为开发环境的配置使用，然后新建名为webpack.prod.js文件，作为开发环境的配置使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    login: <span class="string">'./src/login.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10240</span>, <span class="comment">// 图片小于10k，webpack在打包的时候会自动用base64转换</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// use: 'file-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">        filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">            collapseWhitespace: <span class="literal">false</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// hash: true //是否加上hash，默认是 false</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>接着修改package.json，指定开发环境使用webpack.dev.js，生产环境使用webpack.prod.js</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// package.json</span><br><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack --config webpack.prod.js",</span><br><span class="line">    "watch": "webpack --watch",</span><br><span class="line">    "dev": "webpack-dev-server --config webpack.dev.js --open"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h4 id="JS文件指纹的设置"><a href="#JS文件指纹的设置" class="headerlink" title="JS文件指纹的设置"></a>JS文件指纹的设置</h4><p>使用ChunkHash，通过设置output的filename哈希值，因为文件指纹是在生产环境使用的，所有在webpack.prod.js配置里面修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 可以看到dist目录下构建出的js文件带有后缀名hash</p>
<p><img src="/img/webpack/w10.png" alt="图片"></p>
<p>在src/index.js中修改一点文字，再次运行npm run build ，查看dist目录，文件夹里有两个构建出来的index.js文件带有不同的hash后缀，其中一个就是第二次构建的新文件</p>
<p><img src="/img/webpack/w11.png" alt="图片"></p>
<h4 id="图片、其他文件指纹设置"><a href="#图片、其他文件指纹设置" class="headerlink" title="图片、其他文件指纹设置"></a>图片、其他文件指纹设置</h4><p>使用hash，图片使用file-loader的option配置添加指纹</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>添加好之后，运行npm run build，查看dist目录，可以看到构建出的图片文件添加了hash后缀</p>
<h4 id="css文件指纹，使用contentHash"><a href="#css文件指纹，使用contentHash" class="headerlink" title="css文件指纹，使用contentHash"></a>css文件指纹，使用contentHash</h4><p>前面提到解析css文件使用的style-loader的作用是将样式通过style标签插入到head中，css文件并没有被提构建成一个独立的文件的，所以目前是不能为css文件添加指纹</p>
<p>那么就需要借助MiniCssExtractPlugin这个插件来帮助在构建的时候把css文件提取成一个文件，并添加指纹</p>
<p>首先安装一下： <code>npm i mini-css-extract-plugin -D</code></p>
<p>然后把插件添加到plugin的数组里去，删除style-loader，使用MiniCssExtractPlugin.loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build查看效果</p>
<h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><h4 id="js代码压缩"><a href="#js代码压缩" class="headerlink" title="js代码压缩"></a>js代码压缩</h4><p>使用uglifyjs-webpack-plugin，插件uglifyjs-webpack-plugin是webpack4内置的插件，所以正常build构建出的代码就是默认压缩的</p>
<h4 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h4><p>使用optimize-css-assets-webpack-plugin插件进行压缩，同时需要安装css预处理器cssnano</p>
<p>首先安装下：<code>npm i optimize-css-assets-webpack-plugin -D</code></p>
<p>安装css预处理器：<code>npm i cssnano -D</code></p>
<p>在webpack.prod.js中配置使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>测试效果，删除dist目录，执行npm run build，查看dist目录下构建的css文件</p>
<h4 id="html文件压缩"><a href="#html文件压缩" class="headerlink" title="html文件压缩"></a>html文件压缩</h4><p>前面用到的HtmlWebpackPlugin，可以设置压缩html的参数，压缩空格、换行符号、注释，一个页面对应一个HtmlWebpackPlugin，设置<code>collapseWhitespace: true</code>压缩空格和换行，removeComments: true删除注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">        filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            removeComments: <span class="literal">true</span>, <span class="comment">//删除注释</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// hash: true //是否加上hash，默认是 false</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在dist目录下找到对应的index.html文件检测效果</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
