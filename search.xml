<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客，换了电脑之后踩坑记录</title>
    <url>/2019/06/27/blogNote/</url>
    <content><![CDATA[<p>搭建参考教程：</p>
<ol>
<li><a href="https://www.jianshu.com/p/e99ed60390a8" target="_blank" rel="noopener">全民博客时代的到来——20 分钟简要教程</a></li>
<li><a href="https://www.jianshu.com/p/6fb0b287f950" target="_blank" rel="noopener">Hexo博客的跨设备同步</a></li>
</ol>
<p>换了电脑之后 hexo 配置都没有了</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>新建一个分支 hexo，管理 hexo 配置和主题文件，原来的 master 分支继续存放生成的静态页面即要发布的内容</p>
<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><ol>
<li>新建 hexo 分支，把 hexo 的配置和主题文件复制进去，然后执行：git add … git push ，push 到 hexo 分支</li>
<li>生成并发布到 master 执行：hexo g，然后 hexo d</li>
</ol>
<p>换电脑之后(windows)：</p>
<ol>
<li>先 clone 一下 hexo 分支的代码</li>
<li>安裝 npm install hexo-cli -g</li>
<li>安装 hexo npm install hexo</li>
<li>安装其他依赖 npm install</li>
<li>安装 hexo-deployer-git 执行命令：npm install hexo-deployer-git –save</li>
<li>安装 hexo server 命令：npm install hexo-server<br>npm install hexo-server –save</li>
<li>生成添加密钥: 执行命令 ssh-keygen -t rsa -C “Github 的注册邮箱地址”，一路回车，待秘钥生成完毕，会得到两个文件 id_rsa 和 id_rsa.pub，用带格式的记事本打开 id_rsa.pub，Ctrl + a 复制里面的所有内容，然后进入<a href="https://github.com/settings/keys，添加密钥" target="_blank" rel="noopener">https://github.com/settings/keys，添加密钥</a></li>
</ol>
<p>踩坑记录：</p>
<ul>
<li>执行 hexo s 启动本地服务，页面空白，有时候还一直转圈圈，网上百度，说是 hexo server 默认的端口号是 4000，这个端口号被占用了，依照网上的操作，hexo s -p 4001 切换端口号，还是没用</li>
</ul>
<p>使用了主题，比如 next ,在根目录执行：git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next，安装主题，否则不能生成静态目录</p>
<ul>
<li>又发现另外一个待解决的问题： 如果使用的主题皮肤，主题皮肤是另外一个仓库的，有自己的 git 配置，不能被我的 git 仓库管理，解决方法：<a href="https://juejin.im/post/5c2e22fcf265da615d72c596" target="_blank" rel="noopener">https://juejin.im/post/5c2e22fcf265da615d72c596</a></li>
</ul>
<ol>
<li><p>git submodule add <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>这个命令可以将外部的仓库作为当前项目的子模块添加进来</p>
</li>
<li><p>报错： ‘themes/next’ already exists in the index，原因是themes/next文件夹已经在git stage里面缓存了，执行git rm -r –cached theme/next命令从stage 移除该文件夹</p>
</li>
<li><p>继续添加子模块：  git submodule add <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</li>
<li><p>子模块添加成功后，根目录会出现一个 ：.gitmodules文件，这是一个配置文件，记录子模块</p>
</li>
<li><p>执行 git commit -m “添加皮肤主题next作为子模块”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[hexo 16896fd] 添加皮肤主题next作为子模块</span><br><span class="line">2 files changed, 4 insertions(+)</span><br><span class="line">create mode 100644 .gitmodules</span><br><span class="line">create mode 160000 themes/next</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>create mode 160000，表示themes/next 条目是160000，这在Git中是一个特殊模式意思是你将一根提交，记录为目录项，而不是子目录或者文件</p>
<h2 id="如果再换电脑（MAC）"><a href="#如果再换电脑（MAC）" class="headerlink" title="如果再换电脑（MAC）"></a>如果再换电脑（MAC）</h2><ul>
<li><p>使用git clone克隆整个仓库，然后themes/next存在，是空的</p>
</li>
<li><p>生成添加密钥: 执行命令 ssh-keygen -t rsa -C “Github 的注册邮箱地址”，一路回车，待秘钥生成完毕，会得到两个文件 id_rsa 和 id_rsa.pub，用带格式的记事本打开 id_rsa.pub，Ctrl + a 复制里面的所有内容，然后进入<a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a></p>
</li>
<li><p>执行git submodule init命令来初始化本地的配置文件</p>
</li>
<li><p>git submodule update来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交</p>
</li>
<li><p>安裝 npm install hexo-cli -g</p>
</li>
<li><p>尝试执行 hexo s,启动服务</p>
</li>
</ul>
<h3 id="其他错误处理"><a href="#其他错误处理" class="headerlink" title="其他错误处理"></a>其他错误处理</h3><p><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">全局安装软件包时解决EACCES权限错误</a></p>
<h2 id="如果皮肤的作者有更新"><a href="#如果皮肤的作者有更新" class="headerlink" title="如果皮肤的作者有更新"></a>如果皮肤的作者有更新</h2>]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>不容错过的 Babel7 知识</title>
    <url>/2020/03/31/babel-7start/</url>
    <content><![CDATA[<p>博客原文地址：<a href="https://juejin.im/post/5ddff3abe51d4502d56bd143" target="_blank" rel="noopener">不容错过的 Babel7 知识</a></p>
<p>简单了解Babel</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Babel 是一个 JS 编译器。</p>
<p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<h2 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h2><ul>
<li><p>语法转换</p>
</li>
<li><p>通过 Polyfill 方式在目标环境中添加缺失的特性(@babel/polyfill模块)</p>
</li>
<li><p>源码转换(codemods)</p>
</li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="核心库-babel-core"><a href="#核心库-babel-core" class="headerlink" title="核心库 @babel/core"></a>核心库 @babel/core</h3><p>不安装 @babel/core，无法使用 babel 进行编译。</p>
<p>npm install –save-dev @babel/core</p>
<h3 id="CLI命令行工具-babel-cli"><a href="#CLI命令行工具-babel-cli" class="headerlink" title="CLI命令行工具 @babel/cli"></a>CLI命令行工具 @babel/cli</h3><p>babel 提供的命令行工具，主要是提供 babel 这个命令，适合安装在项目里。</p>
<p>@babel/node 提供了 babel-node 命令，但是 @babel/node 更适合全局安装，不适合安装在项目里。</p>
<p>npm install –save-dev @babel/cli</p>
<p>将命令配置在 package.json 文件的 scripts 字段中:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "compiler": "babel src --out-dir lib --watch"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>配置在.babelrc文件中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">    "plugins": ["@babel/plugin-transform-arrow-functions"], //插件发布在 npm 上，可以直接填写插件的名称，</span><br><span class="line">    "plugins": ["./node_modules/@babel/plugin-transform-arrow-functions"], //也可以指定插件的相对/绝对路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预设"><a href="#预设" class="headerlink" title="预设"></a>预设</h3><p>通过使用或创建一个 preset 即可轻松使用一组插件。</p>
<p>@babel/preset-env 主要作用是对我们所使用的并且目标浏览器中缺失的功能进行代码转换和加载 polyfill，在不进行任何配置的情况下，@babel/preset-env 所包含的插件将支持所有最新的JS特性(ES2015,ES2016等，不包含 stage 阶段)，将其转换成ES5代码。例如，如果你的代码中使用了可选链(目前，仍在 stage 阶段)，那么只配置 @babel/preset-env，转换时会抛出错误，需要另外安装相应的插件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h3><p>垫片就是垫平不同浏览器或者不同环境下的差异，让新的内置函数、实例方法等在低版本浏览器中也可以使用。</p>
<p>@babel/polyfill 模块包括 core-js 和一个自定义的 regenerator runtime 模块，可以模拟完整的 ES2015+ 环境（不包含第4阶段前的提议）。</p>
<p>安装 @babel/polyfill 依赖: npm install –save @babel/polyfill</p>
<p>注意：不使用 –save-dev，因为这是一个需要在源码之前运行的垫片。</p>
<p>我们需要将完整的 polyfill 在代码之前加载，</p>
<p>@babel/polyfill 需要在其它代码之前引入，我们也可以在 webpack 中进行配置。</p>
<p>例如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">entry: [</span><br><span class="line">    require.resolve('./polyfills'),</span><br><span class="line">    path.resolve('./index')</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>@babel/preset-env 提供了一个 useBuiltIns 参数，设置值为 usage 时，就只会包含代码需要的 polyfill 。有一点需要注意：配置此参数的值为 usage ，必须要同时设置 corejs (如果不设置，会给出警告，默认使用的是”corejs”: 2) ，注意: 这里仍然需要安装 @babel/polyfill(当前 @babel/polyfill 版本默认会安装 “corejs”: 2):</p>
<p>npm install –save core-js@3</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//.babelrcconst </span><br><span class="line">presets = [    [        "@babel/env",        &#123;               "useBuiltIns": "usage",            "corejs": 3        &#125;    ]]</span><br></pre></td></tr></table></figure>
<p>Babel 会检查所有代码，以便查找在目标环境中缺失的功能，然后仅仅把需要的 polyfill 包含进来。</p>
<p>Babel 会使用很小的辅助函数来实现类似 _createClass 等公共方法。默认情况下，它将被添加(inject)到需要它的每个文件中。</p>
<h3 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h3><p>@babel/plugin-transform-runtime 是一个可以重复使用 Babel 注入的帮助程序，以节省代码大小的插件。</p>
<p>@babel/plugin-transform-runtime 需要和 @babel/runtime 配合使用。</p>
<p>npm install –save-dev @babel/plugin-transform-runtime</p>
<p>npm install –save @babel/runtime</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123; <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>, &#123;<span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>, <span class="attr">"corejs"</span>: <span class="number">3</span>&#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [[<span class="string">"@babel/plugin-transform-runtime"</span>]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们希望 @babel/plugin-transform-runtime 不仅仅处理帮助函数，同时也能加载 polyfill 的话，我们需要给 @babel/plugin-transform-runtime 增加配置信息。</p>
<p>新增依赖 @babel/runtime-corejs3: npm install @babel/runtime-corejs3 –save</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>, &#123;<span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>, <span class="attr">"corejs"</span>: <span class="number">3</span>&#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [[<span class="string">"@babel/plugin-transform-runtime"</span>, &#123;<span class="attr">"corejs"</span>: <span class="number">3</span>&#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插件-预设补充知识"><a href="#插件-预设补充知识" class="headerlink" title="插件/预设补充知识"></a>插件/预设补充知识</h3><p>如果两个转换插件都将处理“程序（Program）”的某个代码片段，则将根据转换插件或 preset 的排列顺序依次执行。</p>
<ul>
<li><p>插件在 Presets 前运行。</p>
</li>
<li><p>插件顺序从前往后排列。</p>
</li>
<li><p>Preset 顺序是颠倒的（从后往前）。</p>
</li>
</ul>
<p>插件参数</p>
<p>插件和 preset 都可以接受参数，参数由插件名和参数对象组成一个数组。preset 设置参数也是这种格式。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Babel 支持多种格式的配置文件。</p>
<p>所有的 Babel API 参数都可以被配置，但是如果该参数需要使用的 JS 代码，那么可能需要使用 JS 代码版的配置文件。</p>
<p>如果希望以编程的方式创建配置文件或者希望编译 node_modules 目录下的模块：那么 babel.config.js 可以满足你的需求。</p>
<p>如果只是需要一个简单的并且中用于单个软件包的配置：那么 .babelrc 即可满足你的需求。</p>
]]></content>
      <tags>
        <tag>babel</tag>
        <tag>babel7</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作</title>
    <url>/2017/04/08/git-base/</url>
    <content><![CDATA[<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>新建分支：</p>
<p>git checkout -b [分支]<br>git push –set-upstream origin [分支]</p>
<p>删除本地分支：先切换到别的分支，然后git branch -d [分支]</p>
<p>删除远程分支 ：git push origin –delete [分支]</p>
<p>切换远程仓库的地址：git remote set-url oringin &lt;新的远程仓库URL&gt;</p>
<p>查看远程仓库的地址：git remote -v</p>
<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>git stash 将当前所有修改项(未提交的)暂存，压栈。此时代码回到你上一次的提交，用git status可查看状态。</p>
<p>git stash list将列出所有暂存项。</p>
<p>git stash clear 清除所有暂存项。</p>
<p>git stash apply 将暂存的修改重新应用，使用git status可以看到以前暂存的修改又回来了</p>
<p>git stash pop 弹出最后一个stash</p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>git log 查看提交日志</p>
<p>git reset HEAD^  撤回上一次的commit提交</p>
<p>git reset –hard [commit的版本id] ，回滚到某个版本的提交</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的事件循环和任务队列</title>
    <url>/2020/08/17/browser-tasks/</url>
    <content><![CDATA[<p>参考文档：</p>
<p><a href="https://segmentfault.com/a/1190000012748907" target="_blank" rel="noopener">浏览器中的事件循环机制</a></p>
<p><a href="https://segmentfault.com/a/1190000019059045?utm_source=tag-newest" target="_blank" rel="noopener">浏览器的微任务MicroTask和宏任务MacroTask</a></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>js在浏览器运行是单线程的，一般情况下浏览器会按顺序同步执行js代码，但是有些情况下需要延迟执行js代码</p>
<p>最常见的就是等待接口返回数据之后再去执行回调函数，不可能一直在那里等着接口有返回了再去执行后面的，这就是会阻塞后面js执行，请求接口是同步执行的，请求成功之后的回调是异步的，所以会先找一个地方把异步操作存起来，等其他的js执行完成了再去执行，这个存贮的地方就是浏览器的任务队列</p>
<h2 id="事件循环（event-loop）机制"><a href="#事件循环（event-loop）机制" class="headerlink" title="事件循环（event loop）机制"></a>事件循环（event loop）机制</h2><p>浏览器的事件循环机制，可以理解为任务队列的机制</p>
<h3 id="任务队列的分类"><a href="#任务队列的分类" class="headerlink" title="任务队列的分类"></a>任务队列的分类</h3><ul>
<li><p>同步任务（Task），即为立即执行的js代码队列</p>
</li>
<li><p>宏任务（macroTask），setTimeout、setInterval、I/O、UI渲染</p>
</li>
<li><p>微任务（microTask），promise、object.obsever、MutationObsever</p>
</li>
<li><p>用户交互事件，点击事件等</p>
</li>
</ul>
<h3 id="promise-与-setTimeout"><a href="#promise-与-setTimeout" class="headerlink" title="promise 与 setTimeout"></a>promise 与 setTimeout</h3><p>我们用的比较多的是这两个，先看一下这两个的执行顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span> + <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'before resolve'</span>);</span><br><span class="line">    resolve(<span class="string">'promise'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after resolve'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line">before resolve</span><br><span class="line">after resolve</span><br><span class="line">end</span><br><span class="line">promise</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>
<p>为什么‘promise’会比‘延迟任务’先打印出来，明明按照代码的编写顺序延迟任务setTimeout是先进入任务队列的，这就是因为promise进入的是微任务（microTask）队列，而延迟任务进入的是宏任务（macroTask）队列，从上可看出，微任务（microTask）队列是优先于宏任务（macroTask）队列执行的</p>
<p>执行顺序说明：</p>
<ol>
<li><p>test函数进入执行队列</p>
</li>
<li><p>执行同步任务，console.log(a)，同步任务都是立即执行的</p>
</li>
<li><p>setTimeout任务进入任务队列，没有立即执行，而是放在了宏任务（macroTask）队列</p>
</li>
<li><p>代码继续往下走，promise进入任务队列，new promise会立即执行传入的回调函数，resolve(‘promise)前后和它的两个console.log()，都是同步任务，所以会立即执行，执行到resolve(‘promise’);这一句，把promise.then()放入任务队列，这个是放入微任务（microTask）队列，</p>
</li>
<li><p>执行同步任务console.log(‘end’);</p>
</li>
<li><p>浏览器闲下来，优先查找微任务（microTask）队列，执行promise.then()，控制台打印console.log(value);</p>
</li>
<li><p>微任务（microTask）队列为空，查找宏任务（macroTask）队列，控制台打印console.log(“延迟任务”);</p>
</li>
</ol>
<h3 id="只要有-Microtasks-插入，就会不断执行-Microtasks-队列直到结束，在结束前都不会执行到-Tasks"><a href="#只要有-Microtasks-插入，就会不断执行-Microtasks-队列直到结束，在结束前都不会执行到-Tasks" class="headerlink" title="只要有 Microtasks 插入，就会不断执行 Microtasks 队列直到结束，在结束前都不会执行到 Tasks"></a>只要有 Microtasks 插入，就会不断执行 Microtasks 队列直到结束，在结束前都不会执行到 Tasks</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">".outer"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">".inner"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用。</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"检测到dom改变"</span>);</span></span><br><span class="line"><span class="undefined">      &#125;).observe(outer, &#123;</span></span><br><span class="line"><span class="javascript">        attributes: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">target</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"click"</span> + <span class="string">' '</span> + target);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"延迟任务"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;, 0);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          resolve(<span class="string">'promise'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(value);</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        outer.setAttribute(<span class="string">"data-random"</span>, <span class="built_in">Math</span>.random());</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      inner.addEventListener(<span class="string">"click"</span>, () =&gt; onClick(<span class="string">'inner'</span>));</span></span><br><span class="line"><span class="javascript">      outer.addEventListener(<span class="string">"click"</span>, () =&gt; onClick(<span class="string">'outer'</span>));</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    test();</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">click inner</span><br><span class="line">promise</span><br><span class="line">检测到dom改变</span><br><span class="line">click outer</span><br><span class="line">promise</span><br><span class="line">检测到dom改变</span><br><span class="line">延迟任务</span><br><span class="line">延迟任务</span><br></pre></td></tr></table></figure>
<h3 id="一个事件循环执行过程"><a href="#一个事件循环执行过程" class="headerlink" title="一个事件循环执行过程"></a>一个事件循环执行过程</h3><p>先执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setInterval'</span>)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout 1'</span>)</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'promise 2'</span>)</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'setTimeout 2'</span>)</span><br><span class="line">            <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'promise 3'</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                clearInterval(interval)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 1'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise <span class="number">1</span></span><br><span class="line">setInterval</span><br><span class="line">setTimeout <span class="number">1</span></span><br><span class="line">promise <span class="number">2</span></span><br><span class="line">setInterval</span><br><span class="line">setTimeout <span class="number">2</span></span><br><span class="line">promise <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title>git-rebase</title>
    <url>/2020/04/08/git-rebase/</url>
    <content><![CDATA[<p>太多的commit不利于code review，造成分支污染，如果需要回滚代码，发现有很多的commit，难以定位要回滚的版本</p>
<h2 id="使用场景：合并多次commit"><a href="#使用场景：合并多次commit" class="headerlink" title="使用场景：合并多次commit"></a>使用场景：合并多次commit</h2><p>git rebase -i HEAD~4</p>
<p>进入vi模式：</p>
<ul>
<li><p>p, pick = use commit</p>
</li>
<li><p>r, reword = use commit, but edit the commit message</p>
</li>
<li><p>e, edit = use commit, but stop for amending（停下来修改）</p>
</li>
<li><p>s, squash = use commit, but meld into previous commit（融入先前哪个commit）</p>
</li>
<li><p>f, fixup = like “squash”, but discard this commit’s log message（丢弃这个commit的日志信息）</p>
</li>
<li><p>x, exec = run command (the rest of the line) using shell（运行命令）</p>
</li>
<li><p>d, drop = remove commit</p>
</li>
</ul>
<h2 id="git-pull-–rebase"><a href="#git-pull-–rebase" class="headerlink" title="git pull –rebase"></a>git pull –rebase</h2><p>多个人使用同一个远程分支合作开发，执行git pull之后，远程有新的commit</p>
<h2 id="git-rebase-–abort"><a href="#git-rebase-–abort" class="headerlink" title="git rebase –abort"></a>git rebase –abort</h2>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/07/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>手写Promise，了解Promise核心原理</title>
    <url>/2020/10/23/my-promise/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>react/context</title>
    <url>/2019/06/28/react-context/</url>
    <content><![CDATA[<p>context 提供了一个无需为每层组件手动添加 props，就可以在组件树之间进行数据传递的方法</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li>React.createContext</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Context对象，并传递一个默认的值： defaultValue， 其他组件可以订阅这个Context对象，称为消费组件</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext(<span class="string">"defaultValue"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>Context.Provider</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个Context对象都返回一个Provider React 组件，</span></span><br><span class="line">&lt;MyContext.Provider value=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt;</span><br><span class="line">  &lt;ThemedButton /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br></pre></td></tr></table></figure>
<p>Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。</p>
<p>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p>
<ul>
<li>订阅 Context</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过指定contextType订阅Context</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = ThemeContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.context&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Class.contextType</li>
</ul>
<p>挂在在 class 的 contextType 属性会被重新赋值为一个由 React.createContext() 创建的 Context 对象</p>
<p>在 class 内部可以使用 this.context 来消费最近的 Context 上的那个值，可以在任何生命周期中访问到它，包括 render 函数中。</p>
<ul>
<li>Context.Consumer</li>
</ul>
<p>在函数式组件中完成订阅 Context，这需要函数作为子元素，这个函数接受当前的 context 值，返回一个 React 节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* 基于 context 值进行渲染*/</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br></pre></td></tr></table></figure>
<p>传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。</p>
<h2 id="动态-Context"><a href="#动态-Context" class="headerlink" title="动态 Context"></a>动态 Context</h2><h2 id="嵌套组件中更新-Context"><a href="#嵌套组件中更新-Context" class="headerlink" title="嵌套组件中更新 Context"></a>嵌套组件中更新 Context</h2><p>要在嵌套很深的组件中更新 Context，可以通过 context 传递一个函数，使得 consumers 组件更新 context</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// theme-context.js</span></span><br><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">"#000000"</span>,</span><br><span class="line">    background: <span class="string">"#eeeeee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">"#ffffff"</span>,</span><br><span class="line">    background: <span class="string">"#222222"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(&#123;</span><br><span class="line">  theme: themes.dark,</span><br><span class="line">  <span class="comment">// 默认值，函数</span></span><br><span class="line">  toggleTheme: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"default click"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// theme-toggler-button.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeToggleButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 利用函数式组件和Consumer订阅Context</span></span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123; theme, toggleTheme &#125;) =&gt; (</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;toggleTheme&#125;</span><br><span class="line">          style=&#123;&#123; <span class="attr">backgroundColor</span>: theme.background, <span class="attr">color</span>: theme.foreground &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.toggleTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"click"</span>);</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        theme: state.theme === themes.dark ? themes.light : themes.dark</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggleTheme: <span class="keyword">this</span>.toggleTheme</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Content() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemeToggleButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="消费多个-Context"><a href="#消费多个-Context" class="headerlink" title="消费多个 Context"></a>消费多个 Context</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line">  &#123;theme =&gt; (</span><br><span class="line">    &lt;UserContext.Consumer&gt;</span><br><span class="line">      &#123;user =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ProfilePage</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">UserContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">  )&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组操作</title>
    <url>/2020/08/04/js-array/</url>
    <content><![CDATA[<h2 id="数组随机排序"><a href="#数组随机排序" class="headerlink" title="数组随机排序"></a>数组随机排序</h2><h3 id="随机数打乱数组的排序"><a href="#随机数打乱数组的排序" class="headerlink" title="随机数打乱数组的排序"></a>随机数打乱数组的排序</h3><p>遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素</p>
<p>通过随机数打乱数组原有的排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort1</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="comment">// 生成一个在数组长度范围内的随机数</span></span><br><span class="line">    <span class="keyword">let</span> rc = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * l)</span><br><span class="line">    <span class="comment">// 让当前循环的数组元素和随机出来的数组元素交换位置</span></span><br><span class="line">    <span class="keyword">const</span> current = arr[i]</span><br><span class="line">    arr[i] = arr[rc]</span><br><span class="line">    arr[rc] = current</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成新的随机排序数组"><a href="#生成新的随机排序数组" class="headerlink" title="生成新的随机排序数组"></a>生成新的随机排序数组</h3><p>通过随机数从数组中随机取出某一项，重新排序组成新的数组</p>
<ul>
<li><p>循环给定的数组，</p>
</li>
<li><p>每次循环根据数组的长度获取随机整数</p>
</li>
<li><p>以获取的随机数为索引，从数组中取出该随机数所对应的那一项，push到新的数组中去</p>
</li>
<li><p>然后用splice方法从原数组中删除已经放进新数组的那一项</p>
</li>
<li><p>循环执行以上操作</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mixedArr = []</span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> rc = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * arr.length)</span><br><span class="line">    mixedArr.push(arr[rc])</span><br><span class="line">    arr.splice(rc, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mixedArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="array-sort方法排序"><a href="#array-sort方法排序" class="headerlink" title="array.sort方法排序"></a>array.sort方法排序</h3><p>sort方法会在愿数组上进行排序，接受一个排序的方法，通过生成随机数的方式，决定要不要调换当前两个元素的顺序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h2><h3 id="根据对象单个属性排序"><a href="#根据对象单个属性排序" class="headerlink" title="根据对象单个属性排序"></a>根据对象单个属性排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = a[property]</span><br><span class="line">    <span class="keyword">let</span> value2 = b[property]</span><br><span class="line">    <span class="keyword">return</span> value1 - value2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'zopp'</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'gpp'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'yjj'</span>, <span class="attr">age</span>: <span class="number">8</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">arr.sort(compare(<span class="string">'age'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="多个属性排序"><a href="#多个属性排序" class="headerlink" title="多个属性排序"></a>多个属性排序</h3><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><h3 id="ES6-中的-flat-方法"><a href="#ES6-中的-flat-方法" class="headerlink" title="ES6 中的 flat 方法"></a>ES6 中的 flat 方法</h3><p>array.flat接受一个数字，表示要扁平化的深度</p>
<h3 id="利用递归"><a href="#利用递归" class="headerlink" title="利用递归"></a>利用递归</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> flatten = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      flatten(item)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用-reduce-函数迭代"><a href="#利用-reduce-函数迭代" class="headerlink" title="利用 reduce 函数迭代"></a>利用 reduce 函数迭代</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten2(cur) : cur)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="利用indexOf"><a href="#利用indexOf" class="headerlink" title="利用indexOf"></a>利用indexOf</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArr.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="先将原数组排序，在与相邻的进行比较，如果不同则存入新数组"><a href="#先将原数组排序，在与相邻的进行比较，如果不同则存入新数组" class="headerlink" title="先将原数组排序，在与相邻的进行比较，如果不同则存入新数组"></a>先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formArr = arr.sort()</span><br><span class="line">  <span class="keyword">var</span> newArr = [formArr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; formArr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (formArr[i] !== formArr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      newArr.push(formArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用对象属性存在的特性，如果没有该属性则存入新数组"><a href="#利用对象属性存在的特性，如果没有该属性则存入新数组" class="headerlink" title="利用对象属性存在的特性，如果没有该属性则存入新数组"></a>利用对象属性存在的特性，如果没有该属性则存入新数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique3</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">      obj[arr[i]] = <span class="number">1</span></span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用数组原型对象上的-includes-方法"><a href="#利用数组原型对象上的-includes-方法" class="headerlink" title="利用数组原型对象上的 includes 方法"></a>利用数组原型对象上的 includes 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(arr[i])) &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用数组原型对象上的-filter-和-includes-方法"><a href="#利用数组原型对象上的-filter-和-includes-方法" class="headerlink" title="利用数组原型对象上的 filter 和 includes 方法"></a>利用数组原型对象上的 filter 和 includes 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique5</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newArr.includes(item) ? <span class="string">''</span> : newArr.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用-ES6-的-set-方法"><a href="#利用-ES6-的-set-方法" class="headerlink" title="利用 ES6 的 set 方法"></a>利用 ES6 的 set 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)) <span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据属性去重"><a href="#根据属性去重" class="headerlink" title="根据属性去重"></a>根据属性去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique6</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !res.has(item.id) &amp;&amp; res.set(item.id, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique6([&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'aa'</span>&#125;, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'bb'</span>&#125;]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique7</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i].id]) &#123;</span><br><span class="line">      result.push(arr[i])</span><br><span class="line">      obj[arr[i].id] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取数组的交集-并集-差集"><a href="#取数组的交集-并集-差集" class="headerlink" title="取数组的交集/并集/差集"></a>取数组的交集/并集/差集</h2><h3 id="includes-方法结合-filter-方法"><a href="#includes-方法结合-filter-方法" class="headerlink" title="includes 方法结合 filter 方法"></a>includes 方法结合 filter 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = a.concat(b.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> !a.includes(v)))</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersection = a.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> b.includes(v))</span><br><span class="line"><span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = a.concat(b).filter(<span class="function">(<span class="params">v</span>) =&gt;</span> !a.includes(v) || !b.includes(v))</span><br><span class="line"><span class="comment">// [1,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="ES6-的-Set-数据结构"><a href="#ES6-的-Set-数据结构" class="headerlink" title="ES6 的 Set 数据结构"></a>ES6 的 Set 数据结构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4,5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x)))</span><br><span class="line"><span class="comment">// set &#123;2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x) || !a.has(x)))</span><br><span class="line"><span class="comment">// Set &#123;1, 3, 4 , 5&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    s += arr[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>] + sum(arr.slice(<span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ES6-的-reduce-方法"><a href="#ES6-的-reduce-方法" class="headerlink" title="ES6 的 reduce 方法"></a>ES6 的 reduce 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, curr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + curr</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类数组转化"><a href="#类数组转化" class="headerlink" title="类数组转化"></a>类数组转化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...arguments]</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>window.print打印设置水印和页头页底</title>
    <url>/2020/05/08/print/</url>
    <content><![CDATA[<p>需求：点击打印按钮，打印出两个不同的文件，第一个文件是普通的表格，无特殊要求，第二个是打印一份录用员工的offer，打印offer需要每一页都有水印、带有公司logo的页头和带有公司网站的页底</p>
<p>每一页的带有公司logo的页头页底，可以使用样式 <code>position: fixed;</code>设置为position: fixed;样式属性的元素，可以在打印的时候每一页纸上都显示在固定位置，样式如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正文部分设置适当的paddingTop值，使用 <code>pageBreakAfter: &#39;always&#39;</code>在适当的位置强制分页，效果：</p>
<p><img src="/img/print/test1.jpeg" alt="效果"></p>
<p>水印部分也要每个页面都有，同样思路使用 <code>position: fixed;</code>定位元素，正文部分要浮在水印的上面，使用<code>z-index</code>让正文部分的值高于水印部分的值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.watermark</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(10) <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fffffe</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/print/test2.png" alt="效果"></p>
<p>碰到另外一个问题：点击一个按钮同时打印出来的除了offer还有另外一个审批的表格table，这个表格不需要页头页底和水印。</p>
<p>解决方案：设置一个足够高的白色蒙版，<code>absolute</code>相对于offer定位，遮住不需要的水印和页头页底</p>
<p>absolute定位的元素不会在每一页都显示，但是会根据相对的父级元素定位，可以用来遮住不想显示的内容</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    position: <span class="string">'absolute'</span>,</span><br><span class="line">    top: <span class="number">-1199</span>,</span><br><span class="line">    left: <span class="number">0</span>,</span><br><span class="line">    width: <span class="string">'100%'</span>,</span><br><span class="line">    height: <span class="number">1200</span>,</span><br><span class="line">    zIndex: <span class="number">1</span>,</span><br><span class="line">    background: <span class="string">'#fff'</span>,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title>react/refs</title>
    <url>/2019/07/15/react-refs/</url>
    <content><![CDATA[<p>官网文档的搬运者</p>
<h2 id="何时使用-refs"><a href="#何时使用-refs" class="headerlink" title="何时使用 refs"></a>何时使用 refs</h2><ol>
<li><p>管理焦点，文本选择或媒体播放</p>
</li>
<li><p>触发强制动画。</p>
</li>
<li><p>集成第三方 DOM 库。</p>
</li>
</ol>
<h2 id="创建-ref"><a href="#创建-ref" class="headerlink" title="创建 ref"></a>创建 ref</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 创建ref</span></span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="keyword">this</span>.myRef.current;</span><br></pre></td></tr></table></figure>
<h3 id="ref-的值根据节点的类型而有所不同："><a href="#ref-的值根据节点的类型而有所不同：" class="headerlink" title="ref 的值根据节点的类型而有所不同："></a>ref 的值根据节点的类型而有所不同：</h3><ul>
<li><p>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。</p>
</li>
<li><p>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。</p>
</li>
<li><p>你不能在函数组件上使用 ref 属性，因为他们没有实例。</p>
</li>
</ul>
<h2 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setTextInputRef = <span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.textInput = element;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 使用原生 DOM API 使 text 输入框获得焦点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.textInput) <span class="keyword">this</span>.textInput.focus();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 组件挂载后，让文本框自动获得焦点</span></span><br><span class="line">    <span class="keyword">this</span>.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React</span></span><br><span class="line">    <span class="comment">// 实例上（比如 this.textInput）</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.setTextInputRef&#125; /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以在组件间传递回调形式的 refs，就像你可以传递通过 React.createRef() 创建的对象 refs 一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;CustomTextInput inputRef=&#123;el =&gt; (this.inputElement = el)&#125; /</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转发-refs-到-DOM-组件"><a href="#转发-refs-到-DOM-组件" class="headerlink" title="转发 refs 到 DOM 组件"></a>转发 refs 到 DOM 组件</h2><p>Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="comment">// 当 ref 挂载完成，ref.current 将指向 &lt;button&gt; DOM 节点。</span></span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"FancyButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 你可以直接获取 DOM button 的 ref：</span></span><br><span class="line"><span class="regexp">const ref = React.createRef();</span></span><br><span class="line"><span class="regexp">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/</span>FancyButton&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="在高阶组件-HOC-中转发-refs"><a href="#在高阶组件-HOC-中转发-refs" class="headerlink" title="在高阶组件(HOC)中转发 refs"></a>在高阶组件(HOC)中转发 refs</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"old props:"</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"new props:"</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return LogProps;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class FancyButton extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  focus() &#123;&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default logProps(FancyButton);</span></span><br></pre></td></tr></table></figure>
<p>调用高阶组件：logProps组件，并且传递props时，高阶组件会透传props到他的包裹组件，但refs不会传递，因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。</p>
<h3 id="使用React-forwardRef在高阶组件中传递refs"><a href="#使用React-forwardRef在高阶组件中传递refs" class="headerlink" title="使用React.forwardRef在高阶组件中传递refs"></a>使用React.forwardRef在高阶组件中传递refs</h3><p>重写上面的高阶组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LogProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"old props:"</span>, prevProps);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"new props:"</span>, <span class="keyword">this</span>.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; forwardedRef, ...rest &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  // return LogProps;</span></span><br><span class="line"><span class="xml">  return React.forwardRef((props, ref) =&gt; &#123;</span></span><br><span class="line">    return &lt;LogProps &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react/renderProps</title>
    <url>/2019/07/08/react-renderProps/</url>
    <content><![CDATA[<p>具有reader prop的组件，接受一个函数，该函数返回一个react元素，并调用它，而不是事先自己的渲染逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">)&#125;/</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如何分享一个组件封装到其他需要相同state组件的状态或行为并不是很容易</p>
<p>render prop是一个用于告知组件需要渲染什么内容的函数prop</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class Cat extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const mouse = this.props.mouse;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p style=&#123;&#123; position: &quot;absolute&quot;, left: mouse.x, top: mouse.y &#125;&#125;&gt;猫咪&lt;/p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handelMouseMove = this.handelMouseMove.bind(this);</span><br><span class="line">    this.state = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handelMouseMove(event) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: event.clientX,</span><br><span class="line">      y: event.clientY</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123;&#123; height: &quot;100%&quot; &#125;&#125; onMouseMove=&#123;this.handelMouseMove&#125;&gt;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标！&lt;/h1&gt;</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; &lt;Cat mouse=&#123;mouse&#125; /&gt;&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MouseTracker;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react/state</title>
    <url>/2019/06/28/react-state/</url>
    <content><![CDATA[<p>setState方法可以接受一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// counter: state.counter + props.increment</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>上一个状态的state作为第一个参数，此次更新的props作为第二个参数</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>网站收藏</title>
    <url>/2019/07/10/site/</url>
    <content><![CDATA[<p><a href="https://www.phodal.com/" target="_blank" rel="noopener">phodal博客</a></p>
<p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰的网络日志</a></p>
<p><a href="https://github.com/happyrui/nestTodoList/tree/develop" target="_blank" rel="noopener">赵芮(微盟同事)的github</a></p>
<p><a href="https://blog.csdn.net/zr15829039341" target="_blank" rel="noopener">赵芮(微盟同事)的博客</a></p>
<p><a href="https://martindelophy.github.io/blog/" target="_blank" rel="noopener">杨海鑫（同事）的博客</a></p>
]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>react-router原理</title>
    <url>/2020/07/15/react-router/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>编写可维护的webpack构建配置，进阶学习</title>
    <url>/2020/05/27/webpack-builder/</url>
    <content><![CDATA[<p>如何把webpack的配置编写的更加通用，把webpack的配置编写成一个构建包，在每个项目里都能快速使用</p>
<p>现在的webpack配置分为webpack.prod.js，  webpack.dev.js，  webpack.ssr.js，分别对应三个不同的环境场景，三个配置文件里面的配置有些都是相同的例如es6代码的转换，react的使用、处理less样式文件等，不得不每次复制到每个配置文件代码里面去，而不同的环境场景的配置又具有差异，解决思路就是新建一个webpack.base.js文件存放共用的配置，使用webpack-merge组件合并配置</p>
<p>在根目录新建build-webpack文件夹，cd build-webpack，进入目录，npm init -y初始化package.json文件</p>
<p>build-webpack文件夹下新建lib目录，存放webpack配置文件，在lib文件下新建webpack.base.js，webpack.prod.js，  webpack.dev.js，  webpack.ssr.js文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.base.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> FriendlyErrorsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置entry 和 htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index.jsx'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.jsx/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = entryFile;</span><br><span class="line">    htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        chunks: [<span class="string">'vendors'</span>, pageName],</span><br><span class="line">        inject: <span class="literal">true</span>,</span><br><span class="line">        minify: &#123;</span><br><span class="line">          html5: <span class="literal">true</span>,</span><br><span class="line">          preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          minifyCSS: <span class="literal">true</span>,</span><br><span class="line">          minifyJS: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlWebpackPlugin&#125; = setMPA();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(projectRoot, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            remUnit: <span class="number">75</span>, <span class="comment">// 转换率：1rem = 75px</span></span><br><span class="line">            remPrecision: <span class="number">8</span> <span class="comment">// 转换之后保留小数点后位数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ...htmlWebpackPlugin,</span><br><span class="line">    <span class="keyword">new</span> FriendlyErrorsWebpackPlugin(),</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hooks.done.tab(<span class="string">'done'</span>, (stats) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(stats.compilation.errors &amp;&amp; stats.compilation.errors.length &amp;&amp; process.argv.indexOf(<span class="string">'--watch'</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'build error'</span>);</span><br><span class="line">          process.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  stats: <span class="string">'errors-only'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安装 :<code>npm i webpack-merge -D</code></p>
<p>webpack.dev.js包括热更新和source-map，使用webpack-merge合并配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热更新，source-map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 服务基础目录</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 开启热更新</span></span><br><span class="line">    stats: <span class="string">'errors-only'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, devConfig);</span><br></pre></td></tr></table></figure>
<p>webpack.prod.jsb包括代码压缩，文件指纹,公共资源的提取：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码压缩，文件指纹,公共资源的提取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react@16/umd/react.development.js'</span>,</span><br><span class="line">        global: <span class="string">'React'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react-dom@16/umd/react-dom.development.js'</span>,</span><br><span class="line">        global: <span class="string">'ReactDom'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: <span class="number">0</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: <span class="string">'commons'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, prodConfig);</span><br></pre></td></tr></table></figure>
<p>webpack.ssr.js主要是不解析css文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.ssr.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>);</span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码压缩，文件指纹,公共资源的提取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: <span class="string">'ignore-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: <span class="string">'ignore-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react@16/umd/react.development.js'</span>,</span><br><span class="line">        global: <span class="string">'React'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react-dom@16/umd/react-dom.development.js'</span>,</span><br><span class="line">        global: <span class="string">'ReactDom'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: <span class="number">0</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: <span class="string">'commons'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, prodConfig);</span><br></pre></td></tr></table></figure>
<p>新建.gitignore文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/node_modules</span><br><span class="line">/logs</span><br></pre></td></tr></table></figure>
<h2 id="使用eslint规范构建脚本"><a href="#使用eslint规范构建脚本" class="headerlink" title="使用eslint规范构建脚本"></a>使用eslint规范构建脚本</h2><p>eslint可以帮助在构建之前检查代码的规范，而不是等到运行的时候在报错</p>
<p>在build-webpack目录安装eslint以及eslint所需要的依赖：<code>npm i eslint eslint-config-airbnb-base babel-eslint -D</code></p>
<p>新建.eslintrc.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build-webpack/.eslintrc.</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"airbnb-base"</span>,</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"node"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在package.json增加eslint script</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// build-webpack/package.json</span><br><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "eslint": "eslint ./lib --fix"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run eslint可以帮助在构建之前检查规范，</p>
<p>在命令行运行npm run eslint</p>
<p><img src="/img/webpack/w17.png" alt="图片"></p>
<p>这边的报错是因为我的webpack配置中使用的插件没有安装</p>
<p>根据报错一次安装插件到dependencies，根据提示解决报错</p>
<h2 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h2><p>冒烟测试确保构建没有大问题，检测一些基本的功能可用</p>
<p>例如构建是否成功，每次构建完成是否正确的打包静态资源</p>
<p>在test新建template目录，作为模版目录，也就是要使用构建脚本构建的项目，可以把之前的项目复制一份进来，删除不需要的文件：</p>
<p><img src="/img/webpack/w18.png" alt="图片"></p>
<p>在build-webpack目录新建test目录，test新建smoke目录，smoke新建index.js文件用来编写测试脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/smoke/index.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> rimraf = <span class="built_in">require</span>(<span class="string">'rimraf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入tamplate，__dirname代表运行时候的目录</span></span><br><span class="line">process.chdir(path.join(__dirname, <span class="string">'template'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次构建之前，删除dist目录</span></span><br><span class="line">rimraf(<span class="string">'./dist'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 引入配置</span></span><br><span class="line">  <span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">'../../lib/webpack.prod.js'</span>);</span><br><span class="line">  <span class="comment">// 通过webpack对template目录的代码运行prodConfig这个配置</span></span><br><span class="line">  webpack(prodConfig, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      process.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(stats.toString(&#123;</span><br><span class="line">      color: <span class="literal">true</span>,</span><br><span class="line">      modules: <span class="literal">false</span>,</span><br><span class="line">      children: <span class="literal">false</span></span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在build-webpack目录安装： <code>npm i rimraf -S</code></p>
<p>修改webpack.base.js文件，增加projectRoot，修改执行的目录为tamplate目录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.base.js</span></span><br><span class="line"><span class="keyword">const</span> projectRoot = process.cwd(); <span class="comment">// 当前目录</span></span><br><span class="line"><span class="keyword">const</span> setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(projectRoot, <span class="string">'./src/*/index.jsx'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(projectRoot, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在终端运行：<code>node test/smoke/index.js</code></p>
<h3 id="检查dist目录是否有构建出来的文件"><a href="#检查dist目录是否有构建出来的文件" class="headerlink" title="检查dist目录是否有构建出来的文件"></a>检查dist目录是否有构建出来的文件</h3><p>使用mocha编写单元测试的测试用例，安装： <code>npm i mocha -D</code></p>
<p><code>npm i glob-all -D</code></p>
<p>新建smoke/html-test.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob-all'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'checking generated html files'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should genarate html files'</span>, (done) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> files = glob.sync([<span class="string">'./dist/index.html'</span>, <span class="string">'./dist/search.html'</span>]);</span><br><span class="line">    <span class="keyword">if</span>(files.length &gt; <span class="number">0</span>) done();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'no html files genarated'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>新建smoke/css-js-test.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob-all'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'checking generated css js files'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should genarate css js files'</span>, (done) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> files = glob.sync([<span class="string">'./dist/index_*.js'</span>, <span class="string">'./dist/search_*.js'</span>, <span class="string">'./dist/index_*.css'</span>, <span class="string">'./dist/search_*.css'</span>]);</span><br><span class="line">    <span class="keyword">if</span>(files.length &gt; <span class="number">0</span>) done();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'no css js files genarated'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>修改smoke/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /...</span></span><br><span class="line"><span class="keyword">const</span> Mocha = <span class="built_in">require</span>(<span class="string">'mocha'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mocha = <span class="keyword">new</span> Mocha(&#123;</span><br><span class="line">  timeout: <span class="string">'10000ms'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 每次构建之前，删除dist目录</span></span><br><span class="line">rimraf(<span class="string">'./dist'</span>, () =&gt; &#123;</span><br><span class="line">  webpack(prodConfig, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'webpack build success, begin run test'</span>);</span><br><span class="line">    mocha.addFile(path.join(__dirname, <span class="string">'html-test.js'</span>));</span><br><span class="line">    mocha.addFile(path.join(__dirname, <span class="string">'css-js-test.js'</span>));</span><br><span class="line">    mocha.run();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在终端运行：<code>node test/smoke/index.js</code>，冒烟测试成功之后会在终端打印</p>
<p><img src="/img/webpack/w19.png" alt="图片"></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>使用抹茶和断言库进行单元测试</p>
<p>安装断言库：<code>npm i assert -D</code></p>
<p>在test目录新建index文件，作为单元测试的入口，在test目录新建unit目录，这个目录放单元测试的代码</p>
<p>测试webpack.base配置，test/unit/webpack-base-test.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test/unit/webpack-base-test.js</span></span><br><span class="line">describe(<span class="string">'webpack.base.js test case'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'../../lib/webpack.base'</span>);</span><br><span class="line">  <span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line">  <span class="comment">// console.log(baseConfig)</span></span><br><span class="line">  <span class="comment">// 测试entry字段</span></span><br><span class="line">  it(<span class="string">'entry'</span>, () =&gt; &#123;</span><br><span class="line">    assert.equal(baseConfig.entry.index, <span class="string">'/Users/lizhaoxin/mypro/webpack-first/build-webpack/test/smoke/template/src/index/index.jsx'</span>);</span><br><span class="line">    assert.equal(baseConfig.entry.search, <span class="string">'/Users/lizhaoxin/mypro/webpack-first/build-webpack/test/smoke/template/src/search/index.jsx'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>test/index：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入tamplate, __dirname代表运行时候的目录</span></span><br><span class="line">process.chdir(path.join(__dirname, <span class="string">'smoke/template'</span>));</span><br><span class="line"><span class="comment">// 引入测试代码</span></span><br><span class="line">describe(<span class="string">'builder-webpack test case'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./unit/webpack-base-test'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>修改build-webpack/package.json，增加test运行脚本</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "./node_modules/.bin/_mocha",</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run test:测试用例成功了，会在前面打勾</p>
<p><img src="/img/webpack/w20.png" alt="图片"></p>
<p>测试覆盖率， istanbul是一个单元测试代码覆盖率检查工具，可以很直观地告诉我们，单元测试对代码的控制程度。，安装 npm i istanbul -D, 修改build-webpack/package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "istanbul cover ./node_modules/.bin/_mocha",</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run build,可以在终端看到，测试用例的覆盖情况,例如单元测试覆盖了多少函数，多少代码行数，多少分支：</p>
<p><img src="/img/webpack/w21.png" alt="图片"></p>
<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2>]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks 数据流</title>
    <url>/2020/08/04/react-hooks-dataStream/</url>
    <content><![CDATA[<h2 id="单组件数据流"><a href="#单组件数据流" class="headerlink" title="单组件数据流"></a>单组件数据流</h2><p>使用useState，毫无争议</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件间共享数据流"><a href="#组件间共享数据流" class="headerlink" title="组件间共享数据流"></a>组件间共享数据流</h2><p>我们首先想到的就是useContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建Context</span><br><span class="line">const CountContext = createContext&lt;any&gt;(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  let [count, setCount] = useState(1);</span><br><span class="line"></span><br><span class="line">  function add() &#123;</span><br><span class="line">    setCount(++count);</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    // 通过父级组件分发</span><br><span class="line">    &lt;CountContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt;</span><br><span class="line">      &lt;Card title=&quot;createContext&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">        &lt;Child2 /&gt;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    &lt;/CountContext.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">  let &#123; count, setCount &#125; = useContext(CountContext);</span><br><span class="line"></span><br><span class="line">  function add() &#123;</span><br><span class="line">    setCount(--count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;count:&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;add&#125;&gt;-&lt;/Button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">function Child2() &#123;</span><br><span class="line">  let &#123; count, setCount &#125; = useContext(CountContext);</span><br><span class="line"></span><br><span class="line">  function add() &#123;</span><br><span class="line">    setCount(count - 2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;count:&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;add&#125;&gt;-2&lt;/Button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题是数据与 UI 不解耦，我看到这里的时候，我也不是很明白，我感觉这个很好用，然后接着往下看</p>
<h2 id="数据流与组件解耦-hooks-state-unstated-next"><a href="#数据流与组件解耦-hooks-state-unstated-next" class="headerlink" title="数据流与组件解耦 hooks state + unstated-next"></a>数据流与组件解耦 hooks state + unstated-next</h2><p>unstated-next 是一个React轻量状态管理库，可以帮你把上面例子中，定义在 组件 中的数据单独出来，形成一个自定义数据管理 Hook：</p>
<p><a href="https://github.com/jamiebuilds/unstated-next" target="_blank" rel="noopener">unstated-next</a></p>
<p>简单的API介绍</p>
<ol>
<li><p>unstated-next提供 const Counter = createContainer(useCounter)方法， 创建一个状态管理类，相当于一个容器</p>
</li>
<li><p>Counter.Provider，包裹共享的数据，向应用中注入状态管理实例，</p>
</li>
<li><p>Counter.useContainer，在子组件使用共享的数据</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createContainer &#125; from &quot;unstated-next&quot;;</span><br><span class="line"></span><br><span class="line">// 自定义数据管理 Hook</span><br><span class="line">function useCounter() &#123;</span><br><span class="line">  const [state, setState] = useState&lt;any&gt;(&#123;a: 100, b: 200&#125;);</span><br><span class="line">  return &#123; ...state, setState &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const Counter = createContainer(useCounter);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Counter.Provider&gt;</span><br><span class="line">      &lt;CounterDisplay /&gt;</span><br><span class="line">    &lt;/Counter.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function CounterDisplay() &#123;</span><br><span class="line">  let &#123; a, b, setState &#125; = Counter.useContainer();</span><br><span class="line"></span><br><span class="line">  function changeA() &#123;</span><br><span class="line">    setState(&#123;a: a + 1&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeB()&#123;</span><br><span class="line">    setState(&#123;b: b + 1, a: a + 2&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;unstated-next&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;a:&#123;a&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;changeA&#125;&gt;A加一&lt;/Button&gt;</span><br><span class="line">      &lt;p&gt;b:&#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;changeB&#125;&gt;A加2，B加2&lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法解决了数据流与组件解耦，但是带来了新的问题，就是useState 无法合并更新</p>
<h2 id="合并更新"><a href="#合并更新" class="headerlink" title="合并更新"></a>合并更新</h2><p>为了让数据能够合并更新，我想到了useReducer 可以让数据合并更新，现在的思路就是：</p>
<p>hooks state + unstated-next + useReducer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createContainer &#125; from &quot;unstated-next&quot;;</span><br><span class="line"></span><br><span class="line">function useCounterR()&#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, &#123;a: 100, b: 200&#125;);</span><br><span class="line"></span><br><span class="line">  function reducer(state: any, action: any) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">      case &apos;add&apos;: </span><br><span class="line">        return &#123;...state, a: state.a + 2&#125;;</span><br><span class="line">      case &apos;dec&apos;:</span><br><span class="line">        return &#123;...state, a: state.a - 10&#125;;</span><br><span class="line">      case &apos;double&apos;:</span><br><span class="line">        return &#123;...state, b: state.b * 2&#125;;</span><br><span class="line">      case &apos;triple&apos;:</span><br><span class="line">        return &#123;...state, b: state.b * 3&#125;;</span><br><span class="line">      default:</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回state和修改state的dispatch</span><br><span class="line">  return &#123; ...state, dispatch &#125;;</span><br><span class="line">&#125;</span><br><span class="line">const CounterR = createContainer(useCounterR);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;CounterR.Provider&gt;</span><br><span class="line">      &lt;ViewR /&gt;</span><br><span class="line">      &lt;ViewR2 /&gt;</span><br><span class="line">    &lt;/CounterR.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR() &#123;</span><br><span class="line">  let &#123;a, b, dispatch&#125; = CounterR.useContainer();</span><br><span class="line"></span><br><span class="line">  console.log(&apos;ViewR&apos;, a, b);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;reducer&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;a: &#123;a&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;b:&#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;add&apos;&#125;)&#125;&gt;</span><br><span class="line">        a + 2</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;triple&apos;&#125;)&#125;&gt;</span><br><span class="line">        b乘以3</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR2() &#123;</span><br><span class="line">  let &#123;b, dispatch&#125; = CounterR.useContainer();</span><br><span class="line"></span><br><span class="line">  console.log(&apos;ViewR2&apos;, b);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;reducer&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;b:&#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;triple&apos;&#125;)&#125;&gt;</span><br><span class="line">        b乘以3</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在终于能合并更新了，然后我发现了新的问题，就是子组件之间会相互影响，一个子组件修改了state，其他的子组件会一起重新渲染</p>
<p>这个原因是 Counter.useContainer 提供的数据流是一个引用整体，其子节点 引用变化后会导致整个 Hook 重新执行，继而所有引用它的组件也会重新渲染。</p>
<h2 id="按需更新"><a href="#按需更新" class="headerlink" title="按需更新"></a>按需更新</h2><p>所以我知道了redux为什么会比他们火的原因了</p>
<p>可以利用 Redux useSelector 实现按需更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &quot;redux&quot;;</span><br><span class="line">import &#123; Provider, useSelector, shallowEqual &#125; from &quot;react-redux&quot;;</span><br><span class="line"></span><br><span class="line">const defaultState = &#123;a: 100, b: 200, user: &#123;name: &apos;xinxin&apos;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state: any = defaultState, action: any) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &apos;add&apos;: </span><br><span class="line">      return &#123;...state, a: state.a + 2&#125;;</span><br><span class="line">    case &apos;dec&apos;:</span><br><span class="line">      return &#123;...state, a: state.a - 10&#125;;</span><br><span class="line">    case &apos;double&apos;:</span><br><span class="line">      return &#123;...state, b: state.b * 2&#125;;</span><br><span class="line">    case &apos;triple&apos;:</span><br><span class="line">      return &#123;...state, b: state.b * 3&#125;;</span><br><span class="line">    case &apos;setUser&apos;:</span><br><span class="line">      return &#123;...state, user: &#123;name: &apos;xinxin222&apos;&#125;&#125;;</span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;ViewR3 /&gt;</span><br><span class="line">      &lt;ViewR4 /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR3() &#123;</span><br><span class="line">  // useSelector 接受第一个参数selector函数</span><br><span class="line">  // 要保持这个selector是一个纯函数</span><br><span class="line">  // selector会返回任何值作为结果，并不仅仅是对象了。然后这个selector返回的结果，就会作为useSelector的返回结果。</span><br><span class="line">  // 当action被dispatched的时候，useSelector()将对前一个selector结果值和当前结果值进行浅比较。如果不同，那么就会被re-render。 反之亦然</span><br><span class="line">  // selector不会接收ownProps参数，但是，可以通过闭包(下面有示例)或使用柯里化selector来使用props。</span><br><span class="line">  // 使用记忆(memoizing) selector时必须格外小心(下面有示例)。</span><br><span class="line">  // useSelector()默认使用===(严格相等)进行相等性检查，而不是浅相等(==)。</span><br><span class="line">  const &#123; a &#125; = useSelector(</span><br><span class="line">    (state:any = &#123;&#125;) =&gt; (&#123; a: state.a &#125;),</span><br><span class="line">    shallowEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  const setA = (a: number) =&gt; a + 2;</span><br><span class="line"></span><br><span class="line">  console.log(1);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;redux&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;a: &#123;a&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;add&apos;, setA&#125;)&#125;&gt;</span><br><span class="line">        a + 2</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR4() &#123;</span><br><span class="line">  const &#123; b &#125; = useSelector(</span><br><span class="line">    (state:any = &#123;&#125;) =&gt; (&#123; b: state.b &#125;),</span><br><span class="line">    shallowEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  const setB = (b: number) =&gt; b + 3;</span><br><span class="line"></span><br><span class="line">  console.log(2);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;redux&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;b: &#123;b&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;setB&apos;, setB&#125;)&#125;&gt;</span><br><span class="line">        b + 3</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reducer 可以让子组件之间会相互不影响，一个子组件修改了state，其他的子组件不会一起重新渲染</p>
<p>然后有发现了一个新的问题：但 useSelector 的作用仅仅是计算结果不变化时阻止组件刷新，但并不能保证返回结果的引用不变化。</p>
<p>当state的值是引用类型的时候，每次都会返回一个新的引用，虽然属性值和数量都没有发生变化，但是还是会引起组件重新渲染，如果有子组件也会重新渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Index() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;ViewR5 /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ViewR5() &#123;</span><br><span class="line">  const [myUser, setMyUser] = useState();</span><br><span class="line">  const &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">    (state: any) =&gt; (&#123;user: state.user&#125;),</span><br><span class="line">    shallowEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(myUser, user, Object.is(myUser, user));</span><br><span class="line">    setMyUser(user);</span><br><span class="line">  &#125;, [user])</span><br><span class="line"></span><br><span class="line">  const setUserName = (user: any) =&gt; (&#123;name: &apos;xinxin 22222&apos;&#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;使用Redux，防止数据引用频繁变化&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;userName: &#123;user.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;setUser&apos;, setUserName&#125;)&#125;&gt;</span><br><span class="line">        setUserName</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码console.log(myUser, user, Object.is(myUser, user));打印出来每次myUser, user这两个对象的属性数量和属性值都没发生变化，但是Object.is判断返回false，因为他们不是来自同一个引用类型的</p>
<h2 id="防止数据引用频繁变化"><a href="#防止数据引用频繁变化" class="headerlink" title="防止数据引用频繁变化"></a>防止数据引用频繁变化</h2><p>为了防止数据引用频繁变化而带来的组件重新渲染，浅比较shallowEqual是不起作用的，尝试使用deepEqual</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ViewR6() &#123;</span><br><span class="line">  const &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">    (state: any) =&gt; (&#123;user: state.user&#125;),</span><br><span class="line">    deepEqual</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  const setUserName = (user: any) =&gt; (&#123;name: &apos;xinxin 22222&apos;&#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Card title=&quot;使用Redux，防止数据引用频繁变化&quot; style=&#123;&#123;marginBottom: 20&#125;&#125; type=&quot;inner&quot;&gt;</span><br><span class="line">      &lt;p&gt;userName: &#123;user.name&#125;&lt;/p&gt;</span><br><span class="line">      &lt;RChild name=&#123;user.name&#125;  /&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; store.dispatch(&#123;type: &apos;setUser&apos;, setUserName&#125;)&#125;&gt;</span><br><span class="line">        setUserName</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">function RChild(props) &#123;</span><br><span class="line">  console.log(props.name);</span><br><span class="line">  return &lt;p&gt;&#123;props.name&#125;&lt;/p&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，发现组件不在重新渲染了，现在的问题是这段代码我们拿到的还是新的引用，只不过我们通过deepEqual对前后两次的值进行深比较，在useSelector不在返回新的引用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">  (state: <span class="built_in">any</span>) =&gt; (&#123;user: state.user&#125;),</span><br><span class="line">  deepEqual  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果换成通过机构计算函数去获取状态，像这样子</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">user: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">Object</span>.is(myUser, user)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myUser, user, <span class="built_in">Object</span>.is(myUser, user)); <span class="comment">// false</span></span><br><span class="line">    myUser = user;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;user = &#123;&#125;&#125; = useSelector(</span><br><span class="line">  (state: <span class="built_in">any</span>) =&gt; (&#123;user: getUser(state.user)&#125;),</span><br><span class="line">  deepEqual  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>运行代码，证明console.log(myUser, user, Object.is(myUser, user));会打印出false，说明这里计算函数不管每次接收到的参数是不是一样，每次接收到的都是一个新的引用，所以都会进行重新计算，如果计算函数是一个很复杂，消耗资源的函数，在拿到的引用类型属性值和数量是一样的时候不应该去重新计算</p>
<p>所以给大家介绍一个reselect 中间件，可以对引用进行缓存</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>了解react hooks 数据流</p>
</li>
<li><p>单组件数据流，使用useState</p>
</li>
<li><p>共享数据流，useContext，数据与 UI 不解耦</p>
</li>
<li><p>为了数据流与组件解耦， hooks state + unstated-next， 带来了新的问题，就是useState 无法合并更新</p>
</li>
<li><p>为了让数据能够合并更新，我想到了useReducer 可以让数据合并更新，问题是：子组件之间会相互影响</p>
</li>
<li><p>为了让子组件不相互影响，redux按需更新， 新问题：useSelector 的作用仅仅是计算结果不变化时阻止组件刷新，但并不能保证返回结果的引用不变化。引用变化了子组件会更新</p>
</li>
<li><p>防止数据引用频繁变化， deepEqual解决引用频繁变化</p>
</li>
<li><p>发现新的问题，计算函数消耗资源，reselect 中间件引用进行缓存</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>react</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-进阶配置</title>
    <url>/2020/05/27/webpack-advanced/</url>
    <content><![CDATA[<h2 id="每次构建之前首先自动删除dist目录"><a href="#每次构建之前首先自动删除dist目录" class="headerlink" title="每次构建之前首先自动删除dist目录"></a>每次构建之前首先自动删除dist目录</h2><p>在学习基础配置的时候，给webpack配置添加了文件指纹来做文件的版本管理，如果某个文件有改动，就会生成新的构建文件，故此会在一次次的构建过程中dist目录会留下很多版本的文件，所有每次构建之前不得不手动删除dist目录，很是麻烦</p>
<p>webpack提供了一个插件，可以在每次构建之前首先自动删除dist目录：clean-webpack-plugin插件</p>
<p>首先安装一下：<code>npm i clean-webpack-plugin -D</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>之后运行npm run build，webpack都会先删除dist，在构建</p>
<p>loader是有严格的顺序的，plugin的顺序要求并不严格，不放心的可以把CleanWebpackPlugin插件放在plugin数组的第一个</p>
<h2 id="自动补全css3前缀"><a href="#自动补全css3前缀" class="headerlink" title="自动补全css3前缀"></a>自动补全css3前缀</h2><p>有时候为了使用最新的css样式，需要为不同的浏览器手动的补齐带有各自浏览器内核的前缀，webpack提供的postcss-loader和autoprefixer插件，可以设置为不同的浏览器自动补齐前缀</p>
<p>安装： <code>npm i postcss-loader autoprefixer -D</code></p>
<p>然后在webpack.prod.js中配置：找到.less的loader配置，添加一个postcss-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在src/index.less样式文件中写一个比较新的样式来进行测试</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/index.less */</span></span><br><span class="line">@base: #f938ab;</span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: @base;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，查看dist/index.css-loader自动添加了浏览器前缀：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dist/index.less */</span></span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">color</span>:<span class="number">#f938ab</span>;<span class="attribute">display</span>:-webkit-box;<span class="attribute">display</span>:-webkit-flex;<span class="attribute">display</span>:-ms-flexbox;<span class="attribute">display</span>:flex&#125;</span><br></pre></td></tr></table></figure>
<p>postcss-loader要求在css-loader之前执行，所有在数组中的顺序必须要放在css-loader之后，否则运行会报错</p>
<h2 id="自动转换px为rem"><a href="#自动转换px为rem" class="headerlink" title="自动转换px为rem"></a>自动转换px为rem</h2><p>为了兼容移动设备不同屏幕的分辨率，适配页面，可以使用rem这个单位来编写样式，webpack提供了px2rem-loader这个loader可以帮助px转换为rem单位</p>
<p>借助手淘的一个lib-flexible库，可以在页面渲染时动态计算出跟元素的font-size值</p>
<p>安装：<code>npm i px2rem-loader -D</code></p>
<p>安装：<code>npm i lib-flexible -S</code></p>
<p>在webpack.prod.js中添加配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            remUnit: <span class="number">75</span>, <span class="comment">// 转换率：1rem = 75px</span></span><br><span class="line">            remPrecision: <span class="number">8</span> <span class="comment">// 转换之后保留小数点后位数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在src/index.less样式文件中写一个宽度的样式来进行测试</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/index.less */</span></span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，查看dist/index.less，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dist/index.less */</span></span><br><span class="line"><span class="selector-class">.text</span>&#123;<span class="attribute">width</span>:<span class="number">6.66666667rem</span>&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以看到px已经被转换成rem单位，然后还需要根据不同的屏幕尺寸，设定不同的跟元素字体，这个就需要使用已经安装好的lib-flexible，</p>
<p>lib-flexible是一个比较稳定的库，属于静态资源，所有现在要学习一下如何把静态资源内联进构建目录</p>
<h2 id="静态资源内联"><a href="#静态资源内联" class="headerlink" title="静态资源内联"></a>静态资源内联</h2><p><img src="/img/webpack/w12.png" alt="图片"></p>
<h3 id="html和js内联"><a href="#html和js内联" class="headerlink" title="html和js内联"></a>html和js内联</h3><p>使用raw-loader</p>
<p><code>npm i raw-loader@0.5.1 -D</code></p>
<h2 id="多页面应用打包"><a href="#多页面应用打包" class="headerlink" title="多页面应用打包"></a>多页面应用打包</h2><p>每次增加一个新的页面入口的时候，都需要手动的修改webpack 的配置文件，修改entry字段，增加入口配置，修改plugin里面的HtmlWebpackPlugin配置，因为每个html入口文件对应一个HtmlWebpackPlugin，这样子及其不方便，</p>
<p>推荐使用glob这个库，通过约定文件目录，glob可以动态找到要配置的入口文件，借助这个可以动态生成entry，和HtmlWebpackPlugin数组，而不需要在每次添加一个entry的时候都去手动的修改webpack配置。</p>
<p>首先来整理一下目录：有两个entry，分别是index.js和search.js，在src下新建一个index文件夹，把之前在src下的index.js和index.less移动到index文件夹下面，在index文件夹下新建一个index.html作为index.js生成html文件的模版文件，可以直接从原来的public/index.html复制过来，新建一个src/search文件夹，在这个文件夹下新建模版文件index.html，入口文件index.js，index.less样式文件，</p>
<p>最后的文件目录：</p>
<p><img src="/img/webpack/w13.png" alt="图片"></p>
<p>安装glob: <code>npm i glob -D</code></p>
<p>修改webpack.prod.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置entry 和 htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index.js'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.js/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = entryFile;</span><br><span class="line">    htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        chunks: [pageName],</span><br><span class="line">        inject: <span class="literal">true</span>,</span><br><span class="line">        minify: &#123;</span><br><span class="line">          html5: <span class="literal">true</span>,</span><br><span class="line">          preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          minifyCSS: <span class="literal">true</span>,</span><br><span class="line">          minifyJS: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlWebpackPlugin&#125; = setMPA();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ...htmlWebpackPlugin,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>再次运行npm run build，查看dist目录，可以检测效果，假如以后要增加一个entry，只需要按照约定新建目录，即可，无需修改webpack配置文件</p>
<p>同样到配置代码，复制一份到webpack.dev.js中</p>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">JavaScript Source Map 详解</a></p>
<h2 id="提取页面公共资源"><a href="#提取页面公共资源" class="headerlink" title="提取页面公共资源"></a>提取页面公共资源</h2><p>提取页面公共资源可以减少构建文件的体积</p>
<h3 id="基础库的分离"><a href="#基础库的分离" class="headerlink" title="基础库的分离"></a>基础库的分离</h3><p>使用html-webpack-externals-plugin，react\react-dom通过cdn引入，不打包进bundle中</p>
<p>安装：<code>npm i html-webpack-externals-plugin -D</code>，</p>
<p>在webpack.prod.js配置文件中使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react@16/umd/react.development.js'</span>,</span><br><span class="line">        global: <span class="string">'React'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: <span class="string">'https://unpkg.com/react-dom@16/umd/react-dom.development.js'</span>,</span><br><span class="line">        global: <span class="string">'ReactDom'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>没有配置之前的构建文件先看一下，构建出来的js文件129k,</p>
<p><img src="/img/webpack/w14.png" alt="图片"></p>
<p>配置之后的构建文件，js文件10k不到，差别还是很明显的</p>
<p><img src="/img/webpack/w15.png" alt="图片"></p>
<p>最后分别在入口文件的模版html中引入react/react-dom：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/index/index.html --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- src/search/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- zhengwen --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="SplitChunksPlugin-基础包的分离"><a href="#SplitChunksPlugin-基础包的分离" class="headerlink" title="SplitChunksPlugin 基础包的分离"></a>SplitChunksPlugin 基础包的分离</h3><p>把react和react-dom进行单独的分离提取出来，叫vendors.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index.js'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index\.js/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    entry[pageName] = entryFile;</span><br><span class="line">    htmlWebpackPlugin.push(</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">        filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        chunks: [<span class="string">'vendors'</span>, pageName],</span><br><span class="line">        inject: <span class="literal">true</span>,</span><br><span class="line">        minify: &#123;</span><br><span class="line">          html5: <span class="literal">true</span>,</span><br><span class="line">          preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          minifyCSS: <span class="literal">true</span>,</span><br><span class="line">          minifyJS: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: <span class="regexp">/(react|react-dom)/</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 查看dist目录，构建出一个vendors.js文件，就是成功提取出的react和react-dom</p>
<h3 id="SplitChunksPlugin-分离页面公共的代码"><a href="#SplitChunksPlugin-分离页面公共的代码" class="headerlink" title="SplitChunksPlugin 分离页面公共的代码"></a>SplitChunksPlugin 分离页面公共的代码</h3><p>通过配置，把页面使用多次的代码提取出一个公共的文件，叫commons.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: <span class="number">0</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: <span class="string">'commons'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span> <span class="comment">// 最少使用次数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 查看dist目录，构建出一个commons.js文件，就是成功提取出的公共的代码</p>
<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><p>摇树优化，一个模块可能有多个方法，只要有其中一个方法被用到了，整个模块就会被打包到bundle里面去，tree shaking就是把用到的方法打包进去，多余的代码在uglify阶段就会被清除掉</p>
<p>删除无用代码的工作原理：</p>
<ul>
<li><p>不会执行到的代码，不会到达的代码</p>
</li>
<li><p>代码执行的结果不会被用到</p>
</li>
<li><p>代码只写不读</p>
</li>
</ul>
<p>tree shaking原理：利用es6模块的特点，import 、export都是出现在顶层，并且import进来的代码不可修改，tree shaking对模块的代码静态分析，在编译阶段分析哪些代码没有用到，对这些代码进行标记，在uglify阶段把它清除掉</p>
<p>在webpack config的配置文件中，设置<code>mode: &#39;production&#39;,</code>就会自动开始tree shaking</p>
<h2 id="scope-hoisting"><a href="#scope-hoisting" class="headerlink" title="scope hoisting"></a>scope hoisting</h2><p>对于每一个模块打包出来的文件都会有一个包裹的函数，模块数量越多，导致大量的函数闭包导致bundle的体积很大，而且打包的时候还增加内存的消耗</p>
<p>scope hoisting原理：将所有的模块按照引用的顺序包裹在一个函数里，适当的重命名变量防止变量冲突</p>
<p>在webpack config的配置文件中，设置<code>mode: &#39;production&#39;,</code>就会自动开始scope hoisting</p>
<h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><p>代码分割的适用场景：js懒加载，抽离相同的代码到一个共享模块</p>
<p>代码分割搭配动态import使用，动态import并不被原生的es6支持，需要安装一个babel-plugin-syntax-dynamic-import插件</p>
<p><code>npm install --save-dev @babel/plugin-syntax-dynamic-import</code></p>
<p>在.babelrc文件中配置，引入这个插件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line">&#123;</span><br><span class="line">  // ..</span><br><span class="line">  "plugins": ["@babel/plugin-syntax-dynamic-import"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个动态加载的js函数，在组建中使用这个函数，动态import返回的是一个promise对象：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./testSync'</span>).then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(text.default);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在动态加载的时候使用jsonp的形式加载动态加载的js文件</p>
<h2 id="使用ESLint"><a href="#使用ESLint" class="headerlink" title="使用ESLint"></a>使用ESLint</h2><p>安装eslint 一套 <code>npm i eslint eslint-plugin-jsx-a11y eslint-plugin-react eslint-plugin-import -D</code></p>
<p>安装eslint-loader: <code>npm i eslint-loader -D</code></p>
<p>安装babel-eslint:<code>npm i babel-eslint -D</code></p>
<p>安装：<code>npm i eslint-config-airbnb -D</code></p>
<p>在根目录新建.eslintrc.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .eslintrc.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"node"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行构建</p>
<h2 id="webpack打包库和组件"><a href="#webpack打包库和组件" class="headerlink" title="webpack打包库和组件"></a>webpack打包库和组件</h2><p>新建项目根目录 large-number，进入项目目录,<code>npm init -y</code>初始化package.json</p>
<p>安装webpack，webpack-cli:<code>npm i webpack webpack-cli -D</code></p>
<p>在根目录新建src/index.js，写一个库函数，例如大数相加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="comment">// 大整数相加</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = a.length - <span class="number">1</span>; <span class="comment">// 从个位开始相加</span></span><br><span class="line">  <span class="keyword">let</span> j = b.length - <span class="number">1</span>; <span class="comment">// b的个位数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        x = a[i] - <span class="number">0</span>;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        y = b[j] - <span class="number">0</span>;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; </span><br><span class="line">      sum = x + y + carry;</span><br><span class="line">      <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        carry = <span class="number">1</span>;</span><br><span class="line">        sum = sum - <span class="number">10</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ret = sum + ret;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(carry) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret = carry + ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add('9999', '666');</span></span><br></pre></td></tr></table></figure>
<p>写好之后，在根目录新建webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>); <span class="comment">//npm i terser-webpack-plugin -D</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'none'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'large-number'</span>: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    <span class="string">'large-number.min'</span>: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    library: <span class="string">'largeNumber'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    libraryExport: <span class="string">'default'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(</span><br><span class="line">        &#123;<span class="attr">include</span>: <span class="regexp">/\.min\.js$/</span>&#125;</span><br><span class="line">      )</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改packagr.json，增加build命令和prepublish</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack",</span><br><span class="line">    "prepublish": "webpack" // 发布的时候使用</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>在根目录新建index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV = <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./dist/large-number.min.js'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./dist/large-number.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>npm login登陆npm账号</p>
<p>npm publish发布组件到npm库</p>
<h2 id="SSR打包"><a href="#SSR打包" class="headerlink" title="SSR打包"></a>SSR打包</h2><p>SSR指的是在服务端渲染页面然后返回给前端浏览器做显示</p>
<p>根目录新建server目录，新建server/index.js，编写服务端渲染的代码逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  global.window = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; renderToString &#125; = <span class="built_in">require</span>(<span class="string">'react-dom/server'</span>);</span><br><span class="line"><span class="keyword">const</span> SSR = <span class="built_in">require</span>(<span class="string">'../dist/search-server.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="function">(<span class="params">port</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = express();</span><br><span class="line">  app.use(express.static(<span class="string">'dist'</span>));</span><br><span class="line">  app.get(<span class="string">'/search'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> html = renderMarkup(renderToString(SSR));</span><br><span class="line">    res.status(<span class="number">200</span>).send(html);</span><br><span class="line">  &#125;);</span><br><span class="line">  app.listen(port, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server is running on port:'</span> + port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server(process.env.PORT || <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderMarkup = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">  &lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="root"&gt;<span class="subst">$&#123;str&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根目录新建webpack.ssr.js文件，编写服务端打包的webpack配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态设置entry 和 htmlWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line">setMPA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> htmlWebpackPlugin = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> entryFiles = glob.sync(path.join(__dirname, <span class="string">'./src/*/index-server.jsx'</span>));</span><br><span class="line">  <span class="built_in">Object</span>.keys(entryFiles).map(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> entryFile = entryFiles[index];</span><br><span class="line">    <span class="keyword">const</span> match = entryFile.match(<span class="regexp">/src\/(.*)\/index-server\.jsx/</span>);</span><br><span class="line">    <span class="keyword">const</span> pageName = match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(entryFile)</span><br><span class="line">    <span class="keyword">if</span>(pageName) &#123;</span><br><span class="line">      entry[pageName] = entryFile;</span><br><span class="line">      htmlWebpackPlugin.push(</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          template: path.join(__dirname, <span class="string">`src/<span class="subst">$&#123;pageName&#125;</span>/index.html`</span>),</span><br><span class="line">          filename: <span class="string">`<span class="subst">$&#123;pageName&#125;</span>.html`</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">          chunks: [<span class="string">'vendors'</span>, pageName],</span><br><span class="line">          inject: <span class="literal">true</span>,</span><br><span class="line">          minify: &#123;</span><br><span class="line">            html5: <span class="literal">true</span>,</span><br><span class="line">            preserveLineBreaks: <span class="literal">false</span>,</span><br><span class="line">            removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry, htmlWebpackPlugin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;entry, htmlWebpackPlugin&#125; = setMPA();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: entry,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]-server.js'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>, <span class="string">'eslint-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'postcss-loader'</span>, <span class="attr">options</span>: &#123;</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                overrideBrowserslist: [<span class="string">'last 2 version'</span>, <span class="string">'&gt;1%'</span>, <span class="string">'ios 7'</span>]</span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'less-loader'</span>, &#123;</span><br><span class="line">          loader: <span class="string">'px2rem-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            remUnit: <span class="number">75</span>, <span class="comment">// 转换率：1rem = 75px</span></span><br><span class="line">            remPrecision: <span class="number">8</span> <span class="comment">// 转换之后保留小数点后位数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ...htmlWebpackPlugin,</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: <span class="regexp">/(react|react-dom)/</span>,</span><br><span class="line">          name: <span class="string">'vendors'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>安装：<code>npm i express -D</code></p>
<p>新建src/search/index-server.js，编写一个服务端渲染页面的页面代码，注意使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      ssr test</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">module.exports = &lt;Index /</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>运行npm run build查看dist目录</p>
<h3 id="使用打包出来的浏览器端的html文件作为，模版可以显示样式"><a href="#使用打包出来的浏览器端的html文件作为，模版可以显示样式" class="headerlink" title="使用打包出来的浏览器端的html文件作为，模版可以显示样式"></a>使用打包出来的浏览器端的html文件作为，模版可以显示样式</h3><p>修改server/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = fs.readFileSync(path.join(__dirname, <span class="string">'../dist/search.html'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderMarkup = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 打包好的模版里面会有注释的占位符，然后用服务端渲染好的代码替换注释</span></span><br><span class="line">  <span class="keyword">return</span> template.replace(<span class="string">'&lt;!--HTML_PLACEHOLDER--&gt;'</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改search/index.html模版文件，添加一个占位符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="comment">&lt;!--HTML_PLACEHOLDER--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="服务端获取数据"><a href="#服务端获取数据" class="headerlink" title="服务端获取数据"></a>服务端获取数据</h3><p>新建server/data.json</p>
<p>修改search/index.html模版文件，添加一个数据占位符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--INITIAL_DATA_PLACEHOLDER--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改server/index.js加载数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="built_in">require</span>(<span class="string">'./data.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderMarkup = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dataStr = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="keyword">return</span> template.replace(<span class="string">'&lt;!--HTML_PLACEHOLDER--&gt;'</span>, str).replace(<span class="string">'&lt;!--INITIAL_DATA_PLACEHOLDER--&gt;'</span>, <span class="string">`&lt;script&gt;window.__initial_data=<span class="subst">$&#123;dataStr&#125;</span>&lt;/script&gt;`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把数据加载到页面，后续就可以使用数据渲染页面</p>
<h2 id="构建时候命令行的日志展示优化"><a href="#构建时候命令行的日志展示优化" class="headerlink" title="构建时候命令行的日志展示优化"></a>构建时候命令行的日志展示优化</h2><p>在webpack.config.js设置stats字段</p>
<p>stats预设值：</p>
<p><img src="/img/webpack/w16.png" alt="图片"></p>
<h3 id="Friendly-errors-webpack-plugin"><a href="#Friendly-errors-webpack-plugin" class="headerlink" title="Friendly-errors-webpack-plugin"></a>Friendly-errors-webpack-plugin</h3><p>Friendly-errors-webpack-plugin识别某些类别的webpack错误，并清理，聚合和优先级，以提供更好的开发人员体验。</p>
<p>安装：<code>npm install friendly-errors-webpack-plugin --save-dev</code></p>
<p>安装好了之后，在webpack.prod.js和webpack.dev.js中分别引入，并使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FriendlyErrorsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> FriendlyErrorsWebpackPlugin()</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>
<p>之后在运行npm run build活着npm run dev的时候，在构建成功会用绿色提示，并显示构建所需要的时间，有警告的时候会使用黄色的提示，编译报错的时候使用红色的颜色标记</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建速度、体积分析和优化</title>
    <url>/2020/06/16/webpack-optimize/</url>
    <content><![CDATA[<p><img src="/img/webpack/36.png" alt="图片"></p>
<h2 id="初级分析：构建体积和速度"><a href="#初级分析：构建体积和速度" class="headerlink" title="初级分析：构建体积和速度"></a>初级分析：构建体积和速度</h2><p>基本的分析可以使用webpack内置的stats进行构建的统计分析，例如总共消耗的时间和每个构建资源的大小，使用方法就是在根目录的package.json方法里面添加运行脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build:stats": "webpack --config webpack.prod.js --json &gt; stats.json"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run build:stats会在根目录生成一个stats.json文件，里面包含构建资源的信息，是否构架成功，大致用了多少时间构建，但是这个分析只是作为一个基础的分析，颗粒度泰国粗糙</p>
<h2 id="精细分析：构建速度分析"><a href="#精细分析：构建速度分析" class="headerlink" title="精细分析：构建速度分析"></a>精细分析：构建速度分析</h2><p>借助speed-measure-webpack-plugin 插件分析详细的构建速度，可以清晰的看到每个loader和plugin的耗时情况</p>
<p>安装：<code>npm i speed-measure-webpack-plugin -D</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> SpeedMeasireWebpackPlugin = <span class="built_in">require</span>(<span class="string">'speed-measure-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasireWebpackPlugin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在终端运行npm run build，结果：</p>
<p><img src="/img/webpack/w22.png" alt="图片"></p>
<p>速度正常的会用绿色显示，速度稍慢的会用黄色表示，速度很慢需要重点关注的会用红色表示，然后可以做一下调整的优化方便的工作</p>
<h2 id="构建体积的分析"><a href="#构建体积的分析" class="headerlink" title="构建体积的分析"></a>构建体积的分析</h2><p>借助webpack-bundle-analyzer可以分析构建体积</p>
<p>安装：<code>npm install webpack-bundle-analyzer -D</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 会在浏览器自动打开一个<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a> 页面，页面里面展示的是构建包的体积大小，可以针对性的找出是哪个包的体积大，还是某个组件的体积太大，针对性的作出处理</p>
<h2 id="高版本的webpack"><a href="#高版本的webpack" class="headerlink" title="高版本的webpack"></a>高版本的webpack</h2><p><img src="/img/webpack/w23.png" alt="图片"></p>
<h2 id="多进程-多实例构建"><a href="#多进程-多实例构建" class="headerlink" title="多进程/多实例构建"></a>多进程/多实例构建</h2><p>使用happypack实现多进程：安装<code>npm i happypack -D</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        <span class="comment">// use: ['babel-loader', 'eslint-loader']</span></span><br><span class="line">        use: [<span class="string">'happypack/loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      loaders: [<span class="string">'babel-loader'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>先看一下没有使用happypack前的构建速度,3726ms</p>
<p><img src="/img/webpack/w24.png" alt="图片"></p>
<p>使用了happypack之后的构建速度：</p>
<p><img src="/img/webpack/w24.png" alt="图片"></p>
<p>可以看到happy默认启用了三个线程构建，构建速度2605ms，速度的提升还是很明显的</p>
<p>再看一下使用webpack提供的thread-loader实现多进程的构建，安装： <code>npm i thread-loader -D</code>,</p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader'</span>, &#123;<span class="attr">loader</span>: <span class="string">'thread-loader'</span>, <span class="attr">options</span>: &#123;<span class="attr">workers</span>: <span class="number">3</span>&#125;&#125;]</span><br><span class="line">        <span class="comment">// use: ['happypack/loader']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// new HappyPack(&#123;</span></span><br><span class="line">    <span class="comment">//   loaders: ['babel-loader']</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在终端查看构建速度，2122ms</p>
<p><img src="/img/webpack/26.png" alt="图片"></p>
<h2 id="多进程并行压缩"><a href="#多进程并行压缩" class="headerlink" title="多进程并行压缩"></a>多进程并行压缩</h2><p>在webpack推荐使用TerserPlugin，安装：<code>npm install terser-webpack-plugin --save-dev</code></p>
<p>在webpack.prod.js中引入并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="literal">true</span></span><br><span class="line">    &#125;)]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>添加并行压缩前后构建时间对比：</p>
<p><img src="/img/webpack/27.png" alt="图片"></p>
<p><img src="/img/webpack/28.png" alt="图片"></p>
<h2 id="分包-预编译资源模块"><a href="#分包-预编译资源模块" class="headerlink" title="分包-预编译资源模块"></a>分包-预编译资源模块</h2><p>前面使用的HtmlWebpackExternalsPlugin，可以把一些静态资源通过cdn的方式引入，以减少构建包的体积，那么如果这种静态引入的包越多，就需要每个配置，然后在模版页面每个引入</p>
<p>可以使用DLLPlugin可以对多个组件或者框架哭进行提取</p>
<p>根目录新建webpack.dll.js配置文件，配置dll预编译的配置:先给目前使用的react相关的进行分包预编译配置，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    library: [</span><br><span class="line">      <span class="string">'react'</span>, <span class="string">'react-dom'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash].dll.js'</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">'build/library'</span>),</span><br><span class="line">    library: <span class="string">'[name]'</span></span><br><span class="line">  &#125;, </span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">      path: path.join(__dirname, <span class="string">'build/library/[name].json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在根目录的的package.json增加dll命令脚本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "dll": "webpack --config webpack.dll.js"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>运行npm run dll，会在根目录生成一个build文件夹，里面是预编译的react代码，同时会生成一个json文件，包含预编译代码的信息，</p>
<p>然后在webpack.prod.js中引用预编译的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: <span class="string">'./build/library/library.json'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h2 id="利用缓存提升二次构建的速度"><a href="#利用缓存提升二次构建的速度" class="headerlink" title="利用缓存提升二次构建的速度"></a>利用缓存提升二次构建的速度</h2><p>缓存对二次构建速度有用，先看一下没有开启缓存之前的构建速度：</p>
<p><img src="/img/webpack/29.png" alt="图片"></p>
<p>目前的项目比较小，构建一下大概2秒多一点</p>
<h3 id="babel-loader开启转换缓存"><a href="#babel-loader开启转换缓存" class="headerlink" title="babel-loader开启转换缓存"></a>babel-loader开启转换缓存</h3><p>babel转换js的语法缓存，在缓存之后下一次再构建的时候就可以直接使用缓存好的转换结果，从而提升转换的速度，开启babel-loader缓存的方法很简单，在webpack.prod.js文件中给babel-loader加一个开启缓存的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: [<span class="string">'babel-loader?cacheDirectory=true'</span>, &#123;<span class="attr">loader</span>: <span class="string">'thread-loader'</span>, <span class="attr">options</span>: &#123;<span class="attr">workers</span>: <span class="number">3</span>&#125;&#125;]</span><br><span class="line">        <span class="comment">// use: ['happypack/loader']</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>加好缓存之后，运行一次npm run build，这次build会生成缓存，在node_modules问价夹下生成一个.cache文件夹，里面存放的是缓存资源</p>
<p><img src="/img/webpack/30.png" alt="图片"></p>
<p>然后，第二次执行npm run build，因为使用了缓存，速度的提升还是有的，只不过因为项目太小了，不是很明显</p>
<p><img src="/img/webpack/31.png" alt="图片"></p>
<h3 id="terser开启压缩缓存"><a href="#terser开启压缩缓存" class="headerlink" title="terser开启压缩缓存"></a>terser开启压缩缓存</h3><p>开启压缩缓存提升压缩速度，也是很简单，在webpack.prod.js中开启terser的缓存参数就好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      cache: <span class="literal">true</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>开启压缩缓存之后，第一次运行npm run build:</p>
<p><img src="/img/webpack/32.png" alt="图片"></p>
<p>再一次运行npm run build:</p>
<p><img src="/img/webpack/33.png" alt="图片"></p>
<h3 id="针对模块的缓存"><a href="#针对模块的缓存" class="headerlink" title="针对模块的缓存"></a>针对模块的缓存</h3><p>HardSourceWebpackPlugin为模块提供中间缓存，使用方法：</p>
<p>安装：<code>npm install --save-dev hard-source-webpack-plugin</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HardSourceWebpackPlugin = <span class="built_in">require</span>(<span class="string">'hard-source-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HardSourceWebpackPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>配置好之后，第一次运行npm run build，可以看到这个插件在写入缓存</p>
<p><img src="/img/webpack/34.png" alt="图片"></p>
<p>第二次运行之后，可以看到插件提示使用了1M的缓存，速度也是有了明显的提升</p>
<p><img src="/img/webpack/35.png" alt="图片"></p>
<h2 id="缩小构建体积"><a href="#缩小构建体积" class="headerlink" title="缩小构建体积"></a>缩小构建体积</h2><p>webpack自带的配置也可以用来缩小构建体积，例如配置模块查找字段resolve,include,exclude等字段</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">'src'</span>),</span><br><span class="line">        use: [<span class="string">'babel-loader?cacheDirectory=true'</span>, &#123;<span class="attr">loader</span>: <span class="string">'thread-loader'</span>, <span class="attr">options</span>: &#123;<span class="attr">workers</span>: <span class="number">3</span>&#125;&#125;]</span><br><span class="line">        <span class="comment">// use: ['happypack/loader']</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react/umd/react.production.min.js'</span>),</span><br><span class="line">      <span class="string">'react-dom'</span>: path.resolve(__dirname, <span class="string">'./node_modules/react-dom/umd/react-dom.production.min.js'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>],</span><br><span class="line">    mainFields: [<span class="string">'main'</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h2 id="tree-shaking清除无用的代码"><a href="#tree-shaking清除无用的代码" class="headerlink" title="tree shaking清除无用的代码"></a>tree shaking清除无用的代码</h2><p>purgecss-webpack-plugin擦除无用的css，安装： <code>npm i purgecss-webpack-plugin -D</code></p>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> purgecssWebpackplugin = <span class="built_in">require</span>(<span class="string">'purgecss-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PATHS = &#123;</span><br><span class="line">  src: path.join(__dirname, <span class="string">'src'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    <span class="keyword">new</span> purgecssWebpackplugin(&#123;</span><br><span class="line">      paths: glob.sync(<span class="string">`<span class="subst">$&#123;PATHS.src&#125;</span>/**/*`</span>,  &#123; <span class="attr">nodir</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>写一行没有用到的css，运行npm run build，样式并没有被打包到bundle文件中去</p>
<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>安装loader: <code>npm install image-webpack-loader --save-dev</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.wrap(&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            mozjpeg: &#123;</span><br><span class="line">              progressive: <span class="literal">true</span>,</span><br><span class="line">              quality: <span class="number">65</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// optipng.enabled: false will disable optipng</span></span><br><span class="line">            optipng: &#123;</span><br><span class="line">              enabled: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            pngquant: &#123;</span><br><span class="line">              quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">              speed: <span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            gifsicle: &#123;</span><br><span class="line">              interlaced: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// the webp option will enable WEBP</span></span><br><span class="line">            webp: &#123;</span><br><span class="line">              quality: <span class="number">75</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h2 id="动态polyfill"><a href="#动态polyfill" class="headerlink" title="动态polyfill"></a>动态polyfill</h2><p>polyfill可以垫平不同浏览器之间的差异，但是有些浏览器版本较高，对于es6的语法支持很好，依然还是会使用polyfill，其实这些高版本的浏览器都是不需要的，所有会造成浪费，动态polyfill会判断当前浏览器的内核以及版本，动态的返回这个浏览器所需要的代码，从而提升速度</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack配置-基础配置</title>
    <url>/2020/05/13/webpack-start/</url>
    <content><![CDATA[<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>新建空的目录webpack-first</p>
<p>初始化package.json文件：进入webpack-first文件夹运行 <code>npm init -y</code>命令</p>
<p>在项目内安装webpack：命令行运行 <code>npm install webpack webpack-cli --save-dev</code></p>
<p>新建src目录，在src目录下新建index.js文件</p>
<p>安装完成，打印一下webpack版本：命令行执行<code>./node_modules/.bin/webpack</code>命令</p>
<p><img src="/img/webpack/w1.png" alt="打印webpack版本"></p>
<h2 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h2><p>webpack的配置文件是在根目录下webpack.config.js文件里面配置</p>
<p>webpack的配置主要配置的是：</p>
<ol>
<li><p>基础功能：入口，出口文件配置</p>
</li>
<li><p>转换器loader</p>
</li>
<li><p>插件plugins</p>
</li>
</ol>
<p>在根目录新建webpack.config.js这个文件，简单配置一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'boundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>在src新建helloWorld文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./src/helloWorld.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js引入helloWorld</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; helloWorld &#125; <span class="keyword">from</span> <span class="string">'./helloWorld'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(helloWorld());</span><br></pre></td></tr></table></figure>
<p>运行 <code>./node_modules/.bin/webpack</code>，不添加任何参数就是不指定配置文件，打包结果会在根目录下面的dist目录生成一个boundle.js文件</p>
<h3 id="每次运行-node-modules-bin-webpack一长串太麻烦了"><a href="#每次运行-node-modules-bin-webpack一长串太麻烦了" class="headerlink" title="每次运行./node_modules/.bin/webpack一长串太麻烦了"></a>每次运行<code>./node_modules/.bin/webpack</code>一长串太麻烦了</h3><p>./node_modules/.bin/目录下存放的是该项目所有依赖的软连接，所有需要从./node_modules/.bin/目录启动webpack来打包项目，实际上呢package.json文件可以默认读取到./node_modules/.bin/目录下的命令，在package.json增加一个scripts配置，执行build命令的时候会去./node_modules/.bin/目录下寻找webpack命令，然后执行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-first"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以直接执行<code>npm run build</code>打包项目了</p>
<h2 id="简单了解webpack核心概念"><a href="#简单了解webpack核心概念" class="headerlink" title="简单了解webpack核心概念"></a>简单了解webpack核心概念</h2><h3 id="entry指定打包的入口"><a href="#entry指定打包的入口" class="headerlink" title="entry指定打包的入口"></a>entry指定打包的入口</h3><p>webpack是模块打包器，一切皆模块，不仅是代码模块，图片、字体、文本都会当成一个个模块，模块之间的依赖关系根据入口文件entry寻找，生成一颗依赖树，在打包的过程中如果发现依赖关系，就把文件加入依赖树中，最终生成打包后的资源</p>
<p>单入口的entry是一个字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: <span class="string">'./src/index.js'</span>,</span><br></pre></td></tr></table></figure>
<p>多入口的entry是一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  pc: <span class="string">'./src/pc.js'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="output指定webpack编译打包后的文件如何输出到磁盘"><a href="#output指定webpack编译打包后的文件如何输出到磁盘" class="headerlink" title="output指定webpack编译打包后的文件如何输出到磁盘"></a>output指定webpack编译打包后的文件如何输出到磁盘</h3><p>单入口对应单个的output配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">''</span>,</span><br><span class="line">  path: <span class="string">''</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>多入口对应多个output配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  path: <span class="string">''</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="尝试多入口配置"><a href="#尝试多入口配置" class="headerlink" title="尝试多入口配置"></a>尝试多入口配置</h3><p>在src目录下新建一个login.js文件作为另外一个入口文件，随便写点什么可执行的代码进去</p>
<p>然后修改webpack.config.js这个文件，修改entry字段和output字段以配置多入口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    login: <span class="string">'./src/login.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>, <span class="comment">// 使用占位符为每个入口打包之后的文件命名</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行<code>rm -rf dist/</code>删除dist目录下已经生成的打包文件，再次执行npm run build 会发现dist目录下面新生成了两个文件：index.js,login.js</p>
<h3 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a>loaders</h3><p>对于webpack不能解析的文件（es6,7以及更高版本，less文件，image文件等）通过loaders先转换一下</p>
<p>基本用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.txt$/</span>, <span class="comment">// 匹配规则</span></span><br><span class="line">        use: <span class="string">'css-loader'</span> <span class="comment">// 要使用的loader</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>用于优化打包出来的文件，资源管理和环境变量的注入，作用于整个构建过程</p>
<h3 id="mode-webpack4新提出的概念"><a href="#mode-webpack4新提出的概念" class="headerlink" title="mode  webpack4新提出的概念"></a>mode  webpack4新提出的概念</h3><p>指定当前的构建环境：production（默认），development，none</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td>设置process.env.NODE_ENV设置为development，开启 NamedChunksPlugin和NamedModulesPlugin</td>
<td>NamedChunksPlugin：把chunk id变为一个字符串标识符。NamedModulesPlugin：当开启 HMR 的时候使用该插件会显示模块的相对路径，建议用于开发环境。</td>
</tr>
<tr>
<td>production</td>
<td>设置process.env.NODE_ENV设置为production，开启 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin</td>
<td>启用生产环境适用的插件，比如代码压缩，去注释等</td>
</tr>
</tbody>
</table>
<h2 id="了解webpack基础用法"><a href="#了解webpack基础用法" class="headerlink" title="了解webpack基础用法"></a>了解webpack基础用法</h2><h3 id="在浏览器中查看页面"><a href="#在浏览器中查看页面" class="headerlink" title="在浏览器中查看页面"></a>在浏览器中查看页面</h3><p>为了查看webpack基础用法配置之后的页面，需要 html 文件，可以使用 html-webpack-plugin 插件来帮助。</p>
<p>首先安装一下：<code>npm install html-webpack-plugin -D</code></p>
<p>新建 public 目录，并在其中新建一个 index.html 文件( 文件内容使用 html:5 快捷生成即可)</p>
<p>修改 webpack.config.js 文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先引入插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">                collapseWhitespace: <span class="literal">false</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// hash: true //是否加上hash，默认是 false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行npm run build，dist目录下新生成一个index.html的文件，打开dist目录，双击在浏览器打开这个文件，可以看到页面内显示的hello world文本</p>
<h3 id="Babel-loader-解析es6和jsx"><a href="#Babel-loader-解析es6和jsx" class="headerlink" title="Babel-loader 解析es6和jsx"></a>Babel-loader 解析es6和jsx</h3><h4 id="babel如何解析es语法"><a href="#babel如何解析es语法" class="headerlink" title="babel如何解析es语法"></a>babel如何解析es语法</h4><p>首先安装：<code>npm i @babel/core @babel/preset-env babel-loader -D</code></p>
<p>Babel-loader执行依赖Babel的配置文件.babelrc，在根目录新建.babelrc文件，写入代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>] <span class="comment">//预设一组es6的插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改webpack.config.js这个文件，增加babel-sloader的配置，手动设置一下<code>mode: &#39;development&#39;</code>，一会打包的时候可以看到打包出来的代码不会被压缩</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>测试一下：打开之前新建的src/login文件，修改代码：特意使用es6的箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/login</span></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'login page'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行npm run build可以看到在dist目录下构建出的login.js里面的函数被转换成普通的function函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dist/login.js代码片段</span></span><br><span class="line"><span class="comment">/***/</span> <span class="string">"./src/login.js"</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/login.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/*! no static exports found */</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var login = function login() &#123;\n  console.log('login page');\n&#125;;\n\n//# sourceURL=webpack:///./src/login.js?"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Babel如何转换jsx或者vuex语法"><a href="#Babel如何转换jsx或者vuex语法" class="headerlink" title="Babel如何转换jsx或者vuex语法"></a>Babel如何转换jsx或者vuex语法</h4><p>为了测试babel解析jsx语法，首先安装一下react以及要解析jsx所需要的的babel/preset-react：<code>npm i react react-dom @babel/preset-react -D</code></p>
<p>安装完成在.babelrc文件增加preset-react配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [..., <span class="string">"@babel/preset-react"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了测试效果，修改src/index.js文件的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> reactdom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world react<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reactdom.render(<span class="xml"><span class="tag">&lt;<span class="name">Index</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure>
<p>在public/index.html新增target节点 id=”root”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- public/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 新增 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行npm run build，在浏览器刷新index.html页面，发现网页显示的文本变成hello world react</p>
<h3 id="解析css"><a href="#解析css" class="headerlink" title="解析css"></a>解析css</h3><h4 id="css-loader用于加载-css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中"><a href="#css-loader用于加载-css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中" class="headerlink" title="css-loader用于加载.css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中"></a>css-loader用于加载.css文件，并且转换成commonjs文件，style-loader将样式通过style标签插入到head中</h4><p>首先安装css-loader，style-loader: <code>npm i style-loader css-loader -D</code></p>
<p>新建src/index.css文件，写入样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在index.js文件中引入这个样式，并且修改react组件使用这个样式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">react</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">"text"</span>&gt;</span>hello world react<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最后不要忘了在webpack.config.js文件配置css-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>注意loader的解析是链式解析，总右往左，所以上面的loader的执行顺序是先使用css-loader解析css，然后将解析好的文件传递给style-loader再进行下一步的工作</p>
<p>运行npm run build，在浏览器刷新index.html，可以看到文字变成了粉色</p>
<h4 id="如何使用less-loader和sass-loader"><a href="#如何使用less-loader和sass-loader" class="headerlink" title="如何使用less-loader和sass-loader"></a>如何使用less-loader和sass-loader</h4><p>less-loader和sass-loader的使用和css-loader的使用方法类似，以下以less为例，less-loader就是将less.css转换成css，</p>
<p>首先安装less 和 less-loader：<code>npm i less less-loader -D</code></p>
<p>修改刚才的index.css文件后缀名为index.less，并写点简单的样式：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.less</span></span><br><span class="line"><span class="variable">@base:</span> <span class="number">#f938ab</span>;</span><br><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@base</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.js中引入index.less</p>
<p>在webpack.config.js文件配置less-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在浏览器刷新index.html，可以看到文字变成新设置的颜色</p>
<h3 id="解析图片和字体资源"><a href="#解析图片和字体资源" class="headerlink" title="解析图片和字体资源"></a>解析图片和字体资源</h3><h4 id="file-loader解析图片文件"><a href="#file-loader解析图片文件" class="headerlink" title="file-loader解析图片文件"></a>file-loader解析图片文件</h4><p>使用<code>file-loader</code>解析文件资源，首先安装一下:<code>npm i file-loader -D</code>，安装完成之后，在src下新建一个img文件夹，用来存放图片资源，照一张漂亮的图片放进img文件夹</p>
<p>在index.js中引用这张图片：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xiaozhan <span class="keyword">from</span> <span class="string">'./img/zhanzhan.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line">      &lt;img src=&#123;xiaozhan&#125; /&gt;</span><br><span class="line">    &lt;/&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在webpack.config.js文件配置file-loader，匹配一些常用的图片文件后缀</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在浏览器刷新index.html，可以看到页面增加了一个图片文件</p>
<p><img src="/img/webpack/w3.png" alt="图片"></p>
<h4 id="file-loader解析字体"><a href="#file-loader解析字体" class="headerlink" title="file-loader解析字体"></a>file-loader解析字体</h4><p>字体文件的解析与图片文件一样可以使用file-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<h4 id="解析图片和字体文件也可以使用url-loader"><a href="#解析图片和字体文件也可以使用url-loader" class="headerlink" title="解析图片和字体文件也可以使用url-loader"></a>解析图片和字体文件也可以使用url-loader</h4><p>url-loader可以较小资源自动base64转换，看一下使用的效果</p>
<p>首先安装：<code>npm i url-loader -D</code></p>
<p>然后修改webpack.config.js的配置，把file-loader替换成url-loader</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10240</span>, <span class="comment">// 图片小于10k，webpack在打包的时候会自动用base64转换</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>找一个小于10k的图片测试一下，首先看一下使用file-loader打包的文件，dist目录下打包出来了图片文件，index.js是848k，图片文件6.9k</p>
<p><img src="/img/webpack/w4.png" alt="图片"></p>
<p>然后删除掉dist目录，使用url-loader的配置再打包一次，</p>
<p><img src="/img/webpack/w5.png" alt="图片"></p>
<p>可以看到，dist目录下打包出来的文件并没有图片文件，而index.js文件变成了857k，因为图片使用base64转行进去了，刷新页面，看到的页面和刚才一样的</p>
<h3 id="webpack中文件的监听"><a href="#webpack中文件的监听" class="headerlink" title="webpack中文件的监听"></a>webpack中文件的监听</h3><p>刚才一系列操作，每次做点什么代码上的改动都要手动build，手动刷新页面，极其不方便</p>
<p>文件的监听就是在发现源代码发生变化的时候，自动重新构建出新的输出文件</p>
<p>webpack中开启监听有两种方式：</p>
<ul>
<li>启动webpack命令时带上 –watch参数，在package.json增加一个scripts配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack",</span><br><span class="line">    "watch": "webpack --watch"</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改了之后，在命令行输入 npm run watch，命令行提示 ：webpack is watching the files…</p>
<p><img src="/img/webpack/w6.png" alt="图片"></p>
<p>然后随便做点修改，保存，webpack就会监听到文件发生了变化，就会重新构建出新的输出文件，并在命令行生成一个记录</p>
<p><img src="/img/webpack/w7.png" alt="图片"></p>
<p>这个时候在手动刷新一些浏览器，可以看到浏览器显示了修改之后的效果，这个方法的缺陷就是还是需要手动刷新浏览器</p>
<ul>
<li>webpack.config.js中配置watch: true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  watch: <span class="literal">true</span>, <span class="comment">//默认false</span></span><br><span class="line">  watchOptions: &#123;</span><br><span class="line">    ignored: <span class="regexp">/node_modules/</span>, <span class="comment">//不监听的文件夹，支持正则匹配</span></span><br><span class="line">    aggregateTimeout: <span class="number">300</span>, <span class="comment">//监听到发生变化后等待300秒再去执行</span></span><br><span class="line">    poll: <span class="number">1000</span> <span class="comment">//每秒询问1000次文件是否发生变化</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>watch: true原理：轮询判断文件的最后编辑时间是否发生变化，设置了aggregate: 300,，检测到某个文件发生了变化，不会立即执行，而是先缓存起来，等待300秒之后再去执行，如果在此期间其他的文件也发生了变化，会一起打包</p>
<p>在命令行运行npm run build，wabpack会进入监听模式。这个方法的缺陷也是需要手动刷新浏览器，所以就需要热更新</p>
<h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>webpack-dev-server配合HotModuleReplacementPlugin插件一起使用，以达到热更新的目的</p>
<p>webpack-dev-server：不刷新浏览器，不输入文件，而是放在内存中，构建速度有一定的优势</p>
<p>安装： <code>npm install webpack-dev-server</code></p>
<p>在package.json文件增加一个scripts配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack",</span><br><span class="line">    "watch": "webpack --watch",</span><br><span class="line">    "dev": "webpack-dev-server --open"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>webpack-dev-server在开发过程中是不需要使用的，所以修改webpack.config.js文件中的mode配置为development，然后引入webpack内置插件：HotModuleReplacementPlugin插件，同时设置devServer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 服务基础目录</span></span><br><span class="line">    hot: <span class="literal">true</span> <span class="comment">// 开启热更新</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>设置好了之后在命令行运行npm run dev，webpack会自动在浏览器打开页面，尝试修改，浏览器也会自动刷新修改后的内容</p>
<p>另外一种热更新的方式webpack-dev-middleWare</p>
<h4 id="webpack-dev-middleWare"><a href="#webpack-dev-middleWare" class="headerlink" title="webpack-dev-middleWare"></a>webpack-dev-middleWare</h4><p>webpack-dev-middleWare将输出的文件传送给服务器</p>
<h4 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h4><p><img src="/img/webpack/w8.png" alt="图片"></p>
<p>热更新的过程</p>
<ol>
<li><p>启动阶段，在文件系统里把文件用webpack compile进行编译，把编译好的文件传输给bundle server,bundle server让打包出来的文件以server的方式浏览器能够访问的到，</p>
</li>
<li><p>如果源代码文件发生了修改，会再次用webpack compile进行编译，编译完成后将代码发送给HMR Server，HMR Server就会知道哪些模块发生了改变，然后通知HMR Runtime哪些文件发生了变化，HMR Runtime负责更新代码，以达到不刷新浏览器改变代码的目的</p>
</li>
</ol>
<h3 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h3><p>打包后输出文件的后缀，做文件的版本的管理，在发布版本的时候，可以只更新有改动的文件，对于没有修改的文件，可以继续使用浏览器的缓存</p>
<p><img src="/img/webpack/w9.png" alt="图片"></p>
<p>由于在开发换进和生产环境可能需要不同的webpack配置，例如热更新只需要在开发环境使用，而文件指纹hash是在开发环境支持的，所有需要区分一下生产环境和开发环境的webpack配置，做法就是首先把之前的webpack.config.js改成webpack.dev.js作为开发环境的配置使用，然后新建名为webpack.prod.js文件，作为开发环境的配置使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    login: <span class="string">'./src/login.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            limit: <span class="number">10240</span>, <span class="comment">// 图片小于10k，webpack在打包的时候会自动用base64转换</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// use: 'file-loader'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|otf|ttf)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">        filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">            collapseWhitespace: <span class="literal">false</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// hash: true //是否加上hash，默认是 false</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>接着修改package.json，指定开发环境使用webpack.dev.js，生产环境使用webpack.prod.js</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// package.json</span><br><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack --config webpack.prod.js",</span><br><span class="line">    "watch": "webpack --watch",</span><br><span class="line">    "dev": "webpack-dev-server --config webpack.dev.js --open"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h4 id="JS文件指纹的设置"><a href="#JS文件指纹的设置" class="headerlink" title="JS文件指纹的设置"></a>JS文件指纹的设置</h4><p>使用ChunkHash，通过设置output的filename哈希值，因为文件指纹是在生产环境使用的，所有在webpack.prod.js配置里面修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">    filename: <span class="string">'[name]_[chunkhash:8].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build 可以看到dist目录下构建出的js文件带有后缀名hash</p>
<p><img src="/img/webpack/w10.png" alt="图片"></p>
<p>在src/index.js中修改一点文字，再次运行npm run build ，查看dist目录，文件夹里有两个构建出来的index.js文件带有不同的hash后缀，其中一个就是第二次构建的新文件</p>
<p><img src="/img/webpack/w11.png" alt="图片"></p>
<h4 id="图片、其他文件指纹设置"><a href="#图片、其他文件指纹设置" class="headerlink" title="图片、其他文件指纹设置"></a>图片、其他文件指纹设置</h4><p>使用hash，图片使用file-loader的option配置添加指纹</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash:8].[ext]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>添加好之后，运行npm run build，查看dist目录，可以看到构建出的图片文件添加了hash后缀</p>
<h4 id="css文件指纹，使用contentHash"><a href="#css文件指纹，使用contentHash" class="headerlink" title="css文件指纹，使用contentHash"></a>css文件指纹，使用contentHash</h4><p>前面提到解析css文件使用的style-loader的作用是将样式通过style标签插入到head中，css文件并没有被提构建成一个独立的文件的，所以目前是不能为css文件添加指纹</p>
<p>那么就需要借助MiniCssExtractPlugin这个插件来帮助在构建的时候把css文件提取成一个文件，并添加指纹</p>
<p>首先安装一下： <code>npm i mini-css-extract-plugin -D</code></p>
<p>然后把插件添加到plugin的数组里去，删除style-loader，使用MiniCssExtractPlugin.loader：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name]_[contenthash:8].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build查看效果</p>
<h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><h4 id="js代码压缩"><a href="#js代码压缩" class="headerlink" title="js代码压缩"></a>js代码压缩</h4><p>使用uglifyjs-webpack-plugin，插件uglifyjs-webpack-plugin是webpack4内置的插件，所以正常build构建出的代码就是默认压缩的</p>
<h4 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h4><p>使用optimize-css-assets-webpack-plugin插件进行压缩，同时需要安装css预处理器cssnano</p>
<p>首先安装下：<code>npm i optimize-css-assets-webpack-plugin -D</code></p>
<p>安装css预处理器：<code>npm i cssnano -D</code></p>
<p>在webpack.prod.js中配置使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> OpimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> OpimizeCssAssetsPlugin(&#123;</span><br><span class="line">      AccetNameRegExp: <span class="regexp">/\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>测试效果，删除dist目录，执行npm run build，查看dist目录下构建的css文件</p>
<h4 id="html文件压缩"><a href="#html文件压缩" class="headerlink" title="html文件压缩"></a>html文件压缩</h4><p>前面用到的HtmlWebpackPlugin，可以设置压缩html的参数，压缩空格、换行符号、注释，一个页面对应一个HtmlWebpackPlugin，设置<code>collapseWhitespace: true</code>压缩空格和换行，removeComments: true删除注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">        filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">        minify: &#123;</span><br><span class="line">            removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            removeComments: <span class="literal">true</span>, <span class="comment">//删除注释</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// hash: true //是否加上hash，默认是 false</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure>
<p>运行npm run build，在dist目录下找到对应的index.html文件检测效果</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>redux学习</title>
    <url>/2020/08/11/redux/</url>
    <content><![CDATA[<p>参考链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" target="_blank" rel="noopener">阮一峰老师：Redux 入门教程（二）：中间件与异步操作</a></p>
<p><a href="https://www.redux.org.cn/" target="_blank" rel="noopener">Redux 中文文档</a></p>
<p><a href="https://juejin.im/post/6856791557035524109#heading-14" target="_blank" rel="noopener">redux教程</a></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>createStore()方法可以创建一个store，该方法接受一个reducer，reducer描述如何处理store的更新</p>
<p>store是一个对象，用来保存整个应用的状态，一个应用只能有一个store，作为数据的来源</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>提供 getState() 方法获取 当前的state；</p>
</li>
<li><p>提供 dispatch(action) 方法更新 state；stroe是不可以随意修改的，只能通过store.dispatch(action)来修改</p>
</li>
<li><p>通过 subscribe(listener) 注册监听器;</p>
</li>
<li><p>通过 subscribe(listener) 返回的函数注销监听器。</p>
</li>
</ul>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>getState() 方法获取 state，state是当前的状态，state和视图层是一一对应的</p>
<h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h3><p>通过store.dispatch(action)方法触发更新store，action定义当前应该如何更新store，具体的更新操作有reducer完成</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action是一个对象，对象中不可缺少的type属性，描述如何更新store，对象中也可以根据需要定义其他的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<p>它的主要作用是根据action来更新state，返回一个新的state</p>
<p>reducer必须是一个纯函数，同样的输入必须有同样的输出，也就是说同样action和state返回的新的state也必须是一样的</p>
<h3 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h3><p>设置监听函数，一旦store发生变化，就会自动执行这个store.subscribe()，主要是用来监听store的变化更新视图层</p>
<p>store.subscribe()返回一个函数，调用返回的函数，可以解除监听</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure>
<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>一个结合react的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始的store</span></span><br><span class="line"><span class="keyword">const</span> defaultState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + action.payload;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REDUCE'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - action.payload;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testRedux</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(defaultState);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(store.getState());</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="comment">// action</span></span><br><span class="line">  <span class="keyword">const</span> addAction = &#123;<span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">const</span> reduceAction = &#123;<span class="attr">type</span>: <span class="string">'REDUCE'</span>, <span class="attr">payload</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(store.getState());</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;state&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; &#123;store.dispatch(addAction)&#125;&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; &#123;store.dispatch(reduceAction)&#125;&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>项目特别大的时候，store的结构也会很复杂，像这样子，会有很多属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store = &#123;</span><br><span class="line">  count: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  todoList: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  list: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导致reducer函数也会十分庞大</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;count, todoList&#125; = state;</span><br><span class="line">  <span class="keyword">const</span> &#123;type, payload&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: count + payload&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REDUCE'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">count</span>: count - payload&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">todoList</span>: [...todoList, <span class="string">`这是一个待办<span class="subst">$&#123;todoList.length&#125;</span>`</span>]&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是不同的action会更新store不同的属性，往往是不相关的，可以把reducer拆分成函数，不同的reducer处理不同的属性，redux提供辅助函数combineReducers来合并reducer</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countReducer = <span class="function">(<span class="params">count = defaultState.count, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;type, payload&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line">      <span class="keyword">return</span> count + payload;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REDUCE'</span>:</span><br><span class="line">      <span class="keyword">return</span> count - payload;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoReducer = <span class="function">(<span class="params">todoList = defaultState.todoList, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;type&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_TODO'</span>: </span><br><span class="line">      <span class="keyword">return</span> [...todoList, <span class="string">`这是一个待办<span class="subst">$&#123;todoList.length&#125;</span>`</span>]</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> [...todoList];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  count: countReducer, <span class="attr">todoList</span>: todoReducer</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实际开发的时候，可以把所有的reducer写在一个文件中，然后统一引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(reducers)</span><br></pre></td></tr></table></figure>
<h2 id="redux的数据流方向"><a href="#redux的数据流方向" class="headerlink" title="redux的数据流方向"></a>redux的数据流方向</h2><p>严格的单向数据流是 Redux 架构的设计核心</p>
<h3 id="redux的工作流程"><a href="#redux的工作流程" class="headerlink" title="redux的工作流程"></a>redux的工作流程</h3><p>从redux的工作流程可以看出数据的流动方向</p>
<ul>
<li><p>首先创建store：通过createStore(reducer)方法传入一个reducer，创建一个store</p>
</li>
<li><p>提前写好reducer，reducer是一个函数，接受一个当前的state和action作为参数，并在函数中做我们要做的数据处理</p>
</li>
<li><p>通过store.getState() 方法获取当前的state，state和视图层是一一对应的</p>
</li>
<li><p>用户想要更新界面，也就是要更新state，需要调用store.dispatch(action)，来改变state，action也是提前写好的</p>
</li>
<li><p>store接受到dispatch之后会自动调用reducer方法，并把当前最新的state和dispatch方法接收到的action传入其中</p>
</li>
<li><p>reducer负责根据action 更新state。并返回一个新的state</p>
</li>
<li><p>state一旦有变化，store就会调用store.subscribe(listener)，store.subscribe()接受一个函数listener，在listener中可以通过store.getState() 方法获取被reducer处理过的state，然后更新界面</p>
</li>
<li><p>如果结合react，可以把setState()方法放在listener函数中去调用，然后以此更新界面</p>
</li>
</ul>
<h2 id="异步action"><a href="#异步action" class="headerlink" title="异步action"></a>异步action</h2><p>刚才写的全部都是同步更新state，store发出action之后自动调用reducer方法，state立即更新，然后就拿新的数据更新UI层</p>
<p>但是，很多情况下，都需要从接口拉取数据，根据异步请求的知识，等接口返回数据之后，在执行reducer，然后才会用接口返回的数据更新state，再拿新的state更新UI层，这就需要异步数据流来实现，来看一下redux是如何实现异步数据流的</p>
<p>这就涉及到一个知识点，如何让reducer在接口返回了数据之后自动执行，这就需要先了解一个知识点，叫中间件</p>
<h3 id="Middleware（中间件）"><a href="#Middleware（中间件）" class="headerlink" title="Middleware（中间件）"></a>Middleware（中间件）</h3><p>Middleware可以增强store.dispatch()，可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。</p>
<p>以异步获取接口数据为例子使用中间件：</p>
<p>异步action，就是发出三种action</p>
<ol>
<li><p>在发起请求接口，发出一个action，去请求接口</p>
</li>
<li><p>接口返回数据成功后，发出一个action，调用reducer，更新store，继而获取最新的state，然后更新UI</p>
</li>
<li><p>接口返回失败的时候，发出一个action，</p>
</li>
</ol>
<p>用户触发第一个action是没有问题的，那么如何才能在接口有返回数据的时候触发第二个action去更改state呢？就需要先知道一个知识点：Action Creator，这个东西呢是用来生成action的，一般同步的action 生成比较简单，也好理解，就是返回一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addAction</span>(<span class="params">payload</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: add,</span><br><span class="line">    payload</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候</span></span><br><span class="line">store.dispatch(addAction)</span><br></pre></td></tr></table></figure>
<p>异步的action Creator，返回一个函数，这个函数首先dispatch一个同步action，然后进行异步操作，也就是请求接口的数据，这里使用原生的fetch方法，等到接口有返回数据之后，在then（）函数里调用第二个dispatch，提前写好要用的reducer，我还写了一个按钮来调用action，简单的代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tagsReducer = <span class="function">(<span class="params">tags = defaultState.tags, action: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;type, payload = &#123;&#125;&#125; = action;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'requestData'</span>: </span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">loading</span>: <span class="literal">true</span>, <span class="attr">list</span>: []&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reciveData'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">loading</span>: <span class="literal">false</span>, <span class="attr">list</span>: [...payload.list]&#125;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">return</span> &#123;...tags&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'requestData'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reciveData = <span class="function">(<span class="params">payload: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      type: <span class="string">'reciveData'</span>,</span><br><span class="line">      payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span> =&gt;</span> (dispatch: any, <span class="attr">getState</span>: any) =&gt; &#123;</span><br><span class="line">    dispatch(requestData());</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">'/api/tags'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()).then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(reciveData(json)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;() =&gt; &#123;store.dispatch(fetchData)&#125;&#125;&gt;异步获取数据&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>点了按钮之后，发现代码报错：<code>Error: Actions must be plain objects. Use custom middleware for async actions.</code>，意思就是action必须是纯对象，如果是异步 action，需要使用自定义的中间件</p>
<p>现在就知道中间件的意义了，本来action只能是一个对象，store.dispatch（action）方法也只能接受一个对象，所以现在需要一个中间件，来让store.dispatch()能够接受一个函数作为参数</p>
<p>redux-thunk就是具有这样子功能的一个中间件，首先安装一下 <code>yarn add redux-thunk</code>，然后配合redux提供的applyMiddleware使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));</span><br></pre></td></tr></table></figure>
<p>createStore可以接受applyMiddleware作为第二个参数，applyMiddleware是一个方法，接受我们要使用的中间件，然后再次点击按钮，可以正常的使用了，没有报错，现在可以正常的使用redux处理异步数据流了</p>
<p>当然支持异步能支持异步数据流的中间件不只有redux-thunk，redux-promise也是一样可以的</p>
<p>关于redux的知识点看了这些之后差不多就会使用redux了</p>
]]></content>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
</search>
